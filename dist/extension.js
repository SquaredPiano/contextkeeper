/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ([
/* 0 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.activate = activate;
exports.deactivate = deactivate;
// The module 'vscode' contains the VS Code extensibility API
// Import the module and reference it with the alias vscode in your code below
const vscode = __importStar(__webpack_require__(1));
const dotenv = __importStar(__webpack_require__(220));
const path = __importStar(__webpack_require__(25));
// Load environment variables from .env.local
dotenv.config({ path: path.resolve(__dirname, "../.env.local") });
const LintingService_1 = __webpack_require__(32);
const ContextIngestionService_1 = __webpack_require__(34);
// Import real services
const ContextService_1 = __webpack_require__(18);
const GeminiService_1 = __webpack_require__(20); // Real AI Service
const elevenlabs_1 = __webpack_require__(224); // Real Voice Service
const MockGitService_1 = __webpack_require__(21);
const MockVoiceService_1 = __webpack_require__(22);
// Import UI components
const StatusBarManager_1 = __webpack_require__(23);
const SidebarWebviewProvider_1 = __webpack_require__(24);
const IssuesTreeProvider_1 = __webpack_require__(26);
const NotificationManager_1 = __webpack_require__(27);
const CommandManager_1 = __webpack_require__(223);
// Global state
let statusBar;
let sidebarProvider;
let issuesTreeProvider;
let commandManager;
// Services (INTEGRATION POINT: Swap mock with real services)
let contextService;
let aiService;
let gitService;
let voiceService;
let lintingService;
let ingestionService;
// State
let currentContext = null;
let currentAnalysis = null;
let isAutonomousMode = false;
// This method is called when your extension is activated
// Your extension is activated the very first time the command is executed
function activate(context) {
    console.log('Autonomous Copilot extension is now active!');
    try {
        // Initialize services
        contextService = new ContextService_1.ContextService();
        // Initialize Linting Service
        lintingService = new LintingService_1.LintingService();
        lintingService.initialize(contextService);
        // Initialize Context Ingestion Service (Real Persistence)
        const outputChannel = vscode.window.createOutputChannel("ContextKeeper Ingestion");
        ingestionService = new ContextIngestionService_1.ContextIngestionService();
        // Don't await here to avoid blocking activation
        ingestionService.initialize(context, outputChannel).catch(err => {
            console.error("Failed to initialize ingestion service:", err);
            outputChannel.appendLine(`Error initializing ingestion: ${err.message}`);
        });
        // Initialize Gemini Service
        const geminiService = new GeminiService_1.GeminiService();
        aiService = geminiService;
        // Try to get API key from settings
        const ckConfig = vscode.workspace.getConfiguration('copilot');
        const apiKey = ckConfig.get('gemini.apiKey') || process.env.GEMINI_API_KEY || "";
        if (apiKey) {
            geminiService.initialize(apiKey).then(() => {
                console.log("Gemini Service initialized with API Key");
            }).catch(err => {
                console.error("Failed to initialize Gemini Service:", err);
                NotificationManager_1.NotificationManager.showError("Failed to connect to Gemini AI. Check your API Key.");
            });
        }
        else {
            console.warn("No Gemini API Key found. AI features will be disabled or mocked.");
            NotificationManager_1.NotificationManager.showError("Gemini API Key missing. Please set 'contextkeeper.gemini.apiKey' in settings.");
        }
        gitService = new MockGitService_1.MockGitService();
        // Initialize Voice Service (Real or Mock)
        const elevenLabsApiKey = ckConfig.get('elevenlabs.apiKey') || process.env.ELEVEN_LABS_API_KEY || process.env.ELEVENLABS_API_KEY || "";
        const voiceEnabled = ckConfig.get('voice.enabled', true);
        if (voiceEnabled && elevenLabsApiKey) {
            const realVoiceService = new elevenlabs_1.ElevenLabsService();
            realVoiceService.initialize(elevenLabsApiKey).then(() => {
                console.log("ElevenLabs Service initialized");
            }).catch(err => {
                console.error("Failed to initialize ElevenLabs:", err);
            });
            voiceService = realVoiceService;
        }
        else {
            console.log("Using Mock Voice Service (Voice disabled or no API key)");
            voiceService = new MockVoiceService_1.MockVoiceService();
        }
        // Initialize UI components
        statusBar = new StatusBarManager_1.StatusBarManager();
        issuesTreeProvider = new IssuesTreeProvider_1.IssuesTreeProvider();
        const treeView = vscode.window.registerTreeDataProvider('copilot.issuesTree', issuesTreeProvider);
        sidebarProvider = new SidebarWebviewProvider_1.SidebarWebviewProvider(context.extensionUri, handleWebviewMessage);
        const webviewProvider = vscode.window.registerWebviewViewProvider('copilot.mainView', sidebarProvider);
        // Set up service event listeners
        setupServiceListeners();
        // Initialize Command Manager
        commandManager = new CommandManager_1.CommandManager(context, contextService, aiService, sidebarProvider, statusBar, issuesTreeProvider);
        commandManager.registerCommands();
        // Add to subscriptions
        context.subscriptions.push(statusBar, treeView, webviewProvider, lintingService);
        // Load autonomous mode from settings
        const config = vscode.workspace.getConfiguration('copilot');
        isAutonomousMode = config.get('autonomous.enabled', false);
        // Show welcome notification
        NotificationManager_1.NotificationManager.showSuccess('Autonomous Copilot is ready!', 'Open Dashboard').then(action => {
            if (action === 'Open Dashboard') {
                vscode.commands.executeCommand('copilot.showPanel');
            }
        });
    }
    catch (error) {
        console.error("Extension activation failed:", error);
        vscode.window.showErrorMessage(`Autonomous Copilot failed to activate: ${error.message}`);
    }
}
/**
 * Set up event listeners for service events
 */
function setupServiceListeners() {
    // Listen to context service events
    contextService.on('contextCollected', (context) => {
        currentContext = context;
        sidebarProvider.updateContext(context);
    });
    // Listen to AI service events
    aiService.on('analysisStarted', () => {
        const state = {
            status: 'analyzing',
            progress: 0,
            message: 'Starting analysis',
        };
        statusBar.setState(state);
        sidebarProvider.updateState(state);
    });
    aiService.on('analysisProgress', (progress, message) => {
        const state = {
            status: 'analyzing',
            progress,
            message,
        };
        statusBar.setState(state);
        sidebarProvider.updateState(state);
    });
    aiService.on('analysisComplete', (analysis) => {
        currentAnalysis = analysis;
        // Update UI components
        const state = {
            status: 'complete',
            issuesFound: analysis.issues.length,
        };
        statusBar.setState(state);
        sidebarProvider.updateState(state);
        sidebarProvider.updateAnalysis(analysis);
        issuesTreeProvider.updateAnalysis(analysis);
        // Show notification
        NotificationManager_1.NotificationManager.showAnalysisComplete(analysis.issues.length);
        // Voice notification if enabled
        if (voiceService.isEnabled()) {
            const message = analysis.issues.length > 0
                ? `Found ${analysis.issues.length} issues in your code.`
                : 'No issues found. Your code looks great!';
            voiceService.speak(message, 'professional');
        }
    });
    aiService.on('error', (error) => {
        const state = {
            status: 'error',
            error: error.message,
        };
        statusBar.setState(state);
        sidebarProvider.showError(error.message);
        NotificationManager_1.NotificationManager.showError(`Analysis failed: ${error.message}`);
    });
}
/**
 * Register all extension commands
 */
function registerCommands(context) {
    // Analyze command
    context.subscriptions.push(vscode.commands.registerCommand('copilot.analyze', async () => {
        await runAnalysis();
    }));
    // Toggle autonomous mode
    context.subscriptions.push(vscode.commands.registerCommand('copilot.toggleAutonomous', async () => {
        isAutonomousMode = !isAutonomousMode;
        const config = vscode.workspace.getConfiguration('copilot');
        await config.update('autonomous.enabled', isAutonomousMode, true);
        if (isAutonomousMode) {
            NotificationManager_1.NotificationManager.showAutonomousStarted();
        }
        else {
            NotificationManager_1.NotificationManager.showSuccess('Autonomous mode disabled');
        }
    }));
    // Show panel
    context.subscriptions.push(vscode.commands.registerCommand('copilot.showPanel', () => {
        sidebarProvider.reveal();
    }));
    // Refresh context
    context.subscriptions.push(vscode.commands.registerCommand('copilot.refreshContext', async () => {
        await refreshContext();
    }));
    // Navigate to issue
    context.subscriptions.push(vscode.commands.registerCommand('copilot.navigateToIssue', async (file, line, column = 0) => {
        try {
            const document = await vscode.workspace.openTextDocument(file);
            const editor = await vscode.window.showTextDocument(document);
            const position = new vscode.Position(line - 1, column);
            editor.selection = new vscode.Selection(position, position);
            editor.revealRange(new vscode.Range(position, position), vscode.TextEditorRevealType.InCenter);
        }
        catch (error) {
            NotificationManager_1.NotificationManager.showError(`Cannot open file: ${error.message}`);
        }
    }));
    // Apply fix (placeholder for future implementation)
    context.subscriptions.push(vscode.commands.registerCommand('copilot.applyFix', async (issueId) => {
        NotificationManager_1.NotificationManager.showSuccess('Fix application coming soon!');
    }));
}
/**
 * Handle messages from webview
 */
async function handleWebviewMessage(message) {
    switch (message.type) {
        case 'requestContext':
            await refreshContext();
            break;
        case 'triggerAnalysis':
            await runAnalysis();
            break;
        case 'toggleAutonomous':
            await vscode.commands.executeCommand('copilot.toggleAutonomous');
            break;
        case 'navigateToIssue':
            await vscode.commands.executeCommand('copilot.navigateToIssue', message.file, message.line);
            break;
        case 'applyFix':
            await vscode.commands.executeCommand('copilot.applyFix', message.issueId);
            break;
        case 'dismissIssue':
            // Future: implement issue dismissal
            break;
    }
}
/**
 * Refresh developer context
 */
async function refreshContext() {
    try {
        const context = await contextService.collectContext();
        currentContext = context;
        sidebarProvider.updateContext(context);
    }
    catch (error) {
        NotificationManager_1.NotificationManager.showError(`Failed to collect context: ${error.message}`);
    }
}
/**
 * Run code analysis
 */
async function runAnalysis() {
    try {
        // Collect context first if needed
        if (!currentContext) {
            await refreshContext();
        }
        if (!currentContext) {
            throw new Error('No context available');
        }
        // Get current file content
        const editor = vscode.window.activeTextEditor;
        const code = editor ? editor.document.getText() : '';
        // Run analysis with progress
        await NotificationManager_1.NotificationManager.withProgress('Analyzing code...', async (progress) => {
            progress.report({ increment: 0, message: 'Collecting context' });
            // The AI service will emit progress events that update the UI
            const analysis = await aiService.analyze(code, currentContext);
            progress.report({ increment: 100, message: 'Complete!' });
            return analysis;
        });
    }
    catch (error) {
        const state = {
            status: 'error',
            error: error.message,
        };
        statusBar.setState(state);
        sidebarProvider.showError(error.message);
        await NotificationManager_1.NotificationManager.showErrorWithRetry(`Analysis failed: ${error.message}`, () => runAnalysis());
    }
}
// This method is called when your extension is deactivated
function deactivate() {
    console.log('Autonomous Copilot extension is being deactivated');
    // Clean up linting service
    if (lintingService) {
        lintingService.dispose();
    }
    // Clean up ingestion service
    if (ingestionService) {
        ingestionService.dispose();
    }
}


/***/ }),
/* 1 */
/***/ ((module) => {

"use strict";
module.exports = require("vscode");

/***/ }),
/* 2 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getLogsWithGitlog = getLogsWithGitlog;
const vscode = __importStar(__webpack_require__(1));
const GitService_1 = __webpack_require__(229);
/**
 * @deprecated Use GitService instead
 */
async function getLogsWithGitlog(repoPath) {
    const workspaceFolder = repoPath || vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
    if (!workspaceFolder) {
        throw new Error("No workspace folder found");
    }
    const gitService = new GitService_1.GitService(workspaceFolder);
    return gitService.getRecentCommits(10);
}


/***/ }),
/* 3 */,
/* 4 */
/***/ ((module) => {

"use strict";
module.exports = require("node:child_process");

/***/ }),
/* 5 */
/***/ ((module) => {

"use strict";
module.exports = require("node:util");

/***/ }),
/* 6 */
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),
/* 7 */,
/* 8 */,
/* 9 */,
/* 10 */,
/* 11 */,
/* 12 */
/***/ ((module) => {

"use strict";
module.exports = require("tty");

/***/ }),
/* 13 */
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),
/* 14 */,
/* 15 */
/***/ ((module) => {

"use strict";
module.exports = require("node:process");

/***/ }),
/* 16 */
/***/ ((module) => {

"use strict";
module.exports = require("node:os");

/***/ }),
/* 17 */
/***/ ((module) => {

"use strict";
module.exports = require("node:tty");

/***/ }),
/* 18 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ContextService = void 0;
const events_1 = __webpack_require__(19);
const vscode = __importStar(__webpack_require__(1));
const storage_1 = __webpack_require__(35);
class ContextService extends events_1.EventEmitter {
    constructor() {
        super();
        // We rely on ContextIngestionService for writing to the DB.
        // This service reads from DB and VS Code API.
    }
    /**
     * Collect comprehensive developer context from workspace and LanceDB
     */
    async collectContext() {
        try {
            // Ensure storage is connected
            await storage_1.storage.connect();
            // 1. Fetch recent events from LanceDB
            const recentEvents = await storage_1.storage.getRecentEvents(100); // Fetch last 100 events
            // 2. Process events into context structures
            const gitContext = this.processGitEvents(recentEvents);
            const fileContext = await this.collectFileContext(recentEvents);
            const timeline = this.processTimeline(recentEvents);
            const session = this.processSession(recentEvents);
            const context = {
                git: gitContext,
                files: fileContext,
                cursor: await this.collectCursorContext(),
                timeline: timeline,
                session: session,
            };
            this.emit('contextCollected', context);
            return context;
        }
        catch (error) {
            console.error('Error collecting context:', error);
            this.emit('error', error);
            throw error;
        }
    }
    getCurrentFile() {
        return vscode.window.activeTextEditor?.document.fileName || '';
    }
    getRiskyFiles() {
        // This will be re-calculated during collectContext, but we can also expose a cached version if needed.
        // For now, let's just return what we can calculate from a fresh fetch or cache.
        // To keep it simple and stateless, we'll fetch. 
        // Optimization: Cache this if performance is an issue.
        return []; // Placeholder, actual logic is in processSession/collectContext
    }
    /**
     * Process Git events from logs
     */
    processGitEvents(events) {
        const commits = events
            .filter(e => e.event_type === 'git_commit')
            .map(e => {
            const meta = JSON.parse(e.metadata);
            return {
                hash: meta.hash || 'unknown',
                message: meta.message || 'No message',
                author: meta.author || 'Unknown',
                date: new Date(e.timestamp),
            };
        });
        return {
            recentCommits: commits,
            currentBranch: 'main', // TODO: Use simple-git or VS Code Git extension API for real branch
            uncommittedChanges: [], // TODO: Use simple-git for status
        };
    }
    /**
     * Collect file-related context (VS Code API + DB History)
     */
    async collectFileContext(events) {
        // Current Open Files (VS Code API)
        const openFiles = vscode.workspace.textDocuments
            .filter(doc => doc.uri.scheme === 'file')
            .map(doc => doc.fileName);
        const activeFile = vscode.window.activeTextEditor?.document.fileName || '';
        // Recently Edited (DB History)
        const editEvents = events.filter(e => e.event_type === 'file_edit');
        const recentlyEditedMap = new Map();
        editEvents.forEach(e => {
            if (!recentlyEditedMap.has(e.file_path)) {
                const meta = JSON.parse(e.metadata);
                recentlyEditedMap.set(e.file_path, {
                    file: e.file_path,
                    timestamp: new Date(e.timestamp),
                    changes: meta.changeCount || 0
                });
            }
        });
        // Edit Frequency (DB History)
        const editFrequency = new Map();
        editEvents.forEach(e => {
            const count = editFrequency.get(e.file_path) || 0;
            editFrequency.set(e.file_path, count + 1);
        });
        return {
            openFiles,
            activeFile,
            recentlyEdited: Array.from(recentlyEditedMap.values()),
            editFrequency,
        };
    }
    /**
     * Process Timeline (DB History)
     */
    processTimeline(events) {
        const edits = events
            .filter(e => e.event_type === 'file_edit')
            .map(e => {
            const meta = JSON.parse(e.metadata);
            return {
                file: e.file_path,
                timestamp: new Date(e.timestamp),
                line: 0, // LanceDB metadata might not have line number for every edit yet, need to improve ingestion if needed
                chars: meta.changeCount || 0 // Using changeCount as proxy for "chars" or magnitude
            };
        });
        const opens = events
            .filter(e => e.event_type === 'file_open')
            .map(e => ({
            file: e.file_path,
            timestamp: new Date(e.timestamp)
        }));
        const closes = events
            .filter(e => e.event_type === 'file_close')
            .map(e => ({
            file: e.file_path,
            timestamp: new Date(e.timestamp)
        }));
        return {
            edits: edits.slice(0, 20),
            opens: opens.slice(0, 10),
            closes: closes.slice(0, 10)
        };
    }
    /**
     * Process Session Stats
     */
    processSession(events) {
        const editEvents = events.filter(e => e.event_type === 'file_edit');
        // Calculate risky files (edited frequently)
        const frequency = new Map();
        editEvents.forEach(e => {
            frequency.set(e.file_path, (frequency.get(e.file_path) || 0) + 1);
        });
        const riskyFiles = Array.from(frequency.entries())
            .filter(([_, count]) => count > 5) // Threshold
            .map(([file]) => file);
        // Estimate start time (timestamp of last event in the batch, or now if empty)
        const startTime = events.length > 0 ? new Date(events[events.length - 1].timestamp) : new Date();
        return {
            startTime,
            totalEdits: editEvents.length,
            riskyFiles
        };
    }
    /**
     * Collect cursor/selection context (VS Code API)
     */
    async collectCursorContext() {
        const editor = vscode.window.activeTextEditor;
        if (!editor) {
            return {
                file: '',
                line: 0,
                column: 0,
                currentFunction: '',
                selectedText: '',
            };
        }
        const position = editor.selection.active;
        const selectedText = editor.document.getText(editor.selection);
        let currentFunction = '';
        try {
            // Attempt to find current function using symbols
            const symbols = await vscode.commands.executeCommand('vscode.executeDocumentSymbolProvider', editor.document.uri);
            if (symbols) {
                currentFunction = this.findFunctionAtPosition(symbols, position) || '';
            }
        }
        catch (e) {
            // Ignore symbol provider errors
        }
        return {
            file: editor.document.fileName,
            line: position.line + 1,
            column: position.character + 1,
            currentFunction,
            selectedText,
        };
    }
    findFunctionAtPosition(symbols, pos) {
        for (const symbol of symbols) {
            if (symbol.range.contains(pos)) {
                if (symbol.kind === vscode.SymbolKind.Function ||
                    symbol.kind === vscode.SymbolKind.Method) {
                    return symbol.name;
                }
                const child = this.findFunctionAtPosition(symbol.children, pos);
                if (child)
                    return child;
            }
        }
        return undefined;
    }
}
exports.ContextService = ContextService;


/***/ }),
/* 19 */
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),
/* 20 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GeminiService = void 0;
const gemini_client_1 = __webpack_require__(29);
const context_builder_1 = __webpack_require__(31);
const storage_1 = __webpack_require__(36);
const events_1 = __webpack_require__(19);
class GeminiService extends events_1.EventEmitter {
    client;
    storage;
    isInitialized = false;
    batchCache = new Map();
    constructor() {
        super();
        this.client = new gemini_client_1.GeminiClient();
        this.storage = new storage_1.LanceDBStorage();
    }
    async initialize(apiKey) {
        await this.client.initialize(apiKey);
        try {
            await this.storage.connect(this.client);
        }
        catch (e) {
            console.warn("Failed to connect to LanceDB:", e);
        }
        this.isInitialized = true;
    }
    /**
     * Runs a batch analysis on the active file and potentially related files.
     * This leverages the large context window to get analysis, tests, and fixes in one go.
     */
    async analyze(code, context) {
        if (!this.isInitialized) {
            const error = new Error("GeminiService not initialized. Please check your API key settings.");
            this.emit('error', error);
            throw error;
        }
        this.emit('analysisStarted');
        try {
            const geminiContext = await context_builder_1.ContextBuilder.build({
                gitLogs: context.git.recentCommits.map(c => `${c.hash.substring(0, 7)} - ${c.message}`),
                gitDiff: "",
                openFiles: context.files.openFiles,
                activeFile: context.files.activeFile,
                errors: [],
                editHistory: context.files.recentlyEdited.map(e => ({
                    file: e.file,
                    timestamp: e.timestamp.getTime()
                }))
            }, this.storage);
            // Prepare batch payload
            const filesToAnalyze = new Map();
            filesToAnalyze.set(context.files.activeFile, code);
            // In a real scenario, we would read related files here and add them to the map
            // For now, we focus on the active file but use the batch endpoint structure
            this.emit('analysisProgress', 20, 'Sending batch context to Gemini...');
            // Use runBatch instead of analyzeCode
            const batchResult = await this.client.runBatch(filesToAnalyze, geminiContext);
            // Cache the result for future use (e.g. generateTests calls)
            this.batchCache.set(context.files.activeFile, batchResult);
            this.emit('analysisProgress', 80, 'Processing batch results...');
            // Extract analysis for the active file
            const fileResult = batchResult.files.find(f => f.file === context.files.activeFile) || batchResult.files[0];
            if (!fileResult) {
                throw new Error("No analysis result found for active file");
            }
            const analysis = {
                issues: fileResult.analysis.issues.map((i, idx) => ({
                    id: `issue-${idx}`,
                    file: context.files.activeFile,
                    line: i.line,
                    column: 0,
                    severity: i.severity || 'warning',
                    message: i.message
                })),
                suggestions: fileResult.analysis.suggestions.map(s => ({
                    type: 'refactor',
                    message: s
                })),
                riskLevel: fileResult.analysis.risk_level || 'low',
                confidence: 0.9,
                timestamp: new Date()
            };
            this.emit('analysisComplete', analysis);
            return analysis;
        }
        catch (error) {
            console.error("GeminiService Analysis Error:", error);
            this.emit('error', error);
            throw error;
        }
    }
    async generateTests(code) {
        if (!this.isInitialized) {
            throw new Error("GeminiService not initialized");
        }
        // Check cache first
        // Note: In a real app, we'd need a better cache key than just the file content or path
        // For now, we assume the last analysis run populated the cache for the active file
        for (const [key, batch] of this.batchCache.entries()) {
            const fileResult = batch.files.find(f => f.generatedTests);
            if (fileResult && fileResult.generatedTests) {
                console.log("Returning cached tests from batch analysis");
                return fileResult.generatedTests;
            }
        }
        // Fallback to single call if not cached
        return this.client.generateTests(code);
    }
    async fixError(code, error) {
        if (!this.isInitialized) {
            throw new Error("GeminiService not initialized");
        }
        // Check cache for pre-calculated fixes
        // This is a simplification; matching specific errors to cached fixes is complex
        // For now, we'll fall back to the direct call for specific error fixes
        const fix = await this.client.fixError(code, error);
        return {
            fixedCode: fix.fixedCode,
            explanation: "Fixed by Gemini AI",
            diff: ""
        };
    }
    async explainCode(code) {
        return "Explanation not implemented yet";
    }
}
exports.GeminiService = GeminiService;


/***/ }),
/* 21 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Mock Git Service
 *
 * Simulates git operations for UI development.
 * INTEGRATION: Replace with real GitService that uses simple-git.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MockGitService = void 0;
class MockGitService {
    currentBranch = 'feature/autonomous-copilot';
    commits = [];
    async createBranch(name) {
        console.log(`[Mock Git] Creating branch: ${name}`);
        await this.delay(300);
        this.currentBranch = name;
    }
    async commit(message, files) {
        console.log(`[Mock Git] Committing: ${message}`);
        console.log(`[Mock Git] Files: ${files?.join(', ') || 'all changes'}`);
        await this.delay(500);
        const commit = {
            hash: this.generateHash(),
            message,
            author: 'You',
            date: new Date(),
        };
        this.commits.unshift(commit);
    }
    async applyDiff(diff) {
        console.log(`[Mock Git] Applying diff:\n${diff}`);
        await this.delay(400);
    }
    async getCurrentBranch() {
        await this.delay(100);
        return this.currentBranch;
    }
    async getRecentCommits(count) {
        await this.delay(200);
        // Return mock commits if none exist
        if (this.commits.length === 0) {
            return this.generateMockCommits(count);
        }
        return this.commits.slice(0, count);
    }
    generateMockCommits(count) {
        const messages = [
            'feat: Add autonomous analysis mode',
            'fix: Handle edge case in context collection',
            'refactor: Simplify issue detection logic',
            'docs: Update README with usage examples',
            'test: Add unit tests for AIService',
            'style: Format code with prettier',
            'chore: Update dependencies',
        ];
        const commits = [];
        const now = Date.now();
        for (let i = 0; i < Math.min(count, messages.length); i++) {
            commits.push({
                hash: this.generateHash(),
                message: messages[i],
                author: i % 3 === 0 ? 'Teammate' : 'You',
                date: new Date(now - i * 3600000), // 1 hour apart
            });
        }
        return commits;
    }
    generateHash() {
        return Math.random().toString(36).substring(2, 9);
    }
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}
exports.MockGitService = MockGitService;


/***/ }),
/* 22 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * Mock Voice Service
 *
 * Simulates voice notifications by showing console logs.
 * INTEGRATION: Replace with real VoiceService that calls ElevenLabs API.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MockVoiceService = void 0;
const vscode = __importStar(__webpack_require__(1));
class MockVoiceService {
    enabled;
    constructor() {
        // Read from configuration
        this.enabled = vscode.workspace.getConfiguration('copilot').get('voice.enabled', true);
    }
    async speak(text, voice = 'professional') {
        if (!this.enabled) {
            console.log('[Mock Voice] Voice disabled, skipping notification');
            return;
        }
        console.log(`[Mock Voice] ðŸ”Š Would speak: "${text}" (${voice} voice)`);
        // Show notification as visual feedback
        const icon = this.getIconForVoice(voice);
        vscode.window.showInformationMessage(`${icon} ${text}`);
        // Simulate speech duration
        await this.delay(text.length * 50); // ~50ms per character
    }
    isEnabled() {
        return this.enabled;
    }
    setEnabled(enabled) {
        this.enabled = enabled;
        vscode.workspace.getConfiguration('copilot').update('voice.enabled', enabled, true);
    }
    getIconForVoice(voice) {
        switch (voice) {
            case 'casual':
                return 'ðŸ˜Ž';
            case 'encouraging':
                return 'ðŸŽ‰';
            case 'professional':
            default:
                return 'ðŸ¤–';
        }
    }
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}
exports.MockVoiceService = MockVoiceService;


/***/ }),
/* 23 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * Status Bar Manager
 *
 * Manages the status bar item that shows copilot state in the bottom bar.
 * States: Idle, Analyzing, Complete, Error
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StatusBarManager = void 0;
const vscode = __importStar(__webpack_require__(1));
class StatusBarManager {
    statusBarItem;
    currentState = { status: 'idle' };
    constructor() {
        this.statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 100);
        this.statusBarItem.command = 'copilot.showPanel';
        this.updateDisplay();
        this.statusBarItem.show();
    }
    setState(state) {
        this.currentState = state;
        this.updateDisplay();
        // Auto-reset from 'complete' state after 5 seconds
        if (state.status === 'complete') {
            setTimeout(() => {
                if (this.currentState.status === 'complete') {
                    this.setState({ status: 'idle' });
                }
            }, 5000);
        }
    }
    updateDisplay() {
        switch (this.currentState.status) {
            case 'idle':
                this.statusBarItem.text = '$(robot) Copilot: Ready';
                this.statusBarItem.backgroundColor = undefined;
                this.statusBarItem.tooltip = 'Click to open Autonomous Copilot dashboard';
                break;
            case 'analyzing':
                this.statusBarItem.text = `$(sync~spin) Copilot: ${this.currentState.message || 'Analyzing'}...`;
                this.statusBarItem.backgroundColor = undefined;
                this.statusBarItem.tooltip = `Progress: ${this.currentState.progress}%`;
                break;
            case 'complete':
                const issueText = this.currentState.issuesFound === 1 ? 'issue' : 'issues';
                this.statusBarItem.text = `$(check) Copilot: Found ${this.currentState.issuesFound} ${issueText}`;
                this.statusBarItem.backgroundColor = new vscode.ThemeColor('statusBarItem.prominentBackground');
                this.statusBarItem.tooltip = 'Analysis complete! Click to view results';
                break;
            case 'error':
                this.statusBarItem.text = '$(warning) Copilot: Error';
                this.statusBarItem.backgroundColor = new vscode.ThemeColor('statusBarItem.errorBackground');
                this.statusBarItem.tooltip = `Error: ${this.currentState.error}`;
                break;
        }
    }
    dispose() {
        this.statusBarItem.dispose();
    }
}
exports.StatusBarManager = StatusBarManager;


/***/ }),
/* 24 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * Sidebar Dashboard Webview Provider
 *
 * Manages the main dashboard webview in the sidebar.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SidebarWebviewProvider = void 0;
const path = __importStar(__webpack_require__(25));
const fs = __importStar(__webpack_require__(6));
class SidebarWebviewProvider {
    extensionUri;
    onMessage;
    _view;
    constructor(extensionUri, onMessage) {
        this.extensionUri = extensionUri;
        this.onMessage = onMessage;
    }
    resolveWebviewView(webviewView, context, _token) {
        this._view = webviewView;
        webviewView.webview.options = {
            enableScripts: true,
            localResourceRoots: [this.extensionUri],
        };
        webviewView.webview.html = this.getHtmlContent(webviewView.webview);
        // Handle messages from webview
        webviewView.webview.onDidReceiveMessage((message) => {
            this.onMessage(message);
        });
    }
    /**
     * Post a message to the webview
     */
    postMessage(message) {
        if (this._view) {
            this._view.webview.postMessage(message);
        }
    }
    /**
     * Update context in the webview
     */
    updateContext(context) {
        this.postMessage({
            type: 'contextUpdate',
            payload: context,
        });
    }
    /**
     * Update analysis results in the webview
     */
    updateAnalysis(analysis) {
        this.postMessage({
            type: 'analysisComplete',
            payload: analysis,
        });
    }
    /**
     * Update extension state
     */
    updateState(state) {
        this.postMessage({
            type: 'stateChanged',
            state,
        });
    }
    /**
     * Show error in webview
     */
    showError(message) {
        this.postMessage({
            type: 'error',
            message,
        });
    }
    /**
     * Reveal the webview
     */
    reveal() {
        if (this._view) {
            this._view.show(true);
        }
    }
    getHtmlContent(webview) {
        // Load HTML from file
        const htmlPath = path.join(this.extensionUri.fsPath, 'src', 'ui', 'webview', 'dashboard.html');
        let html = fs.readFileSync(htmlPath, 'utf8');
        // Could inject nonce for security, add resource URIs, etc.
        // For now, return as-is since we're using inline scripts/styles
        return html;
    }
}
exports.SidebarWebviewProvider = SidebarWebviewProvider;


/***/ }),
/* 25 */
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),
/* 26 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * Issues Tree View Provider
 *
 * Displays issues in a hierarchical tree structure:
 * - Root: Files with issues
 * - Children: Individual issues in each file
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IssuesTreeProvider = void 0;
const vscode = __importStar(__webpack_require__(1));
class IssuesTreeProvider {
    _onDidChangeTreeData = new vscode.EventEmitter();
    onDidChangeTreeData = this._onDidChangeTreeData.event;
    issues = [];
    groupedIssues = new Map();
    constructor() { }
    /**
     * Update the tree with new analysis results
     */
    updateAnalysis(analysis) {
        this.issues = analysis.issues;
        this.groupByFile();
        this.refresh();
    }
    /**
     * Clear all issues
     */
    clear() {
        this.issues = [];
        this.groupedIssues.clear();
        this.refresh();
    }
    /**
     * Refresh the tree view
     */
    refresh() {
        this._onDidChangeTreeData.fire();
    }
    getTreeItem(element) {
        return element;
    }
    getChildren(element) {
        if (!element) {
            // Root level: return file groups
            return Promise.resolve(this.getFileGroupItems());
        }
        else {
            // Child level: return issues for this file
            return Promise.resolve(this.getIssueItems(element.resourceUri.fsPath));
        }
    }
    groupByFile() {
        this.groupedIssues.clear();
        for (const issue of this.issues) {
            if (!this.groupedIssues.has(issue.file)) {
                this.groupedIssues.set(issue.file, []);
            }
            this.groupedIssues.get(issue.file).push(issue);
        }
    }
    getFileGroupItems() {
        const items = [];
        for (const [file, issues] of this.groupedIssues.entries()) {
            const errorCount = issues.filter(i => i.severity === 'error').length;
            const warningCount = issues.filter(i => i.severity === 'warning').length;
            const infoCount = issues.filter(i => i.severity === 'info').length;
            const fileName = file.split('/').pop() || file;
            const label = `${fileName} (${issues.length})`;
            let description = [];
            if (errorCount > 0) {
                description.push(`${errorCount} errors`);
            }
            if (warningCount > 0) {
                description.push(`${warningCount} warnings`);
            }
            if (infoCount > 0) {
                description.push(`${infoCount} info`);
            }
            const item = new IssueTreeItem(label, vscode.TreeItemCollapsibleState.Expanded, 'file');
            item.description = description.join(', ');
            item.resourceUri = vscode.Uri.file(file);
            item.iconPath = new vscode.ThemeIcon('file');
            item.contextValue = 'fileGroup';
            items.push(item);
        }
        return items;
    }
    getIssueItems(file) {
        const issues = this.groupedIssues.get(file) || [];
        return issues.map(issue => {
            const item = new IssueTreeItem(issue.message, vscode.TreeItemCollapsibleState.None, 'issue');
            item.description = `Line ${issue.line}`;
            item.tooltip = this.createTooltip(issue);
            item.iconPath = this.getIconForSeverity(issue.severity);
            item.contextValue = 'issue';
            // Click to navigate to issue
            item.command = {
                command: 'copilot.navigateToIssue',
                title: 'Go to Issue',
                arguments: [issue.file, issue.line, issue.column],
            };
            // Store issue data for context menu actions
            item.issueData = issue;
            return item;
        });
    }
    createTooltip(issue) {
        const tooltip = new vscode.MarkdownString();
        tooltip.supportHtml = true;
        tooltip.isTrusted = true;
        tooltip.appendMarkdown(`**${issue.severity.toUpperCase()}**: ${issue.message}\n\n`);
        tooltip.appendMarkdown(`**Location**: ${issue.file}:${issue.line}:${issue.column}\n\n`);
        if (issue.codeSnippet) {
            tooltip.appendMarkdown(`**Code**:\n\`\`\`\n${issue.codeSnippet}\n\`\`\`\n\n`);
        }
        if (issue.suggestedFix) {
            tooltip.appendMarkdown(`**Suggested Fix**: ${issue.suggestedFix}`);
        }
        return tooltip;
    }
    getIconForSeverity(severity) {
        switch (severity) {
            case 'error':
                return new vscode.ThemeIcon('error', new vscode.ThemeColor('editorError.foreground'));
            case 'warning':
                return new vscode.ThemeIcon('warning', new vscode.ThemeColor('editorWarning.foreground'));
            case 'info':
                return new vscode.ThemeIcon('info', new vscode.ThemeColor('editorInfo.foreground'));
            default:
                return new vscode.ThemeIcon('circle-outline');
        }
    }
}
exports.IssuesTreeProvider = IssuesTreeProvider;
/**
 * Tree item for issues tree view
 */
class IssueTreeItem extends vscode.TreeItem {
    label;
    collapsibleState;
    type;
    issueData;
    constructor(label, collapsibleState, type) {
        super(label, collapsibleState);
        this.label = label;
        this.collapsibleState = collapsibleState;
        this.type = type;
    }
}


/***/ }),
/* 27 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * Notification Manager
 *
 * Handles VSCode notifications and progress indicators.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotificationManager = void 0;
const vscode = __importStar(__webpack_require__(1));
class NotificationManager {
    /**
     * Show a progress notification for long-running tasks
     */
    static async withProgress(title, task) {
        return vscode.window.withProgress({
            location: vscode.ProgressLocation.Notification,
            title,
            cancellable: false,
        }, task);
    }
    /**
     * Show a success notification
     */
    static showSuccess(message, ...actions) {
        return vscode.window.showInformationMessage(message, ...actions);
    }
    /**
     * Show a warning notification
     */
    static showWarning(message, ...actions) {
        return vscode.window.showWarningMessage(message, ...actions);
    }
    /**
     * Show an error notification
     */
    static showError(message, ...actions) {
        return vscode.window.showErrorMessage(message, ...actions);
    }
    /**
     * Show analysis complete notification with actions
     */
    static async showAnalysisComplete(issueCount) {
        const issueText = issueCount === 1 ? 'issue' : 'issues';
        const message = issueCount > 0
            ? `ðŸ” Analysis complete! Found ${issueCount} ${issueText}.`
            : 'âœ… Analysis complete! No issues found.';
        const action = await this.showSuccess(message, 'View Results', 'Dismiss');
        if (action === 'View Results') {
            vscode.commands.executeCommand('copilot.showPanel');
        }
    }
    /**
     * Show autonomous mode notification
     */
    static async showAutonomousStarted() {
        await this.showSuccess('ðŸ¤– Autonomous mode enabled. Copilot will analyze your code when idle.', 'Got it');
    }
    /**
     * Show autonomous analysis notification
     */
    static async showAutonomousAnalysis(issueCount) {
        const issueText = issueCount === 1 ? 'issue' : 'issues';
        const action = await this.showSuccess(`ðŸ¤– Autonomous analysis complete! Found ${issueCount} ${issueText} while you were away.`, 'View Results', 'Dismiss');
        if (action === 'View Results') {
            vscode.commands.executeCommand('copilot.showPanel');
        }
    }
    /**
     * Show error with retry option
     */
    static async showErrorWithRetry(message, retryCallback) {
        const action = await this.showError(message, 'Retry', 'Dismiss');
        if (action === 'Retry') {
            await retryCallback();
        }
    }
    /**
     * Show progress with steps
     */
    static async showProgressWithSteps(title, steps) {
        await this.withProgress(title, async (progress) => {
            const increment = 100 / steps.length;
            for (const step of steps) {
                progress.report({ message: step.message });
                await step.task();
                progress.report({ increment });
            }
        });
    }
}
exports.NotificationManager = NotificationManager;


/***/ }),
/* 28 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileWatcher = void 0;
const vscode = __importStar(__webpack_require__(1));
class FileWatcher {
    watcher = null;
    disposables = [];
    lintingEndpoint;
    outputChannel;
    constructor(lintingEndpoint = "https://your-worker.workers.dev/lint") {
        this.lintingEndpoint = lintingEndpoint;
        this.outputChannel = vscode.window.createOutputChannel("Auto-Linter");
    }
    /**
     * Start watching files in the workspace
     */
    start() {
        this.outputChannel.appendLine("[FileWatcher] Starting file monitoring...");
        // Method 1: Watch specific file patterns (glob patterns)
        // This creates a watcher for TypeScript and JavaScript files
        this.watcher = vscode.workspace.createFileSystemWatcher("**/*.{ts,js,tsx,jsx}", // Watch these file types
        false, // Don't ignore creates
        false, // Don't ignore changes
        false // Don't ignore deletes
        );
        // React to file creation
        this.watcher.onDidCreate((uri) => {
            this.outputChannel.appendLine(`[FileWatcher] File created: ${uri.fsPath}`);
        });
        // React to file changes
        this.watcher.onDidChange((uri) => {
            // console.log(`[FileWatcher] File changed: ${uri.fsPath}`);
        });
        // React to file deletion
        this.watcher.onDidDelete((uri) => {
            this.outputChannel.appendLine(`[FileWatcher] File deleted: ${uri.fsPath}`);
        });
        // Method 2: Watch for document saves (best for auto-linting)
        const saveWatcher = vscode.workspace.onDidSaveTextDocument(async (document) => {
            await this.onFileSaved(document);
        });
        this.disposables.push(saveWatcher);
    }
    /**
     * Handle file save event - auto-lint the file
     */
    async onFileSaved(document) {
        // Only process certain file types
        const validExtensions = [".ts", ".js", ".tsx", ".jsx"];
        const fileExt = document.fileName.substring(document.fileName.lastIndexOf("."));
        if (!validExtensions.includes(fileExt)) {
            return; // Skip non-code files
        }
        this.outputChannel.appendLine(`[FileWatcher] Auto-linting: ${document.fileName}`);
        try {
            const code = document.getText();
            // Call your Cloudflare worker to lint the code
            const response = await fetch(this.lintingEndpoint, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ code }),
            });
            if (!response.ok) {
                throw new Error(`Linting failed: ${response.status} ${response.statusText}`);
            }
            const result = await response.json();
            // Show results to user
            if (result.warnings && result.warnings.length > 0) {
                const message = `âš ï¸ ${result.warnings.length} issue(s) found in ${path.basename(document.fileName)}`;
                vscode.window.showWarningMessage(message);
                this.outputChannel.appendLine(`=== Linting Results for ${document.fileName} ===`);
                result.warnings.forEach((warning) => {
                    this.outputChannel.appendLine(`[${warning.severity}] ${warning.message}`);
                });
                this.outputChannel.show(true);
            }
            else {
                this.outputChannel.appendLine(`âœ… No issues found in ${document.fileName}`);
            }
            // If linting produced a fixed version, optionally apply it
            if (result.linted && result.fixed && result.fixed !== code) {
                const applyFix = await vscode.window.showInformationMessage("Apply auto-fix?", "Yes", "No");
                if (applyFix === "Yes") {
                    await this.applyFix(document, result.fixed);
                }
            }
        }
        catch (error) {
            const msg = `[FileWatcher] Linting error: ${error instanceof Error ? error.message : String(error)}`;
            console.error(msg);
            this.outputChannel.appendLine(msg);
        }
    }
    /**
     * Apply the fixed code to the document
     */
    async applyFix(document, fixedCode) {
        const edit = new vscode.WorkspaceEdit();
        const fullRange = new vscode.Range(document.positionAt(0), document.positionAt(document.getText().length));
        edit.replace(document.uri, fullRange, fixedCode);
        await vscode.workspace.applyEdit(edit);
        await document.save();
        vscode.window.showInformationMessage("âœ… Auto-fix applied!");
    }
    /**
     * Stop watching files and clean up
     */
    stop() {
        if (this.watcher) {
            this.watcher.dispose();
            this.watcher = null;
        }
        this.disposables.forEach((d) => d.dispose());
        this.disposables = [];
        this.outputChannel.appendLine("[FileWatcher] Stopped file monitoring");
        this.outputChannel.dispose();
    }
}
exports.FileWatcher = FileWatcher;
// Helper for path.basename since we don't import path
const path = __importStar(__webpack_require__(25));


/***/ }),
/* 29 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GeminiClient = void 0;
const generative_ai_1 = __webpack_require__(217);
const prompts_1 = __webpack_require__(30);
const utils_1 = __webpack_require__(228);
class GeminiClient {
    apiKey = "";
    modelName = "gemini-2.5-flash";
    genAI = null;
    model = null;
    ready = false;
    lastRequestTime = 0;
    minRequestInterval = 2000; // 2 seconds between requests to be safe
    async initialize(apiKey, modelName = "gemini-2.5-flash") {
        this.apiKey = apiKey;
        this.modelName = modelName;
        this.genAI = new generative_ai_1.GoogleGenerativeAI(this.apiKey);
        this.model = this.genAI.getGenerativeModel({ model: this.modelName });
        this.ready = true;
    }
    isReady() {
        return this.ready;
    }
    enableMockMode() {
        this.modelName = "mock";
        this.model = null; // Ensure we don't use the real model
    }
    async rateLimit() {
        const now = Date.now();
        const timeSinceLast = now - this.lastRequestTime;
        if (timeSinceLast < this.minRequestInterval) {
            const wait = this.minRequestInterval - timeSinceLast;
            await new Promise(resolve => setTimeout(resolve, wait));
        }
        this.lastRequestTime = Date.now();
    }
    async getEmbedding(text) {
        if (!this.ready || !this.genAI) {
            throw new Error("GeminiClient not initialized");
        }
        await this.rateLimit();
        if (this.modelName === "mock") {
            return new Array(768).fill(0.1);
        }
        try {
            const embeddingModel = this.genAI.getGenerativeModel({ model: 'text-embedding-004' });
            const result = await embeddingModel.embedContent(text);
            return result.embedding.values;
        }
        catch (error) {
            console.error("Gemini embedding generation failed:", error);
            throw error;
        }
    }
    async runBatch(files, context) {
        if (!this.ready) {
            throw new Error("GeminiClient not initialized");
        }
        await this.rateLimit();
        if (this.modelName === "mock") {
            return {
                globalSummary: "Mock batch analysis",
                files: Array.from(files.keys()).map(f => ({
                    file: f,
                    analysis: { issues: [], suggestions: [], risk_level: 'low' },
                    generatedTests: "// Mock tests",
                    suggestedFixes: []
                }))
            };
        }
        const prompt = prompts_1.PromptTemplates.batchProcess(files, context);
        try {
            if (!this.model) {
                throw new Error("Model not initialized");
            }
            const result = await this.model.generateContent(prompt);
            const response = await result.response;
            const text = response.text();
            return this.parseBatchResponse(text);
        }
        catch (error) {
            console.error("Gemini batch analysis failed:", error);
            throw error;
        }
    }
    parseBatchResponse(text) {
        return (0, utils_1.parseJsonFromText)(text, {
            globalSummary: "Failed to parse AI response",
            files: []
        });
    }
    async analyzeCode(code, context) {
        if (!this.ready) {
            throw new Error("GeminiClient not initialized");
        }
        await this.rateLimit();
        if (this.modelName === "mock") {
            return {
                issues: [
                    { line: 1, severity: "warning", message: "Mock issue: Variable might be undefined" }
                ],
                suggestions: ["Add a null check"],
                risk_level: "low",
                summary: "Mock analysis result"
            };
        }
        const prompt = prompts_1.PromptTemplates.codeAnalysis(code, context);
        try {
            if (!this.model) {
                throw new Error("Model not initialized");
            }
            const result = await this.model.generateContent(prompt);
            const response = await result.response;
            const text = response.text();
            return this.parseAnalysis(text);
        }
        catch (error) {
            console.error("Gemini analysis failed:", error);
            throw error;
        }
    }
    parseAnalysis(text) {
        const fallback = {
            issues: [],
            suggestions: ["Failed to parse AI response. Please try again."],
            risk_level: 'low',
            summary: "Error parsing AI response."
        };
        const parsed = (0, utils_1.parseJsonFromText)(text, fallback);
        // Ensure structure even if parsed correctly but missing fields
        return {
            issues: Array.isArray(parsed.issues) ? parsed.issues : [],
            suggestions: Array.isArray(parsed.suggestions) ? parsed.suggestions : [],
            risk_level: parsed.risk_level || 'low',
            summary: parsed.summary,
            context_analysis: parsed.context_analysis
        };
    }
    async generateTests(functionCode) {
        if (!this.ready) {
            throw new Error("GeminiClient not initialized");
        }
        await this.rateLimit();
        if (this.modelName === "mock") {
            return `
describe('generatedTest', () => {
  it('should work', () => {
    expect(true).toBe(true);
  });
});`;
        }
        const prompt = prompts_1.PromptTemplates.testGeneration(functionCode);
        try {
            if (!this.model) {
                throw new Error("Model not initialized");
            }
            const result = await this.model.generateContent(prompt);
            const response = await result.response;
            return response.text();
        }
        catch (error) {
            console.error("Gemini test generation failed:", error);
            throw error;
        }
    }
    async fixError(code, error) {
        if (!this.ready) {
            throw new Error("GeminiClient not initialized");
        }
        await this.rateLimit();
        if (this.modelName === "mock") {
            return {
                fixedCode: code + "\n// Fixed by mock",
                confidence: 0.9,
                explanation: "Mock fix applied"
            };
        }
        const prompt = prompts_1.PromptTemplates.errorFix(code, error);
        try {
            if (!this.model) {
                throw new Error("Model not initialized");
            }
            const result = await this.model.generateContent(prompt);
            const response = await result.response;
            const text = response.text();
            const fallback = {
                fixedCode: code,
                confidence: 0,
                explanation: "Failed to parse fix response"
            };
            return (0, utils_1.parseJsonFromText)(text, fallback);
        }
        catch (error) {
            console.error("Gemini error fix failed:", error);
            throw error;
        }
    }
}
exports.GeminiClient = GeminiClient;


/***/ }),
/* 30 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PromptTemplates = void 0;
class PromptTemplates {
    static codeAnalysis(code, context) {
        const relatedFilesStr = context.relatedFiles.length > 0
            ? context.relatedFiles.join(", ")
            : "None";
        const commitsStr = context.recentCommits.length > 0
            ? context.recentCommits.join("\n- ")
            : "None";
        const errorsStr = context.recentErrors.length > 0
            ? context.recentErrors.join("\n- ")
            : "None";
        const pastSessionsStr = context.relevantPastSessions && context.relevantPastSessions.length > 0
            ? context.relevantPastSessions.map(s => `- ${new Date(s.timestamp).toLocaleDateString()}: ${s.summary}`).join("\n")
            : "None";
        return `
You are an expert AI coding assistant. Your task is to analyze the provided code within the context of the user's current workflow.

CONTEXT:
- Active File: ${context.activeFile || "Unknown"}
- Related Open Files: ${relatedFilesStr}
- Recent Git Commits:
- ${commitsStr}
- Recent Workspace Errors:
- ${errorsStr}
- Edit Frequency: ${context.editCount} edits in session
- Relevant Past Sessions (from Vector DB):
${pastSessionsStr}

GIT DIFF SUMMARY (Recent changes):
${context.gitDiffSummary}

CODE TO ANALYZE:
\`\`\`
${code}
\`\`\`

INSTRUCTIONS:
Analyze the code for:
1.  **Correctness**: Logic errors, bugs, potential runtime issues.
2.  **Quality**: Code smells, maintainability, readability.
3.  **Contextual Relevance**: Does this code align with the recent commits and changes?
4.  **Security**: Potential vulnerabilities.

Respond in valid JSON format ONLY:
{
  "issues": [
    { "line": number, "severity": "error"|"warning"|"info", "message": "string" }
  ],
  "suggestions": ["string"],
  "risk_level": "low"|"medium"|"high",
  "summary": "Brief summary of what the user seems to be working on based on this code and context",
  "context_analysis": "Analysis of how this code fits into the broader project context"
}
    `.trim();
    }
    static testGeneration(functionCode) {
        return `
Generate comprehensive unit tests for the following function using Vitest.
Include imports, describe blocks, and it blocks covering happy paths and edge cases.

Code:
\`\`\`
${functionCode}
\`\`\`
    `.trim();
    }
    static batchProcess(files, context) {
        const fileList = Array.from(files.entries()).map(([name, content]) => `
--- FILE: ${name} ---
${content}
---------------------
`).join("\n");
        const commitsStr = context.recentCommits.length > 0
            ? context.recentCommits.join("\n- ")
            : "None";
        return `
You are an expert AI coding assistant. Perform a deep, batched analysis on the following files.

CONTEXT:
- Recent Git Commits:
- ${commitsStr}
- Git Diff Summary:
${context.gitDiffSummary}

FILES TO PROCESS:
${fileList}

INSTRUCTIONS:
For EACH file provided above, perform the following:
1.  **Analyze**: Find bugs, logic errors, and code smells.
2.  **Generate Tests**: Create a comprehensive unit test suite (Vitest) for the file.
3.  **Suggest Fixes**: For any "error" or "high" severity issue found, provide a corrected code snippet.

Respond in valid JSON format ONLY with this structure:
{
  "globalSummary": "Overview of the changes and health of these files",
  "files": [
    {
      "file": "filename",
      "analysis": {
        "issues": [ { "line": number, "severity": "error"|"warning"|"info", "message": "string" } ],
        "suggestions": ["string"],
        "risk_level": "low"|"medium"|"high",
        "summary": "File specific summary"
      },
      "generatedTests": "string (full test file content)",
      "suggestedFixes": [
        {
          "issueId": "issue-index (0, 1, etc)",
          "fix": { "fixedCode": "string", "confidence": number, "explanation": "string" }
        }
      ]
    }
  ]
}
    `.trim();
    }
    static errorFix(code, error) {
        return `
Fix the following error in the code.

Error:
${error}

Code:
\`\`\`
${code}
\`\`\`

INSTRUCTIONS:
Analyze the error and the code. Provide a corrected version of the code.
Respond in valid JSON format ONLY:
{
  "fixedCode": "string (the complete fixed code)",
  "confidence": number (0.0 to 1.0),
  "explanation": "string (brief explanation of the fix)"
}
    `.trim();
    }
}
exports.PromptTemplates = PromptTemplates;


/***/ }),
/* 31 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ContextBuilder = void 0;
class ContextBuilder {
    static async build(raw, storage) {
        const { gitLogs = [], gitDiff = "", openFiles = [], activeFile = null, errors = [], editHistory = [], fileContents = new Map(), projectStructure, dependencies } = raw;
        // 1. Identify related files based on active file
        // Simple heuristic: same directory or imported (mock logic for imports)
        const relatedFiles = openFiles.filter(f => f !== activeFile);
        // 2. Summarize Git Diff (don't just truncate, maybe prioritize modified files)
        let diffSummary = gitDiff || "";
        if (diffSummary.length > 8000) {
            diffSummary = diffSummary.substring(0, 8000) + "\n... [truncated]";
        }
        // 3. Build open file contents map for context
        const openFileContents = new Map();
        if (activeFile && fileContents.has(activeFile)) {
            openFileContents.set(activeFile, fileContents.get(activeFile));
        }
        // Add other open files if small enough? For now just active.
        // 4. Fetch relevant past sessions from Vector DB
        let relevantPastSessions = [];
        if (storage && (activeFile || gitDiff)) {
            try {
                // Query based on active file or diff
                const query = activeFile ? `Working on ${activeFile}` : gitDiff.substring(0, 100);
                const sessions = await storage.getSimilarSessions(query, 3);
                relevantPastSessions = sessions.map(s => ({
                    summary: s.summary,
                    timestamp: s.timestamp
                }));
            }
            catch (e) {
                console.warn("Failed to fetch similar sessions:", e);
            }
        }
        return {
            activeFile: activeFile || null,
            recentCommits: gitLogs.slice(0, 10), // Increased context
            recentErrors: errors.slice(0, 5),
            gitDiffSummary: diffSummary,
            editCount: editHistory.length,
            relatedFiles: relatedFiles,
            openFileContents: openFileContents,
            projectStructure,
            dependencies,
            relevantPastSessions
        };
    }
}
exports.ContextBuilder = ContextBuilder;


/***/ }),
/* 32 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LintingService = void 0;
const vscode = __importStar(__webpack_require__(1));
const events_1 = __webpack_require__(19);
const linting_1 = __webpack_require__(33);
/**
 * LintingService manages VS Code diagnostics and triggers linting
 * on various events: git logs, file edits, opens, closes, function closes
 */
class LintingService extends events_1.EventEmitter {
    diagnosticCollection;
    contextService = null;
    disposables = [];
    isEnabled = true;
    lintingDebounceTimer = null;
    DEBOUNCE_DELAY = 500; // ms
    constructor() {
        super();
        // Create a diagnostic collection for our extension
        this.diagnosticCollection = vscode.languages.createDiagnosticCollection("contextkeeper");
    }
    /**
     * Initialize the linting service with context service
     */
    initialize(contextService) {
        this.contextService = contextService;
        this.setupEventListeners();
    }
    /**
     * Enable or disable linting
     */
    setEnabled(enabled) {
        this.isEnabled = enabled;
        if (!enabled) {
            // Clear all diagnostics when disabled
            this.diagnosticCollection.clear();
        }
    }
    /**
     * Set up event listeners for all linting triggers
     */
    setupEventListeners() {
        // 1. Git logs refresh - lint when git context is updated
        if (this.contextService) {
            // Listen for context collection events (which includes git refresh)
            this.contextService.on("contextCollected", () => {
                if (this.isEnabled) {
                    this.debouncedLintAll();
                }
            });
            // Also listen for direct git context refresh events
            this.contextService.on("gitContextRefreshed", () => {
                if (this.isEnabled) {
                    this.debouncedLintAll();
                }
            });
        }
        // 2. File edits - lint on document changes
        const changeListener = vscode.workspace.onDidChangeTextDocument(async (event) => {
            if (!this.isEnabled)
                return;
            if (event.contentChanges.length === 0)
                return;
            // Debounce linting to avoid excessive calls
            this.debouncedLint(event.document);
        });
        // 3. Files opened - lint when a file is opened
        const openListener = vscode.workspace.onDidOpenTextDocument(async (doc) => {
            if (!this.isEnabled)
                return;
            await (0, linting_1.refreshDiagnostics)(doc, this.diagnosticCollection);
        });
        // 4. Files closed - lint related files when a file is closed
        const closeListener = vscode.workspace.onDidCloseTextDocument(async (doc) => {
            if (!this.isEnabled)
                return;
            // Remove diagnostics for closed file
            this.diagnosticCollection.delete(doc.uri);
            // Optionally lint other open files that might be affected
            this.debouncedLintAll();
        });
        // 5. Function/Component closed - lint when function is closed
        if (this.contextService && "on" in this.contextService) {
            this.contextService.on("functionClosed", async (file) => {
                if (!this.isEnabled)
                    return;
                const doc = vscode.workspace.textDocuments.find((d) => d.fileName === file);
                if (doc) {
                    await (0, linting_1.refreshDiagnostics)(doc, this.diagnosticCollection);
                }
            });
        }
        // 6. File context changes - lint when active editor changes
        const editorChangeListener = vscode.window.onDidChangeActiveTextEditor(async (editor) => {
            if (!this.isEnabled)
                return;
            if (editor) {
                await (0, linting_1.refreshDiagnostics)(editor.document, this.diagnosticCollection);
            }
        });
        // Also lint on save
        const saveListener = vscode.workspace.onDidSaveTextDocument(async (doc) => {
            if (!this.isEnabled)
                return;
            await (0, linting_1.refreshDiagnostics)(doc, this.diagnosticCollection);
        });
        // Store all disposables
        this.disposables.push(changeListener, openListener, closeListener, editorChangeListener, saveListener);
    }
    /**
     * Debounced linting for a single document
     */
    debouncedLint(doc) {
        if (this.lintingDebounceTimer) {
            clearTimeout(this.lintingDebounceTimer);
        }
        this.lintingDebounceTimer = setTimeout(async () => {
            await (0, linting_1.refreshDiagnostics)(doc, this.diagnosticCollection);
            this.lintingDebounceTimer = null;
        }, this.DEBOUNCE_DELAY);
    }
    /**
     * Debounced linting for all open documents
     */
    debouncedLintAll() {
        if (this.lintingDebounceTimer) {
            clearTimeout(this.lintingDebounceTimer);
        }
        this.lintingDebounceTimer = setTimeout(async () => {
            await (0, linting_1.refreshAllDiagnostics)(this.diagnosticCollection);
            this.lintingDebounceTimer = null;
        }, this.DEBOUNCE_DELAY);
    }
    /**
     * Manually trigger linting for a specific document
     */
    async lintDocument(doc) {
        if (!this.isEnabled)
            return;
        await (0, linting_1.refreshDiagnostics)(doc, this.diagnosticCollection);
    }
    /**
     * Manually trigger linting for all open documents
     */
    async lintAllDocuments() {
        if (!this.isEnabled)
            return;
        await (0, linting_1.refreshAllDiagnostics)(this.diagnosticCollection);
    }
    /**
     * Get the diagnostic collection (for external access if needed)
     */
    getDiagnosticCollection() {
        return this.diagnosticCollection;
    }
    /**
     * Clean up and dispose of all listeners
     */
    dispose() {
        if (this.lintingDebounceTimer) {
            clearTimeout(this.lintingDebounceTimer);
        }
        this.disposables.forEach((d) => d.dispose());
        this.diagnosticCollection.dispose();
        this.disposables = [];
    }
}
exports.LintingService = LintingService;


/***/ }),
/* 33 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.refreshDiagnostics = refreshDiagnostics;
exports.refreshAllDiagnostics = refreshAllDiagnostics;
const vscode = __importStar(__webpack_require__(1));
/**
 * Lint a document and update the diagnostic collection
 * This function performs linting and creates VS Code diagnostics
 */
async function refreshDiagnostics(doc, collection) {
    // Only lint certain file types
    const validExtensions = [".ts", ".js", ".tsx", ".jsx", ".py"];
    const fileExt = doc.fileName.substring(doc.fileName.lastIndexOf("."));
    if (!validExtensions.includes(fileExt)) {
        // Clear diagnostics for non-code files
        collection.delete(doc.uri);
        return;
    }
    try {
        const code = doc.getText();
        const diagnostics = [];
        // Get linting endpoint from settings
        const config = vscode.workspace.getConfiguration("contextkeeper");
        const endpoint = config.get("lintingEndpoint") ||
            "https://contextkeeper-worker.workers.dev/lint";
        // Call linting endpoint
        const response = await fetch(endpoint, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ code }),
        });
        if (!response.ok) {
            throw new Error(`Linting failed: ${response.statusText}`);
        }
        const result = await response.json();
        // Convert warnings to VS Code diagnostics
        if (result.warnings && Array.isArray(result.warnings)) {
            for (const warning of result.warnings) {
                const line = Math.max(0, (warning.line || 1) - 1); // Convert to 0-based
                const column = Math.max(0, (warning.column || 1) - 1);
                const range = new vscode.Range(line, column, line, Math.max(column + 1, doc.lineAt(line).range.end.character));
                const severity = mapSeverityToDiagnostic(warning.severity);
                const diagnostic = new vscode.Diagnostic(range, warning.message || "Linting issue", severity);
                // Add source and code if available
                diagnostic.source = "ContextKeeper";
                if (warning.code) {
                    diagnostic.code = warning.code;
                }
                // Add related information if available
                if (warning.suggestedFix) {
                    diagnostic.relatedInformation = [
                        new vscode.DiagnosticRelatedInformation(new vscode.Location(doc.uri, range), `Suggested fix: ${warning.suggestedFix}`),
                    ];
                }
                diagnostics.push(diagnostic);
            }
        }
        // Update the diagnostic collection
        collection.set(doc.uri, diagnostics);
        // Log results
        if (diagnostics.length > 0) {
            console.log(`[Linting] Found ${diagnostics.length} issue(s) in ${doc.fileName}`);
        }
    }
    catch (error) {
        console.error(`[Linting] Error linting ${doc.fileName}:`, error);
        // On error, clear diagnostics to avoid stale data
        collection.delete(doc.uri);
    }
}
/**
 * Map severity string to VS Code DiagnosticSeverity
 */
function mapSeverityToDiagnostic(severity) {
    switch (severity?.toLowerCase()) {
        case "error":
            return vscode.DiagnosticSeverity.Error;
        case "warning":
            return vscode.DiagnosticSeverity.Warning;
        case "info":
            return vscode.DiagnosticSeverity.Information;
        default:
            return vscode.DiagnosticSeverity.Warning;
    }
}
/**
 * Lint all open documents
 */
async function refreshAllDiagnostics(collection) {
    const openDocuments = vscode.workspace.textDocuments;
    for (const doc of openDocuments) {
        await refreshDiagnostics(doc, collection);
    }
}


/***/ }),
/* 34 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ContextIngestionService = void 0;
const vscode = __importStar(__webpack_require__(1));
const storage_1 = __webpack_require__(35);
const GitWatcher_1 = __webpack_require__(219);
class ContextIngestionService {
    gitWatcher = null;
    disposables = [];
    pendingEdits = new Map();
    EDIT_DEBOUNCE_MS = 2000;
    outputChannel = null;
    constructor() { }
    async initialize(context, outputChannel) {
        console.log('Initializing Context Ingestion Service...');
        if (outputChannel) {
            this.outputChannel = outputChannel;
            this.outputChannel.appendLine('ContextIngestionService: Initializing...');
        }
        // 1. Setup Git Watcher
        const workspaceRoot = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
        if (workspaceRoot) {
            this.gitWatcher = new GitWatcher_1.GitWatcher(workspaceRoot);
            this.gitWatcher.on('commit', (commit) => this.handleGitCommit(commit));
            this.gitWatcher.start();
        }
        else {
            console.warn('No workspace root found, Git ingestion disabled.');
        }
        // 2. Setup VS Code Listeners
        this.setupListeners();
        // 3. Ensure Storage is Connected
        try {
            await storage_1.storage.connect();
            console.log('Storage connected for ingestion.');
        }
        catch (error) {
            console.error('Failed to connect storage for ingestion:', error);
        }
    }
    dispose() {
        this.gitWatcher?.stop();
        this.disposables.forEach(d => d.dispose());
        this.pendingEdits.forEach(timeout => clearTimeout(timeout));
    }
    setupListeners() {
        // File Open (Active Editor Change)
        this.disposables.push(vscode.window.onDidChangeActiveTextEditor(editor => {
            if (editor) {
                this.handleFileOpen(editor.document);
            }
        }));
        // File Close
        this.disposables.push(vscode.workspace.onDidCloseTextDocument(doc => this.handleFileClose(doc)));
        // File Edit
        this.disposables.push(vscode.workspace.onDidChangeTextDocument(event => this.handleFileEdit(event)));
    }
    async handleFileOpen(document) {
        if (this.shouldIgnoreFile(document.uri)) {
            return;
        }
        try {
            await storage_1.storage.logEvent({
                timestamp: Date.now(),
                event_type: 'file_open',
                file_path: vscode.workspace.asRelativePath(document.uri),
                metadata: JSON.stringify({
                    languageId: document.languageId,
                    lineCount: document.lineCount
                })
            });
            this.logToOutput(`[FILE_OPEN] ${vscode.workspace.asRelativePath(document.uri)}`);
        }
        catch (error) {
            console.error('Error logging file_open:', error);
        }
    }
    async handleFileClose(document) {
        if (this.shouldIgnoreFile(document.uri)) {
            return;
        }
        try {
            await storage_1.storage.logEvent({
                timestamp: Date.now(),
                event_type: 'file_close',
                file_path: vscode.workspace.asRelativePath(document.uri),
                metadata: JSON.stringify({
                    languageId: document.languageId
                })
            });
            this.logToOutput(`[FILE_CLOSE] ${vscode.workspace.asRelativePath(document.uri)}`);
        }
        catch (error) {
            console.error('Error logging file_close:', error);
        }
    }
    handleFileEdit(event) {
        const document = event.document;
        if (this.shouldIgnoreFile(document.uri)) {
            return;
        }
        if (event.contentChanges.length === 0) {
            return;
        }
        const filePath = document.uri.fsPath;
        // Debounce edits
        if (this.pendingEdits.has(filePath)) {
            clearTimeout(this.pendingEdits.get(filePath));
        }
        const timeout = setTimeout(async () => {
            this.pendingEdits.delete(filePath);
            await this.processFileEdit(document, event.contentChanges);
        }, this.EDIT_DEBOUNCE_MS);
        this.pendingEdits.set(filePath, timeout);
    }
    async processFileEdit(document, changes) {
        try {
            // Calculate a rough "diff" or summary of changes
            const changeSummary = changes.map(c => ({
                range: c.range,
                textLength: c.text.length,
                textPreview: c.text.substring(0, 50).replace(/\n/g, '\\n')
            }));
            await storage_1.storage.logEvent({
                timestamp: Date.now(),
                event_type: 'file_edit',
                file_path: vscode.workspace.asRelativePath(document.uri),
                metadata: JSON.stringify({
                    languageId: document.languageId,
                    changeCount: changes.length,
                    changes: changeSummary
                })
            });
            this.logToOutput(`[FILE_EDIT] ${vscode.workspace.asRelativePath(document.uri)} (${changes.length} changes)`);
        }
        catch (error) {
            console.error('Error logging file_edit:', error);
        }
    }
    async handleGitCommit(commit) {
        try {
            await storage_1.storage.logEvent({
                timestamp: Date.now(), // Or parse commit.date
                event_type: 'git_commit',
                file_path: 'root', // Commits affect the repo
                metadata: JSON.stringify({
                    hash: commit.hash,
                    message: commit.message,
                    author: commit.author,
                    files: commit.files
                })
            });
            this.logToOutput(`[GIT_COMMIT] ${commit.hash} - ${commit.message}`);
            console.log(`Logged git commit: ${commit.hash}`);
        }
        catch (error) {
            console.error('Error logging git_commit:', error);
        }
    }
    shouldIgnoreFile(uri) {
        const fsPath = uri.fsPath;
        return (uri.scheme !== 'file' ||
            fsPath.includes('.git') ||
            fsPath.includes('node_modules') ||
            fsPath.includes('.next') ||
            fsPath.includes('dist') ||
            fsPath.includes('out') ||
            fsPath.includes('build'));
    }
    logToOutput(message) {
        if (this.outputChannel) {
            this.outputChannel.appendLine(`[${new Date().toLocaleTimeString()}] ${message}`);
        }
    }
}
exports.ContextIngestionService = ContextIngestionService;


/***/ }),
/* 35 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.storage = void 0;
const storage_1 = __webpack_require__(36);
exports.storage = new storage_1.LanceDBStorage();
__exportStar(__webpack_require__(218), exports);
__exportStar(__webpack_require__(36), exports);
__exportStar(__webpack_require__(216), exports);


/***/ }),
/* 36 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LanceDBStorage = void 0;
const lancedb = __importStar(__webpack_require__(37));
const uuid_1 = __webpack_require__(199);
const embeddings_1 = __webpack_require__(216);
class LanceDBStorage {
    db = null;
    eventsTable = null;
    sessionsTable = null;
    actionsTable = null;
    embeddingService = null;
    async connect(embeddingService) {
        if (embeddingService) {
            this.embeddingService = embeddingService;
        }
        if (this.db) {
            return;
        } // Already connected
        const uri = `db://${process.env.LANCEDB_DB_NAME}`;
        this.db = await lancedb.connect(uri, {
            apiKey: process.env.LANCE_DB_API_KEY,
            region: 'us-east-1'
        });
        await this.initializeTables();
    }
    async initializeTables() {
        if (!this.db) {
            throw new Error('Database not connected');
        }
        // Create or open events table
        const tableNames = await this.db.tableNames();
        if (!tableNames.includes('events')) {
            this.eventsTable = await this.db.createTable('events', [
                {
                    id: (0, uuid_1.v4)(),
                    timestamp: 0, // Old timestamp to avoid interfering with queries
                    event_type: 'file_open',
                    file_path: '/init',
                    metadata: '{}'
                }
            ]);
        }
        else {
            this.eventsTable = await this.db.openTable('events');
        }
        if (!tableNames.includes('sessions')) {
            this.sessionsTable = await this.db.createTable('sessions', [
                {
                    id: (0, uuid_1.v4)(),
                    timestamp: 0,
                    summary: 'init',
                    embedding: new Array(768).fill(0),
                    project: 'init',
                    event_count: 0
                }
            ]);
        }
        else {
            this.sessionsTable = await this.db.openTable('sessions');
        }
        if (!tableNames.includes('actions')) {
            this.actionsTable = await this.db.createTable('actions', [
                {
                    id: (0, uuid_1.v4)(),
                    session_id: 'init',
                    timestamp: 0,
                    description: 'init',
                    diff: '',
                    files: '[]',
                    embedding: new Array(768).fill(0)
                }
            ]);
        }
        else {
            this.actionsTable = await this.db.openTable('actions');
        }
    }
    async getEmbedding(text) {
        if (this.embeddingService) {
            return this.embeddingService.getEmbedding(text);
        }
        return (0, embeddings_1.generateEmbedding)(text);
    }
    async logEvent(event) {
        if (!this.eventsTable) {
            throw new Error('Events table not initialized');
        }
        const record = {
            id: (0, uuid_1.v4)(),
            ...event,
            metadata: typeof event.metadata === 'string' ? event.metadata : JSON.stringify(event.metadata || {})
        };
        await this.eventsTable.add([record]);
    }
    async createSession(summary, project) {
        if (!this.sessionsTable) {
            throw new Error('Sessions table not initialized');
        }
        const embedding = await this.getEmbedding(summary);
        const session = {
            id: (0, uuid_1.v4)(),
            timestamp: Date.now(),
            summary,
            embedding,
            project,
            event_count: 0
        };
        await this.sessionsTable.add([session]);
        return session;
    }
    async addAction(action) {
        if (!this.actionsTable) {
            throw new Error('Actions table not initialized');
        }
        const embedding = await this.getEmbedding(action.description);
        const record = {
            id: (0, uuid_1.v4)(),
            ...action,
            embedding,
            files: typeof action.files === 'string' ? action.files : JSON.stringify(action.files || [])
        };
        await this.actionsTable.add([record]);
    }
    async getLastSession() {
        if (!this.sessionsTable) {
            throw new Error('Sessions table not initialized');
        }
        // Assuming append-only, we want the last inserted. 
        // Ideally we sort by timestamp DESC.
        // LanceDB JS SDK might not support sort() directly in all versions, 
        // but let's try to fetch more and sort in memory if needed, or rely on insertion order.
        // For robustness, let's fetch the last few and sort.
        const results = await this.sessionsTable
            .query()
            .limit(10) // Fetch last 10 to be safe
            .toArray();
        if (results.length === 0) {
            return null;
        }
        // Sort by timestamp descending
        const sorted = results.sort((a, b) => b.timestamp - a.timestamp);
        return sorted[0];
    }
    async getSimilarSessions(queryText, topK = 5) {
        if (!this.sessionsTable) {
            throw new Error('Sessions table not initialized');
        }
        const embedding = await this.getEmbedding(queryText);
        const results = await this.sessionsTable
            .vectorSearch(embedding)
            .limit(topK)
            .toArray();
        return results;
    }
    async getRecentEvents(limit = 50) {
        if (!this.eventsTable) {
            // Auto-initialize if not ready (lazy loading)
            if (this.db) {
                await this.initializeTables();
            }
            else {
                await this.connect();
            }
            if (!this.eventsTable) {
                throw new Error('Events table could not be initialized');
            }
        }
        // Fetch more than limit to ensure we get the absolute latest if they are not strictly ordered on disk
        // But usually they are.
        const results = await this.eventsTable
            .query()
            .limit(limit * 2)
            .toArray();
        // Sort by timestamp descending
        const sorted = results.sort((a, b) => b.timestamp - a.timestamp);
        return sorted.slice(0, limit);
    }
    /**
     * Retrieves the file path of the most recent file edit or open event.
     * Useful for determining where the user left off.
     */
    async getLastActiveFile() {
        if (!this.eventsTable) {
            throw new Error('Events table not initialized');
        }
        const results = await this.eventsTable
            .query()
            .where("event_type IN ('file_edit', 'file_open')")
            .limit(10)
            .toArray();
        if (results.length === 0) {
            return null;
        }
        const sorted = results.sort((a, b) => b.timestamp - a.timestamp);
        return sorted[0].file_path;
    }
    // Helper for testing/cleanup
    async clearAllTables() {
        if (!this.db) {
            throw new Error('Database not connected');
        }
        const tables = ['events', 'sessions', 'actions'];
        for (const table of tables) {
            try {
                await this.db.dropTable(table);
            }
            catch (e) {
                // Ignore if table doesn't exist
            }
        }
        // Re-initialize to create empty tables
        await this.initializeTables();
    }
}
exports.LanceDBStorage = LanceDBStorage;


/***/ }),
/* 37 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// SPDX-License-Identifier: Apache-2.0
// SPDX-FileCopyrightText: Copyright The LanceDB Authors
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.packBits = exports.rerankers = exports.PermutationBuilder = exports.permutationBuilder = exports.embedding = exports.MergeInsertBuilder = exports.OAuthHeaderProvider = exports.StaticHeaderProvider = exports.HeaderProvider = exports.Table = exports.Index = exports.Occur = exports.Operator = exports.FullTextQueryType = exports.BooleanQuery = exports.MultiMatchQuery = exports.BoostQuery = exports.PhraseQuery = exports.MatchQuery = exports.RecordBatchIterator = exports.TakeQuery = exports.VectorQuery = exports.QueryBase = exports.Query = exports.Session = exports.Connection = exports.VectorColumnOptions = exports.MakeArrowTableOptions = exports.makeArrowTable = exports.TagContents = exports.Tags = exports.NativeJsHeaderProvider = void 0;
exports.connect = connect;
const connection_1 = __webpack_require__(38);
const native_js_1 = __webpack_require__(188);
// Re-export native header provider for use with connectWithHeaderProvider
var native_js_2 = __webpack_require__(188);
Object.defineProperty(exports, "NativeJsHeaderProvider", ({ enumerable: true, get: function () { return native_js_2.JsHeaderProvider; } }));
var native_js_3 = __webpack_require__(188);
Object.defineProperty(exports, "Tags", ({ enumerable: true, get: function () { return native_js_3.Tags; } }));
Object.defineProperty(exports, "TagContents", ({ enumerable: true, get: function () { return native_js_3.TagContents; } }));
var arrow_1 = __webpack_require__(39);
Object.defineProperty(exports, "makeArrowTable", ({ enumerable: true, get: function () { return arrow_1.makeArrowTable; } }));
Object.defineProperty(exports, "MakeArrowTableOptions", ({ enumerable: true, get: function () { return arrow_1.MakeArrowTableOptions; } }));
Object.defineProperty(exports, "VectorColumnOptions", ({ enumerable: true, get: function () { return arrow_1.VectorColumnOptions; } }));
var connection_2 = __webpack_require__(38);
Object.defineProperty(exports, "Connection", ({ enumerable: true, get: function () { return connection_2.Connection; } }));
var native_js_4 = __webpack_require__(188);
Object.defineProperty(exports, "Session", ({ enumerable: true, get: function () { return native_js_4.Session; } }));
var query_1 = __webpack_require__(187);
Object.defineProperty(exports, "Query", ({ enumerable: true, get: function () { return query_1.Query; } }));
Object.defineProperty(exports, "QueryBase", ({ enumerable: true, get: function () { return query_1.QueryBase; } }));
Object.defineProperty(exports, "VectorQuery", ({ enumerable: true, get: function () { return query_1.VectorQuery; } }));
Object.defineProperty(exports, "TakeQuery", ({ enumerable: true, get: function () { return query_1.TakeQuery; } }));
Object.defineProperty(exports, "RecordBatchIterator", ({ enumerable: true, get: function () { return query_1.RecordBatchIterator; } }));
Object.defineProperty(exports, "MatchQuery", ({ enumerable: true, get: function () { return query_1.MatchQuery; } }));
Object.defineProperty(exports, "PhraseQuery", ({ enumerable: true, get: function () { return query_1.PhraseQuery; } }));
Object.defineProperty(exports, "BoostQuery", ({ enumerable: true, get: function () { return query_1.BoostQuery; } }));
Object.defineProperty(exports, "MultiMatchQuery", ({ enumerable: true, get: function () { return query_1.MultiMatchQuery; } }));
Object.defineProperty(exports, "BooleanQuery", ({ enumerable: true, get: function () { return query_1.BooleanQuery; } }));
Object.defineProperty(exports, "FullTextQueryType", ({ enumerable: true, get: function () { return query_1.FullTextQueryType; } }));
Object.defineProperty(exports, "Operator", ({ enumerable: true, get: function () { return query_1.Operator; } }));
Object.defineProperty(exports, "Occur", ({ enumerable: true, get: function () { return query_1.Occur; } }));
var indices_1 = __webpack_require__(192);
Object.defineProperty(exports, "Index", ({ enumerable: true, get: function () { return indices_1.Index; } }));
var table_1 = __webpack_require__(185);
Object.defineProperty(exports, "Table", ({ enumerable: true, get: function () { return table_1.Table; } }));
var header_1 = __webpack_require__(193);
Object.defineProperty(exports, "HeaderProvider", ({ enumerable: true, get: function () { return header_1.HeaderProvider; } }));
Object.defineProperty(exports, "StaticHeaderProvider", ({ enumerable: true, get: function () { return header_1.StaticHeaderProvider; } }));
Object.defineProperty(exports, "OAuthHeaderProvider", ({ enumerable: true, get: function () { return header_1.OAuthHeaderProvider; } }));
var merge_1 = __webpack_require__(186);
Object.defineProperty(exports, "MergeInsertBuilder", ({ enumerable: true, get: function () { return merge_1.MergeInsertBuilder; } }));
exports.embedding = __webpack_require__(194);
var permutation_1 = __webpack_require__(196);
Object.defineProperty(exports, "permutationBuilder", ({ enumerable: true, get: function () { return permutation_1.permutationBuilder; } }));
Object.defineProperty(exports, "PermutationBuilder", ({ enumerable: true, get: function () { return permutation_1.PermutationBuilder; } }));
exports.rerankers = __webpack_require__(197);
var util_1 = __webpack_require__(191);
Object.defineProperty(exports, "packBits", ({ enumerable: true, get: function () { return util_1.packBits; } }));
async function connect(uriOrOptions, optionsOrSession, sessionOrHeaderProvider, headerProvider) {
    let uri;
    let finalOptions = {};
    let finalHeaderProvider;
    if (typeof uriOrOptions !== "string") {
        // First overload: connect(options)
        const { uri: uri_, ...opts } = uriOrOptions;
        uri = uri_;
        finalOptions = opts;
    }
    else {
        // Second overload: connect(uri, options?, session?, headerProvider?)
        uri = uriOrOptions;
        // Handle optionsOrSession parameter
        if (optionsOrSession && "inner" in optionsOrSession) {
            // Second param is session, so no options provided
            finalOptions = {};
        }
        else {
            // Second param is options
            finalOptions = optionsOrSession || {};
        }
        // Handle sessionOrHeaderProvider parameter
        if (sessionOrHeaderProvider &&
            (typeof sessionOrHeaderProvider === "function" ||
                "getHeaders" in sessionOrHeaderProvider)) {
            // Third param is header provider
            finalHeaderProvider = sessionOrHeaderProvider;
        }
        else {
            // Third param is session, header provider is fourth param
            finalHeaderProvider = headerProvider;
        }
    }
    if (!uri) {
        throw new Error("uri is required");
    }
    finalOptions = finalOptions ?? {};
    finalOptions.storageOptions = (0, connection_1.cleanseStorageOptions)(finalOptions.storageOptions);
    // Create native header provider if one was provided
    let nativeProvider;
    if (finalHeaderProvider) {
        if (typeof finalHeaderProvider === "function") {
            nativeProvider = new native_js_1.JsHeaderProvider(finalHeaderProvider);
        }
        else if (finalHeaderProvider &&
            typeof finalHeaderProvider.getHeaders === "function") {
            nativeProvider = new native_js_1.JsHeaderProvider(async () => finalHeaderProvider.getHeaders());
        }
    }
    const nativeConn = await native_js_1.Connection.new(uri, finalOptions, nativeProvider);
    return new connection_1.LocalConnection(nativeConn);
}


/***/ }),
/* 38 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// SPDX-License-Identifier: Apache-2.0
// SPDX-FileCopyrightText: Copyright The LanceDB Authors
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LocalConnection = exports.Connection = void 0;
exports.cleanseStorageOptions = cleanseStorageOptions;
const arrow_1 = __webpack_require__(39);
const arrow_2 = __webpack_require__(39);
const registry_1 = __webpack_require__(182);
const sanitize_1 = __webpack_require__(184);
const table_1 = __webpack_require__(185);
/**
 * A LanceDB Connection that allows you to open tables and create new ones.
 *
 * Connection could be local against filesystem or remote against a server.
 *
 * A Connection is intended to be a long lived object and may hold open
 * resources such as HTTP connection pools.  This is generally fine and
 * a single connection should be shared if it is going to be used many
 * times. However, if you are finished with a connection, you may call
 * close to eagerly free these resources.  Any call to a Connection
 * method after it has been closed will result in an error.
 *
 * Closing a connection is optional.  Connections will automatically
 * be closed when they are garbage collected.
 *
 * Any created tables are independent and will continue to work even if
 * the underlying connection has been closed.
 * @hideconstructor
 */
class Connection {
    [Symbol.for("nodejs.util.inspect.custom")]() {
        return this.display();
    }
}
exports.Connection = Connection;
/** @hideconstructor */
class LocalConnection extends Connection {
    inner;
    /** @hidden */
    constructor(inner) {
        super();
        this.inner = inner;
    }
    isOpen() {
        return this.inner.isOpen();
    }
    close() {
        this.inner.close();
    }
    display() {
        return this.inner.display();
    }
    async tableNames(namespaceOrOptions, options) {
        // Detect if first argument is namespace array or options object
        let namespace;
        let tableNamesOptions;
        if (Array.isArray(namespaceOrOptions)) {
            // First argument is namespace array
            namespace = namespaceOrOptions;
            tableNamesOptions = options;
        }
        else {
            // First argument is options object (backwards compatibility)
            namespace = undefined;
            tableNamesOptions = namespaceOrOptions;
        }
        return this.inner.tableNames(namespace ?? [], tableNamesOptions?.startAfter, tableNamesOptions?.limit);
    }
    async openTable(name, namespace, options) {
        const innerTable = await this.inner.openTable(name, namespace ?? [], cleanseStorageOptions(options?.storageOptions), options?.indexCacheSize);
        return new table_1.LocalTable(innerTable);
    }
    async cloneTable(targetTableName, sourceUri, options) {
        const innerTable = await this.inner.cloneTable(targetTableName, sourceUri, options?.targetNamespace ?? [], options?.sourceVersion ?? null, options?.sourceTag ?? null, options?.isShallow ?? true);
        return new table_1.LocalTable(innerTable);
    }
    getStorageOptions(options) {
        if (options?.dataStorageVersion !== undefined) {
            if (options.storageOptions === undefined) {
                options.storageOptions = {};
            }
            options.storageOptions["newTableDataStorageVersion"] =
                options.dataStorageVersion;
        }
        if (options?.enableV2ManifestPaths !== undefined) {
            if (options.storageOptions === undefined) {
                options.storageOptions = {};
            }
            options.storageOptions["newTableEnableV2ManifestPaths"] =
                options.enableV2ManifestPaths ? "true" : "false";
        }
        return cleanseStorageOptions(options?.storageOptions);
    }
    async createTable(nameOrOptions, dataOrNamespace, namespaceOrOptions, options) {
        if (typeof nameOrOptions !== "string" && "name" in nameOrOptions) {
            // First overload: createTable(options, namespace?)
            const { name, data, ...createOptions } = nameOrOptions;
            const namespace = dataOrNamespace;
            return this._createTableImpl(name, data, namespace, createOptions);
        }
        // Second overload: createTable(name, data, namespace?, options?)
        const name = nameOrOptions;
        const data = dataOrNamespace;
        // Detect if third argument is namespace array or options object
        let namespace;
        let createOptions;
        if (Array.isArray(namespaceOrOptions)) {
            // Third argument is namespace array
            namespace = namespaceOrOptions;
            createOptions = options;
        }
        else {
            // Third argument is options object (backwards compatibility)
            namespace = undefined;
            createOptions = namespaceOrOptions;
        }
        return this._createTableImpl(name, data, namespace, createOptions);
    }
    async _createTableImpl(name, data, namespace, options) {
        if (data === undefined) {
            throw new Error("data is required");
        }
        const { buf, mode } = await parseTableData(data, options);
        const storageOptions = this.getStorageOptions(options);
        const innerTable = await this.inner.createTable(name, buf, mode, namespace ?? [], storageOptions);
        return new table_1.LocalTable(innerTable);
    }
    async createEmptyTable(name, schema, namespaceOrOptions, options) {
        // Detect if third argument is namespace array or options object
        let namespace;
        let createOptions;
        if (Array.isArray(namespaceOrOptions)) {
            // Third argument is namespace array
            namespace = namespaceOrOptions;
            createOptions = options;
        }
        else {
            // Third argument is options object (backwards compatibility)
            namespace = undefined;
            createOptions = namespaceOrOptions;
        }
        let mode = createOptions?.mode ?? "create";
        const existOk = createOptions?.existOk ?? false;
        if (mode === "create" && existOk) {
            mode = "exist_ok";
        }
        let metadata = undefined;
        if (createOptions?.embeddingFunction !== undefined) {
            const embeddingFunction = createOptions.embeddingFunction;
            const registry = (0, registry_1.getRegistry)();
            metadata = registry.getTableMetadata([embeddingFunction]);
        }
        const storageOptions = this.getStorageOptions(createOptions);
        const table = (0, arrow_2.makeEmptyTable)(schema, metadata);
        const buf = await (0, arrow_2.fromTableToBuffer)(table);
        const innerTable = await this.inner.createEmptyTable(name, buf, mode, namespace ?? [], storageOptions);
        return new table_1.LocalTable(innerTable);
    }
    async dropTable(name, namespace) {
        return this.inner.dropTable(name, namespace ?? []);
    }
    async dropAllTables(namespace) {
        return this.inner.dropAllTables(namespace ?? []);
    }
}
exports.LocalConnection = LocalConnection;
/**
 * Takes storage options and makes all the keys snake case.
 */
function cleanseStorageOptions(options) {
    if (options === undefined) {
        return undefined;
    }
    const result = {};
    for (const [key, value] of Object.entries(options)) {
        if (value !== undefined) {
            const newKey = camelToSnakeCase(key);
            result[newKey] = value;
        }
    }
    return result;
}
/**
 * Convert a string to snake case. It might already be snake case, in which case it is
 * returned unchanged.
 */
function camelToSnakeCase(camel) {
    if (camel.includes("_")) {
        // Assume if there is at least one underscore, it is already snake case
        return camel;
    }
    if (camel.toLocaleUpperCase() === camel) {
        // Assume if the string is all uppercase, it is already snake case
        return camel;
    }
    let result = camel.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
    if (result.startsWith("_")) {
        result = result.slice(1);
    }
    return result;
}
async function parseTableData(data, options, streaming = false) {
    let mode = options?.mode ?? "create";
    const existOk = options?.existOk ?? false;
    if (mode === "create" && existOk) {
        mode = "exist_ok";
    }
    let table;
    if ((0, arrow_1.isArrowTable)(data)) {
        table = (0, sanitize_1.sanitizeTable)(data);
    }
    else {
        table = (0, arrow_1.makeArrowTable)(data, options);
    }
    if (streaming) {
        const buf = await (0, arrow_1.fromTableToStreamBuffer)(table, options?.embeddingFunction, options?.schema);
        return { buf, mode };
    }
    else {
        const buf = await (0, arrow_2.fromTableToBuffer)(table, options?.embeddingFunction, options?.schema);
        return { buf, mode };
    }
}


/***/ }),
/* 39 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// SPDX-License-Identifier: Apache-2.0
// SPDX-FileCopyrightText: Copyright The LanceDB Authors
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MakeArrowTableOptions = exports.VectorColumnOptions = void 0;
exports.isMultiVector = isMultiVector;
exports.isIntoVector = isIntoVector;
exports.isArrowTable = isArrowTable;
exports.isNull = isNull;
exports.isInt = isInt;
exports.isFloat = isFloat;
exports.isBinary = isBinary;
exports.isLargeBinary = isLargeBinary;
exports.isUtf8 = isUtf8;
exports.isLargeUtf8 = isLargeUtf8;
exports.isBool = isBool;
exports.isDecimal = isDecimal;
exports.isDate = isDate;
exports.isTime = isTime;
exports.isTimestamp = isTimestamp;
exports.isInterval = isInterval;
exports.isDuration = isDuration;
exports.isList = isList;
exports.isStruct = isStruct;
exports.isUnion = isUnion;
exports.isFixedSizeBinary = isFixedSizeBinary;
exports.isFixedSizeList = isFixedSizeList;
exports.makeArrowTable = makeArrowTable;
exports.makeEmptyTable = makeEmptyTable;
exports.convertToTable = convertToTable;
exports.newVectorType = newVectorType;
exports.fromRecordsToBuffer = fromRecordsToBuffer;
exports.fromRecordsToStreamBuffer = fromRecordsToStreamBuffer;
exports.fromTableToBuffer = fromTableToBuffer;
exports.fromDataToBuffer = fromDataToBuffer;
exports.fromBufferToRecordBatch = fromBufferToRecordBatch;
exports.fromRecordBatchToBuffer = fromRecordBatchToBuffer;
exports.fromTableToStreamBuffer = fromTableToStreamBuffer;
exports.createEmptyTable = createEmptyTable;
exports.ensureNestedFieldsExist = ensureNestedFieldsExist;
exports.dataTypeToJson = dataTypeToJson;
const apache_arrow_1 = __webpack_require__(40);
const registry_1 = __webpack_require__(182);
const sanitize_1 = __webpack_require__(184);
/**
 * Check if a field name indicates a vector column.
 */
function nameSuggestsVectorColumn(fieldName) {
    const nameLower = fieldName.toLowerCase();
    return nameLower.includes("vector") || nameLower.includes("embedding");
}
__exportStar(__webpack_require__(40), exports);
function isMultiVector(value) {
    return Array.isArray(value) && isIntoVector(value[0]);
}
function isIntoVector(value) {
    return (value instanceof Float32Array ||
        value instanceof Float64Array ||
        (Array.isArray(value) && !Array.isArray(value[0])));
}
function isArrowTable(value) {
    if (value instanceof apache_arrow_1.Table)
        return true;
    return "schema" in value && "batches" in value;
}
function isNull(value) {
    return value instanceof apache_arrow_1.Null || apache_arrow_1.DataType.isNull(value);
}
function isInt(value) {
    return value instanceof apache_arrow_1.Int || apache_arrow_1.DataType.isInt(value);
}
function isFloat(value) {
    return value instanceof apache_arrow_1.Float || apache_arrow_1.DataType.isFloat(value);
}
function isBinary(value) {
    return value instanceof apache_arrow_1.Binary || apache_arrow_1.DataType.isBinary(value);
}
function isLargeBinary(value) {
    return value instanceof apache_arrow_1.LargeBinary || apache_arrow_1.DataType.isLargeBinary(value);
}
function isUtf8(value) {
    return value instanceof apache_arrow_1.Utf8 || apache_arrow_1.DataType.isUtf8(value);
}
function isLargeUtf8(value) {
    return value instanceof apache_arrow_1.Utf8 || apache_arrow_1.DataType.isLargeUtf8(value);
}
function isBool(value) {
    return value instanceof apache_arrow_1.Utf8 || apache_arrow_1.DataType.isBool(value);
}
function isDecimal(value) {
    return value instanceof apache_arrow_1.Utf8 || apache_arrow_1.DataType.isDecimal(value);
}
function isDate(value) {
    return value instanceof apache_arrow_1.Utf8 || apache_arrow_1.DataType.isDate(value);
}
function isTime(value) {
    return value instanceof apache_arrow_1.Utf8 || apache_arrow_1.DataType.isTime(value);
}
function isTimestamp(value) {
    return value instanceof apache_arrow_1.Utf8 || apache_arrow_1.DataType.isTimestamp(value);
}
function isInterval(value) {
    return value instanceof apache_arrow_1.Utf8 || apache_arrow_1.DataType.isInterval(value);
}
function isDuration(value) {
    return value instanceof apache_arrow_1.Utf8 || apache_arrow_1.DataType.isDuration(value);
}
function isList(value) {
    return value instanceof apache_arrow_1.List || apache_arrow_1.DataType.isList(value);
}
function isStruct(value) {
    return value instanceof apache_arrow_1.Struct || apache_arrow_1.DataType.isStruct(value);
}
function isUnion(value) {
    return value instanceof apache_arrow_1.Struct || apache_arrow_1.DataType.isUnion(value);
}
function isFixedSizeBinary(value) {
    return value instanceof apache_arrow_1.FixedSizeBinary || apache_arrow_1.DataType.isFixedSizeBinary(value);
}
function isFixedSizeList(value) {
    return value instanceof apache_arrow_1.FixedSizeList || apache_arrow_1.DataType.isFixedSizeList(value);
}
/*
 * Options to control how a column should be converted to a vector array
 */
class VectorColumnOptions {
    /** Vector column type. */
    type = new apache_arrow_1.Float32();
    constructor(values) {
        Object.assign(this, values);
    }
}
exports.VectorColumnOptions = VectorColumnOptions;
// biome-ignore lint/suspicious/noExplicitAny: skip
function vectorFromArray(data, type) {
    // Workaround for: https://github.com/apache/arrow/issues/45862
    // If FSL type with float
    if (apache_arrow_1.DataType.isFixedSizeList(type) && apache_arrow_1.DataType.isFloat(type.valueType)) {
        const extendedData = [...data, new Array(type.listSize).fill(0.0)];
        const array = (0, apache_arrow_1.vectorFromArray)(extendedData, type);
        return array.slice(0, data.length);
    }
    else if (type === undefined) {
        return (0, apache_arrow_1.vectorFromArray)(data);
    }
    else {
        return (0, apache_arrow_1.vectorFromArray)(data, type);
    }
}
/** Options to control the makeArrowTable call. */
class MakeArrowTableOptions {
    /*
     * Schema of the data.
     *
     * If this is not provided then the data type will be inferred from the
     * JS type.  Integer numbers will become int64, floating point numbers
     * will become float64 and arrays will become variable sized lists with
     * the data type inferred from the first element in the array.
     *
     * The schema must be specified if there are no records (e.g. to make
     * an empty table)
     */
    schema;
    /*
     * Mapping from vector column name to expected type
     *
     * Lance expects vector columns to be fixed size list arrays (i.e. tensors)
     * However, `makeArrowTable` will not infer this by default (it creates
     * variable size list arrays).  This field can be used to indicate that a column
     * should be treated as a vector column and converted to a fixed size list.
     *
     * The keys should be the names of the vector columns.  The value specifies the
     * expected data type of the vector columns.
     *
     * If `schema` is provided then this field is ignored.
     *
     * By default, the column named "vector" will be assumed to be a float32
     * vector column.
     */
    vectorColumns = {
        vector: new VectorColumnOptions(),
    };
    embeddings;
    embeddingFunction;
    /**
     * If true then string columns will be encoded with dictionary encoding
     *
     * Set this to true if your string columns tend to repeat the same values
     * often.  For more precise control use the `schema` property to specify the
     * data type for individual columns.
     *
     * If `schema` is provided then this property is ignored.
     */
    dictionaryEncodeStrings = false;
    constructor(values) {
        Object.assign(this, values);
    }
}
exports.MakeArrowTableOptions = MakeArrowTableOptions;
/**
 * An enhanced version of the apache-arrow makeTable function from Apache Arrow
 * that supports nested fields and embeddings columns.
 *
 * (typically you do not need to call this function.  It will be called automatically
 * when creating a table or adding data to it)
 *
 * This function converts an array of Record<String, any> (row-major JS objects)
 * to an Arrow Table (a columnar structure)
 *
 * If a schema is provided then it will be used to determine the resulting array
 * types.  Fields will also be reordered to fit the order defined by the schema.
 *
 * If a schema is not provided then the types will be inferred and the field order
 * will be controlled by the order of properties in the first record.  If a type
 * is inferred it will always be nullable.
 *
 * If not all fields are found in the data, then a subset of the schema will be
 * returned.
 *
 * If the input is empty then a schema must be provided to create an empty table.
 *
 * When a schema is not specified then data types will be inferred.  The inference
 * rules are as follows:
 *
 *  - boolean => Bool
 *  - number => Float64
 *  - bigint => Int64
 *  - String => Utf8
 *  - Buffer => Binary
 *  - Record<String, any> => Struct
 *  - Array<any> => List
 * @example
 * ```ts
 * import { fromTableToBuffer, makeArrowTable } from "../arrow";
 * import { Field, FixedSizeList, Float16, Float32, Int32, Schema } from "apache-arrow";
 *
 * const schema = new Schema([
 *   new Field("a", new Int32()),
 *   new Field("b", new Float32()),
 *   new Field("c", new FixedSizeList(3, new Field("item", new Float16()))),
 *  ]);
 *  const table = makeArrowTable([
 *    { a: 1, b: 2, c: [1, 2, 3] },
 *    { a: 4, b: 5, c: [4, 5, 6] },
 *    { a: 7, b: 8, c: [7, 8, 9] },
 *  ], { schema });
 * ```
 *
 * By default it assumes that the column named `vector` is a vector column
 * and it will be converted into a fixed size list array of type float32.
 * The `vectorColumns` option can be used to support other vector column
 * names and data types.
 *
 * ```ts
 * const schema = new Schema([
 *   new Field("a", new Float64()),
 *   new Field("b", new Float64()),
 *   new Field(
 *     "vector",
 *     new FixedSizeList(3, new Field("item", new Float32()))
 *   ),
 * ]);
 * const table = makeArrowTable([
 *   { a: 1, b: 2, vector: [1, 2, 3] },
 *   { a: 4, b: 5, vector: [4, 5, 6] },
 *   { a: 7, b: 8, vector: [7, 8, 9] },
 * ]);
 * assert.deepEqual(table.schema, schema);
 * ```
 *
 * You can specify the vector column types and names using the options as well
 *
 * ```ts
 * const schema = new Schema([
 *   new Field('a', new Float64()),
 *   new Field('b', new Float64()),
 *   new Field('vec1', new FixedSizeList(3, new Field('item', new Float16()))),
 *   new Field('vec2', new FixedSizeList(3, new Field('item', new Float16())))
 * ]);
 * const table = makeArrowTable([
 *   { a: 1, b: 2, vec1: [1, 2, 3], vec2: [2, 4, 6] },
 *   { a: 4, b: 5, vec1: [4, 5, 6], vec2: [8, 10, 12] },
 *   { a: 7, b: 8, vec1: [7, 8, 9], vec2: [14, 16, 18] }
 * ], {
 *   vectorColumns: {
 *     vec1: { type: new Float16() },
 *     vec2: { type: new Float16() }
 *   }
 * }
 * assert.deepEqual(table.schema, schema)
 * ```
 */
function makeArrowTable(data, options, metadata) {
    const opt = new MakeArrowTableOptions(options !== undefined ? options : {});
    let schema = undefined;
    if (opt.schema !== undefined && opt.schema !== null) {
        schema = (0, sanitize_1.sanitizeSchema)(opt.schema);
        schema = validateSchemaEmbeddings(schema, data, options?.embeddingFunction);
    }
    let schemaMetadata = schema?.metadata || new Map();
    if (metadata !== undefined) {
        schemaMetadata = new Map([...schemaMetadata, ...metadata]);
    }
    if (data.length === 0 &&
        (options?.schema === undefined || options?.schema === null)) {
        throw new Error("At least one record or a schema needs to be provided");
    }
    else if (data.length === 0) {
        if (schema === undefined) {
            throw new Error("A schema must be provided if data is empty");
        }
        else {
            schema = new apache_arrow_1.Schema(schema.fields, schemaMetadata);
            return new apache_arrow_1.Table(schema);
        }
    }
    let inferredSchema = inferSchema(data, schema, opt);
    inferredSchema = new apache_arrow_1.Schema(inferredSchema.fields, schemaMetadata);
    const finalColumns = {};
    for (const field of inferredSchema.fields) {
        finalColumns[field.name] = transposeData(data, field);
    }
    return new apache_arrow_1.Table(inferredSchema, finalColumns);
}
function inferSchema(data, schema, opts) {
    // We will collect all fields we see in the data.
    const pathTree = new PathTree();
    for (const [rowI, row] of data.entries()) {
        for (const [path, value] of rowPathsAndValues(row)) {
            if (!pathTree.has(path)) {
                // First time seeing this field.
                if (schema !== undefined) {
                    const field = getFieldForPath(schema, path);
                    if (field === undefined) {
                        throw new Error(`Found field not in schema: ${path.join(".")} at row ${rowI}`);
                    }
                    else {
                        pathTree.set(path, field.type);
                    }
                }
                else {
                    const inferredType = inferType(value, path, opts);
                    if (inferredType === undefined) {
                        throw new Error(`Failed to infer data type for field ${path.join(".")} at row ${rowI}. \
                             Consider providing an explicit schema.`);
                    }
                    pathTree.set(path, inferredType);
                }
            }
            else if (schema === undefined) {
                const currentType = pathTree.get(path);
                const newType = inferType(value, path, opts);
                if (currentType !== newType) {
                    new Error(`Failed to infer schema for data. Previously inferred type \
                     ${currentType} but found ${newType} at row ${rowI}. Consider \
                     providing an explicit schema.`);
                }
            }
        }
    }
    if (schema === undefined) {
        function fieldsFromPathTree(pathTree) {
            const fields = [];
            for (const [name, value] of pathTree.map.entries()) {
                if (value instanceof PathTree) {
                    const children = fieldsFromPathTree(value);
                    fields.push(new apache_arrow_1.Field(name, new apache_arrow_1.Struct(children), true));
                }
                else {
                    fields.push(new apache_arrow_1.Field(name, value, true));
                }
            }
            return fields;
        }
        const fields = fieldsFromPathTree(pathTree);
        return new apache_arrow_1.Schema(fields);
    }
    else {
        function takeMatchingFields(fields, pathTree) {
            const outFields = [];
            for (const field of fields) {
                if (pathTree.map.has(field.name)) {
                    const value = pathTree.get([field.name]);
                    if (value instanceof PathTree) {
                        const struct = field.type;
                        const children = takeMatchingFields(struct.children, value);
                        outFields.push(new apache_arrow_1.Field(field.name, new apache_arrow_1.Struct(children), field.nullable));
                    }
                    else {
                        outFields.push(new apache_arrow_1.Field(field.name, value, field.nullable));
                    }
                }
            }
            return outFields;
        }
        const fields = takeMatchingFields(schema.fields, pathTree);
        return new apache_arrow_1.Schema(fields);
    }
}
function* rowPathsAndValues(row, basePath = []) {
    for (const [key, value] of Object.entries(row)) {
        if (isObject(value)) {
            yield* rowPathsAndValues(value, [...basePath, key]);
        }
        else {
            // Skip undefined values - they should be treated the same as missing fields
            // for embedding function purposes
            if (value !== undefined) {
                yield [[...basePath, key], value];
            }
        }
    }
}
function isObject(value) {
    return (typeof value === "object" &&
        value !== null &&
        !Array.isArray(value) &&
        !(value instanceof RegExp) &&
        !(value instanceof Date) &&
        !(value instanceof Set) &&
        !(value instanceof Map) &&
        !(value instanceof Buffer));
}
function getFieldForPath(schema, path) {
    let current = schema;
    for (const key of path) {
        if (current instanceof apache_arrow_1.Schema) {
            const field = current.fields.find((f) => f.name === key);
            if (field === undefined) {
                return undefined;
            }
            current = field;
        }
        else if (current instanceof apache_arrow_1.Field && apache_arrow_1.DataType.isStruct(current.type)) {
            const struct = current.type;
            const field = struct.children.find((f) => f.name === key);
            if (field === undefined) {
                return undefined;
            }
            current = field;
        }
        else {
            return undefined;
        }
    }
    if (current instanceof apache_arrow_1.Field) {
        return current;
    }
    else {
        return undefined;
    }
}
/**
 * Try to infer which Arrow type to use for a given value.
 *
 * May return undefined if the type cannot be inferred.
 */
function inferType(value, path, opts) {
    if (typeof value === "bigint") {
        return new apache_arrow_1.Int64();
    }
    else if (typeof value === "number") {
        // Even if it's an integer, it's safer to assume Float64. Users can
        // always provide an explicit schema or use BigInt if they mean integer.
        return new apache_arrow_1.Float64();
    }
    else if (typeof value === "string") {
        if (opts.dictionaryEncodeStrings) {
            return new apache_arrow_1.Dictionary(new apache_arrow_1.Utf8(), new apache_arrow_1.Int32());
        }
        else {
            return new apache_arrow_1.Utf8();
        }
    }
    else if (typeof value === "boolean") {
        return new apache_arrow_1.Bool();
    }
    else if (value instanceof Buffer) {
        return new apache_arrow_1.Binary();
    }
    else if (Array.isArray(value)) {
        if (value.length === 0) {
            return undefined; // Without any values we can't infer the type
        }
        if (path.length === 1 && Object.hasOwn(opts.vectorColumns, path[0])) {
            const floatType = (0, sanitize_1.sanitizeType)(opts.vectorColumns[path[0]].type);
            return new apache_arrow_1.FixedSizeList(value.length, new apache_arrow_1.Field("item", floatType, true));
        }
        const valueType = inferType(value[0], path, opts);
        if (valueType === undefined) {
            return undefined;
        }
        // Try to automatically detect embedding columns.
        if (nameSuggestsVectorColumn(path[path.length - 1])) {
            // Check if value is a Uint8Array for integer vector type determination
            if (value instanceof Uint8Array) {
                // For integer vectors, we default to Uint8 (matching Python implementation)
                const child = new apache_arrow_1.Field("item", new apache_arrow_1.Uint8(), true);
                return new apache_arrow_1.FixedSizeList(value.length, child);
            }
            else {
                // For float vectors, we default to Float32
                const child = new apache_arrow_1.Field("item", new apache_arrow_1.Float32(), true);
                return new apache_arrow_1.FixedSizeList(value.length, child);
            }
        }
        else {
            const child = new apache_arrow_1.Field("item", valueType, true);
            return new apache_arrow_1.List(child);
        }
    }
    else {
        // TODO: timestamp
        return undefined;
    }
}
class PathTree {
    map;
    constructor(entries) {
        this.map = new Map();
        if (entries !== undefined) {
            for (const [path, value] of entries) {
                this.set(path, value);
            }
        }
    }
    has(path) {
        let ref = this;
        for (const part of path) {
            if (!(ref instanceof PathTree) || !ref.map.has(part)) {
                return false;
            }
            ref = ref.map.get(part);
        }
        return true;
    }
    get(path) {
        let ref = this;
        for (const part of path) {
            if (!(ref instanceof PathTree) || !ref.map.has(part)) {
                return undefined;
            }
            ref = ref.map.get(part);
        }
        return ref;
    }
    set(path, value) {
        let ref = this;
        for (const part of path.slice(0, path.length - 1)) {
            if (!ref.map.has(part)) {
                ref.map.set(part, new PathTree());
            }
            ref = ref.map.get(part);
        }
        ref.map.set(path[path.length - 1], value);
    }
}
function transposeData(data, field, path = []) {
    if (field.type instanceof apache_arrow_1.Struct) {
        const childFields = field.type.children;
        const fullPath = [...path, field.name];
        const childVectors = childFields.map((child) => {
            return transposeData(data, child, fullPath);
        });
        const structData = (0, apache_arrow_1.makeData)({
            type: field.type,
            children: childVectors,
        });
        return (0, apache_arrow_1.makeVector)(structData);
    }
    else {
        const valuesPath = [...path, field.name];
        const values = data.map((datum) => {
            let current = datum;
            for (const key of valuesPath) {
                if (current == null) {
                    return null;
                }
                if (isObject(current) &&
                    (Object.hasOwn(current, key) || key in current)) {
                    current = current[key];
                }
                else {
                    return null;
                }
            }
            return current;
        });
        return makeVector(values, field.type, undefined, field.nullable);
    }
}
/**
 * Create an empty Arrow table with the provided schema
 */
function makeEmptyTable(schema, metadata) {
    return makeArrowTable([], { schema }, metadata);
}
/**
 * Helper function to convert Array<Array<any>> to a variable sized list array
 */
// @ts-expect-error (Vector<unknown> is not assignable to Vector<any>)
function makeListVector(lists) {
    if (lists.length === 0 || lists[0].length === 0) {
        throw Error("Cannot infer list vector from empty array or empty list");
    }
    const sampleList = lists[0];
    // biome-ignore lint/suspicious/noExplicitAny: skip
    let inferredType;
    try {
        const sampleVector = makeVector(sampleList);
        inferredType = sampleVector.type;
    }
    catch (error) {
        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
        throw Error(`Cannot infer list vector.  Cannot infer inner type: ${error}`);
    }
    const listBuilder = (0, apache_arrow_1.makeBuilder)({
        type: new apache_arrow_1.List(new apache_arrow_1.Field("item", inferredType, true)),
    });
    for (const list of lists) {
        listBuilder.append(list);
    }
    return listBuilder.finish().toVector();
}
/** Helper function to convert an Array of JS values to an Arrow Vector */
function makeVector(values, type, stringAsDictionary, nullable) {
    if (type !== undefined) {
        // Convert undefined values to null for nullable fields
        if (nullable) {
            values = values.map((v) => (v === undefined ? null : v));
        }
        // workaround for: https://github.com/apache/arrow-js/issues/68
        if (apache_arrow_1.DataType.isBool(type)) {
            const hasNonNullValue = values.some((v) => v !== null && v !== undefined);
            if (!hasNonNullValue) {
                const nullBitmap = new Uint8Array(Math.ceil(values.length / 8));
                const data = (0, apache_arrow_1.makeData)({
                    type: type,
                    length: values.length,
                    nullCount: values.length,
                    nullBitmap,
                });
                return (0, apache_arrow_1.makeVector)(data);
            }
        }
        // No need for inference, let Arrow create it
        if (type instanceof apache_arrow_1.Int) {
            if (apache_arrow_1.DataType.isInt(type) && type.bitWidth === 64) {
                // wrap in BigInt to avoid bug: https://github.com/apache/arrow/issues/40051
                values = values.map((v) => {
                    if (v === null) {
                        return v;
                    }
                    else if (typeof v === "bigint") {
                        return v;
                    }
                    else if (typeof v === "number") {
                        return BigInt(v);
                    }
                    else {
                        return v;
                    }
                });
            }
            else {
                // Similarly, bigint isn't supported for 16 or 32-bit ints.
                values = values.map((v) => {
                    if (typeof v == "bigint") {
                        return Number(v);
                    }
                    else {
                        return v;
                    }
                });
            }
        }
        return vectorFromArray(values, type);
    }
    if (values.length === 0) {
        throw Error("makeVector requires at least one value or the type must be specfied");
    }
    const sampleValue = values.find((val) => val !== null && val !== undefined);
    if (sampleValue === undefined) {
        throw Error("makeVector cannot infer the type if all values are null or undefined");
    }
    if (Array.isArray(sampleValue)) {
        // Default Arrow inference doesn't handle list types
        return makeListVector(values);
    }
    else if (Buffer.isBuffer(sampleValue)) {
        // Default Arrow inference doesn't handle Buffer
        return vectorFromArray(values, new apache_arrow_1.Binary());
    }
    else if (!(stringAsDictionary ?? false) &&
        (typeof sampleValue === "string" || sampleValue instanceof String)) {
        // If the type is string then don't use Arrow's default inference unless dictionaries are requested
        // because it will always use dictionary encoding for strings
        return vectorFromArray(values, new apache_arrow_1.Utf8());
    }
    else {
        // Convert a JS array of values to an arrow vector
        return vectorFromArray(values);
    }
}
/** Helper function to apply embeddings from metadata to an input table */
async function applyEmbeddingsFromMetadata(table, schema) {
    const registry = (0, registry_1.getRegistry)();
    const functions = await registry.parseFunctions(schema.metadata);
    const columns = Object.fromEntries(table.schema.fields.map((field) => [
        field.name,
        table.getChild(field.name),
    ]));
    for (const functionEntry of functions.values()) {
        const sourceColumn = columns[functionEntry.sourceColumn];
        const destColumn = functionEntry.vectorColumn ?? "vector";
        if (sourceColumn === undefined) {
            throw new Error(`Cannot apply embedding function because the source column '${functionEntry.sourceColumn}' was not present in the data`);
        }
        // Check if destination column exists and handle accordingly
        if (columns[destColumn] !== undefined) {
            const existingColumn = columns[destColumn];
            // If the column exists but is all null, we can fill it with embeddings
            if (existingColumn.nullCount !== existingColumn.length) {
                // Column has non-null values, skip embedding application
                continue;
            }
        }
        if (table.batches.length > 1) {
            throw new Error("Internal error: `makeArrowTable` unexpectedly created a table with more than one batch");
        }
        const values = sourceColumn.toArray();
        const vectors = await functionEntry.function.computeSourceEmbeddings(values);
        if (vectors.length !== values.length) {
            throw new Error("Embedding function did not return an embedding for each input element");
        }
        let destType;
        const dtype = schema.fields.find((f) => f.name === destColumn).type;
        if (isFixedSizeList(dtype)) {
            destType = (0, sanitize_1.sanitizeType)(dtype);
        }
        else {
            throw new Error("Expected FixedSizeList as datatype for vector field, instead got: " +
                dtype);
        }
        const vector = makeVector(vectors, destType);
        columns[destColumn] = vector;
    }
    // Add any missing columns from the schema as null vectors
    for (const field of schema.fields) {
        if (!(field.name in columns)) {
            const nullValues = new Array(table.numRows).fill(null);
            columns[field.name] = makeVector(nullValues, field.type, undefined, field.nullable);
        }
    }
    const newTable = new apache_arrow_1.Table(columns);
    return alignTable(newTable, schema);
}
/** Helper function to apply embeddings to an input table */
async function applyEmbeddings(table, embeddings, schema) {
    if (schema !== undefined && schema !== null) {
        schema = (0, sanitize_1.sanitizeSchema)(schema);
    }
    if (schema?.metadata.has("embedding_functions")) {
        return applyEmbeddingsFromMetadata(table, schema);
    }
    else if (embeddings == null || embeddings === undefined) {
        return table;
    }
    let schemaMetadata = schema?.metadata || new Map();
    if (!(embeddings == null || embeddings === undefined)) {
        const registry = (0, registry_1.getRegistry)();
        const embeddingMetadata = registry.getTableMetadata([embeddings]);
        schemaMetadata = new Map([...schemaMetadata, ...embeddingMetadata]);
    }
    // Convert from ArrowTable to Record<String, Vector>
    const colEntries = [...Array(table.numCols).keys()].map((_, idx) => {
        const name = table.schema.fields[idx].name;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vec = table.getChildAt(idx);
        return [name, vec];
    });
    const newColumns = Object.fromEntries(colEntries);
    const sourceColumn = newColumns[embeddings.sourceColumn];
    const destColumn = embeddings.vectorColumn ?? "vector";
    const innerDestType = embeddings.function.embeddingDataType() ?? new apache_arrow_1.Float32();
    if (sourceColumn === undefined) {
        throw new Error(`Cannot apply embedding function because the source column '${embeddings.sourceColumn}' was not present in the data`);
    }
    if (table.numRows === 0) {
        if (Object.prototype.hasOwnProperty.call(newColumns, destColumn)) {
            // We have an empty table and it already has the embedding column so no work needs to be done
            // Note: we don't return an error like we did below because this is a common occurrence.  For example,
            // if we call convertToTable with 0 records and a schema that includes the embedding
            return table;
        }
        const dimensions = embeddings.function.ndims();
        if (dimensions !== undefined) {
            const destType = newVectorType(dimensions, innerDestType);
            newColumns[destColumn] = makeVector([], destType);
        }
        else if (schema != null) {
            const destField = schema.fields.find((f) => f.name === destColumn);
            if (destField != null) {
                newColumns[destColumn] = makeVector([], destField.type, undefined, destField.nullable);
            }
            else {
                throw new Error(`Attempt to apply embeddings to an empty table failed because schema was missing embedding column '${destColumn}'`);
            }
        }
        else {
            throw new Error("Attempt to apply embeddings to an empty table when the embeddings function does not specify `embeddingDimension`");
        }
    }
    else {
        // Check if destination column exists and handle accordingly
        if (Object.prototype.hasOwnProperty.call(newColumns, destColumn)) {
            const existingColumn = newColumns[destColumn];
            // If the column exists but is all null, we can fill it with embeddings
            if (existingColumn.nullCount !== existingColumn.length) {
                // Column has non-null values, skip embedding application and return table as-is
                let newTable = new apache_arrow_1.Table(newColumns);
                if (schema != null) {
                    newTable = alignTable(newTable, schema);
                }
                return new apache_arrow_1.Table(new apache_arrow_1.Schema(newTable.schema.fields, schemaMetadata), newTable.batches);
            }
        }
        if (table.batches.length > 1) {
            throw new Error("Internal error: `makeArrowTable` unexpectedly created a table with more than one batch");
        }
        const values = sourceColumn.toArray();
        const vectors = await embeddings.function.computeSourceEmbeddings(values);
        if (vectors.length !== values.length) {
            throw new Error("Embedding function did not return an embedding for each input element");
        }
        const destType = newVectorType(vectors[0].length, innerDestType);
        newColumns[destColumn] = makeVector(vectors, destType);
    }
    let newTable = new apache_arrow_1.Table(newColumns);
    if (schema != null) {
        if (schema.fields.find((f) => f.name === destColumn) === undefined) {
            throw new Error(`When using embedding functions and specifying a schema the schema should include the embedding column but the column ${destColumn} was missing`);
        }
        newTable = alignTable(newTable, schema);
    }
    newTable = new apache_arrow_1.Table(new apache_arrow_1.Schema(newTable.schema.fields, schemaMetadata), newTable.batches);
    return newTable;
}
/**
 * Convert an Array of records into an Arrow Table, optionally applying an
 * embeddings function to it.
 *
 * This function calls `makeArrowTable` first to create the Arrow Table.
 * Any provided `makeTableOptions` (e.g. a schema) will be passed on to
 * that call.
 *
 * The embedding function will be passed a column of values (based on the
 * `sourceColumn` of the embedding function) and expects to receive back
 * number[][] which will be converted into a fixed size list column.  By
 * default this will be a fixed size list of Float32 but that can be
 * customized by the `embeddingDataType` property of the embedding function.
 *
 * If a schema is provided in `makeTableOptions` then it should include the
 * embedding columns.  If no schema is provded then embedding columns will
 * be placed at the end of the table, after all of the input columns.
 */
async function convertToTable(data, embeddings, makeTableOptions) {
    let processedData = data;
    // If we have a schema with embedding metadata, we need to preprocess the data
    // to ensure all nested fields are present
    if (makeTableOptions?.schema &&
        makeTableOptions.schema.metadata?.has("embedding_functions")) {
        processedData = ensureNestedFieldsExist(data, makeTableOptions.schema);
    }
    const table = makeArrowTable(processedData, makeTableOptions);
    return await applyEmbeddings(table, embeddings, makeTableOptions?.schema);
}
/** Creates the Arrow Type for a Vector column with dimension `dim` */
function newVectorType(dim, innerType) {
    // in Lance we always default to have the elements nullable, so we need to set it to true
    // otherwise we often get schema mismatches because the stored data always has schema with nullable elements
    const children = new apache_arrow_1.Field("item", (0, sanitize_1.sanitizeType)(innerType), true);
    return new apache_arrow_1.FixedSizeList(dim, children);
}
/**
 * Serialize an Array of records into a buffer using the Arrow IPC File serialization
 *
 * This function will call `convertToTable` and pass on `embeddings` and `schema`
 *
 * `schema` is required if data is empty
 */
async function fromRecordsToBuffer(data, embeddings, schema) {
    if (schema !== undefined && schema !== null) {
        schema = (0, sanitize_1.sanitizeSchema)(schema);
    }
    const table = await convertToTable(data, embeddings, { schema });
    const writer = apache_arrow_1.RecordBatchFileWriter.writeAll(table);
    return Buffer.from(await writer.toUint8Array());
}
/**
 * Serialize an Array of records into a buffer using the Arrow IPC Stream serialization
 *
 * This function will call `convertToTable` and pass on `embeddings` and `schema`
 *
 * `schema` is required if data is empty
 */
async function fromRecordsToStreamBuffer(data, embeddings, schema) {
    if (schema !== undefined && schema !== null) {
        schema = (0, sanitize_1.sanitizeSchema)(schema);
    }
    const table = await convertToTable(data, embeddings, { schema });
    const writer = apache_arrow_1.RecordBatchStreamWriter.writeAll(table);
    return Buffer.from(await writer.toUint8Array());
}
/**
 * Serialize an Arrow Table into a buffer using the Arrow IPC File serialization
 *
 * This function will apply `embeddings` to the table in a manner similar to
 * `convertToTable`.
 *
 * `schema` is required if the table is empty
 */
async function fromTableToBuffer(table, embeddings, schema) {
    if (schema !== undefined && schema !== null) {
        schema = (0, sanitize_1.sanitizeSchema)(schema);
    }
    const tableWithEmbeddings = await applyEmbeddings(table, embeddings, schema);
    const writer = apache_arrow_1.RecordBatchFileWriter.writeAll(tableWithEmbeddings);
    return Buffer.from(await writer.toUint8Array());
}
/**
 * Serialize an Arrow Table into a buffer using the Arrow IPC File serialization
 *
 * This function will apply `embeddings` to the table in a manner similar to
 * `convertToTable`.
 *
 * `schema` is required if the table is empty
 */
async function fromDataToBuffer(data, embeddings, schema) {
    if (schema !== undefined && schema !== null) {
        schema = (0, sanitize_1.sanitizeSchema)(schema);
    }
    if (isArrowTable(data)) {
        const table = (0, sanitize_1.sanitizeTable)(data);
        // If we have a schema with embedding functions, we need to ensure all columns exist
        // before applying embeddings, since applyEmbeddingsFromMetadata expects all columns
        // to be present in the table
        if (schema && schema.metadata?.has("embedding_functions")) {
            const alignedTable = alignTableToSchema(table, schema);
            return fromTableToBuffer(alignedTable, embeddings, schema);
        }
        else {
            return fromTableToBuffer(table, embeddings, schema);
        }
    }
    else {
        const table = await convertToTable(data, embeddings, { schema });
        return fromTableToBuffer(table);
    }
}
/**
 * Read a single record batch from a buffer.
 *
 * Returns null if the buffer does not contain a record batch
 */
async function fromBufferToRecordBatch(data) {
    const iter = await apache_arrow_1.RecordBatchFileReader.readAll(Buffer.from(data)).next()
        .value;
    const recordBatch = iter?.next().value;
    return recordBatch || null;
}
/**
 * Create a buffer containing a single record batch
 */
async function fromRecordBatchToBuffer(batch) {
    const writer = new apache_arrow_1.RecordBatchFileWriter().writeAll([batch]);
    return Buffer.from(await writer.toUint8Array());
}
/**
 * Serialize an Arrow Table into a buffer using the Arrow IPC Stream serialization
 *
 * This function will apply `embeddings` to the table in a manner similar to
 * `convertToTable`.
 *
 * `schema` is required if the table is empty
 */
async function fromTableToStreamBuffer(table, embeddings, schema) {
    const tableWithEmbeddings = await applyEmbeddings(table, embeddings, schema);
    const writer = apache_arrow_1.RecordBatchStreamWriter.writeAll(tableWithEmbeddings);
    return Buffer.from(await writer.toUint8Array());
}
/**
 * Reorder the columns in `batch` so that they agree with the field order in `schema`
 */
function alignBatch(batch, schema) {
    const alignedChildren = [];
    for (const field of schema.fields) {
        const indexInBatch = batch.schema.fields?.findIndex((f) => f.name === field.name);
        if (indexInBatch < 0) {
            throw new Error(`The column ${field.name} was not found in the Arrow Table`);
        }
        alignedChildren.push(batch.data.children[indexInBatch]);
    }
    const newData = (0, apache_arrow_1.makeData)({
        type: new apache_arrow_1.Struct(schema.fields),
        length: batch.numRows,
        nullCount: batch.nullCount,
        children: alignedChildren,
    });
    return new apache_arrow_1.RecordBatch(schema, newData);
}
/**
 * Reorder the columns in `table` so that they agree with the field order in `schema`
 */
function alignTable(table, schema) {
    const alignedBatches = table.batches.map((batch) => alignBatch(batch, schema));
    return new apache_arrow_1.Table(schema, alignedBatches);
}
/**
 * Create an empty table with the given schema
 */
function createEmptyTable(schema) {
    return new apache_arrow_1.Table((0, sanitize_1.sanitizeSchema)(schema));
}
function validateSchemaEmbeddings(schema, data, embeddings) {
    const fields = [];
    const missingEmbeddingFields = [];
    // First we check if the field is a `FixedSizeList`
    // Then we check if the data contains the field
    // if it does not, we add it to the list of missing embedding fields
    // Finally, we check if those missing embedding fields are `this._embeddings`
    // if they are not, we throw an error
    for (let field of schema.fields) {
        if (isFixedSizeList(field.type)) {
            field = (0, sanitize_1.sanitizeField)(field);
            if (data.length !== 0 && data?.[0]?.[field.name] === undefined) {
                // Check if there's an embedding function registered for this field
                let hasEmbeddingFunction = false;
                // Check schema metadata for embedding functions
                if (schema.metadata.has("embedding_functions")) {
                    const embeddings = JSON.parse(schema.metadata.get("embedding_functions"));
                    // biome-ignore lint/suspicious/noExplicitAny: we don't know the type of `f`
                    if (embeddings.find((f) => f["vectorColumn"] === field.name)) {
                        hasEmbeddingFunction = true;
                    }
                }
                // Check passed embedding function parameter
                if (embeddings && embeddings.vectorColumn === field.name) {
                    hasEmbeddingFunction = true;
                }
                // If the field is nullable AND there's no embedding function, allow undefined/omitted values
                if (field.nullable && !hasEmbeddingFunction) {
                    fields.push(field);
                }
                else {
                    // Either not nullable OR has embedding function - require explicit values
                    if (hasEmbeddingFunction) {
                        // Don't add to missingEmbeddingFields since this is expected to be filled by embedding function
                        fields.push(field);
                    }
                    else {
                        missingEmbeddingFields.push(field);
                    }
                }
            }
            else {
                fields.push(field);
            }
        }
        else {
            fields.push(field);
        }
    }
    if (missingEmbeddingFields.length > 0 && embeddings === undefined) {
        throw new Error(`Table has embeddings: "${missingEmbeddingFields
            .map((f) => f.name)
            .join(",")}", but no embedding function was provided`);
    }
    return new apache_arrow_1.Schema(fields, schema.metadata);
}
/**
 * Ensures that all nested fields defined in the schema exist in the data,
 * filling missing fields with null values.
 */
function ensureNestedFieldsExist(data, schema) {
    return data.map((row) => {
        const completeRow = {};
        for (const field of schema.fields) {
            if (field.name in row) {
                if (field.type.constructor.name === "Struct" &&
                    row[field.name] !== null &&
                    row[field.name] !== undefined) {
                    // Handle nested struct
                    const nestedValue = row[field.name];
                    completeRow[field.name] = ensureStructFieldsExist(nestedValue, field.type);
                }
                else {
                    // Non-struct field or null struct value
                    completeRow[field.name] = row[field.name];
                }
            }
            else {
                // Field is missing from the data - set to null
                completeRow[field.name] = null;
            }
        }
        return completeRow;
    });
}
/**
 * Recursively ensures that all fields in a struct type exist in the data,
 * filling missing fields with null values.
 */
function ensureStructFieldsExist(data, structType) {
    const completeStruct = {};
    for (const childField of structType.children) {
        if (childField.name in data) {
            if (childField.type.constructor.name === "Struct" &&
                data[childField.name] !== null &&
                data[childField.name] !== undefined) {
                // Recursively handle nested struct
                completeStruct[childField.name] = ensureStructFieldsExist(data[childField.name], childField.type);
            }
            else {
                // Non-struct field or null struct value
                completeStruct[childField.name] = data[childField.name];
            }
        }
        else {
            // Field is missing - set to null
            completeStruct[childField.name] = null;
        }
    }
    return completeStruct;
}
// Matches format of https://github.com/lancedb/lance/blob/main/rust/lance/src/arrow/json.rs
function dataTypeToJson(dataType) {
    switch (dataType.typeId) {
        // For primitives, matches https://github.com/lancedb/lance/blob/e12bb9eff2a52f753668d4b62c52e4d72b10d294/rust/lance-core/src/datatypes.rs#L185
        case apache_arrow_1.Type.Null:
            return { type: "null" };
        case apache_arrow_1.Type.Bool:
            return { type: "bool" };
        case apache_arrow_1.Type.Int8:
            return { type: "int8" };
        case apache_arrow_1.Type.Int16:
            return { type: "int16" };
        case apache_arrow_1.Type.Int32:
            return { type: "int32" };
        case apache_arrow_1.Type.Int64:
            return { type: "int64" };
        case apache_arrow_1.Type.Uint8:
            return { type: "uint8" };
        case apache_arrow_1.Type.Uint16:
            return { type: "uint16" };
        case apache_arrow_1.Type.Uint32:
            return { type: "uint32" };
        case apache_arrow_1.Type.Uint64:
            return { type: "uint64" };
        case apache_arrow_1.Type.Int: {
            const bitWidth = dataType.bitWidth;
            const signed = dataType.isSigned;
            const prefix = signed ? "" : "u";
            return { type: `${prefix}int${bitWidth}` };
        }
        case apache_arrow_1.Type.Float: {
            switch (dataType.precision) {
                case apache_arrow_1.Precision.HALF:
                    return { type: "halffloat" };
                case apache_arrow_1.Precision.SINGLE:
                    return { type: "float" };
                case apache_arrow_1.Precision.DOUBLE:
                    return { type: "double" };
            }
            throw Error("Unsupported float precision");
        }
        case apache_arrow_1.Type.Float16:
            return { type: "halffloat" };
        case apache_arrow_1.Type.Float32:
            return { type: "float" };
        case apache_arrow_1.Type.Float64:
            return { type: "double" };
        case apache_arrow_1.Type.Utf8:
            return { type: "string" };
        case apache_arrow_1.Type.Binary:
            return { type: "binary" };
        case apache_arrow_1.Type.LargeUtf8:
            return { type: "large_string" };
        case apache_arrow_1.Type.LargeBinary:
            return { type: "large_binary" };
        case apache_arrow_1.Type.List:
            return {
                type: "list",
                fields: [fieldToJson(dataType.children[0])],
            };
        case apache_arrow_1.Type.FixedSizeList: {
            const fixedSizeList = dataType;
            return {
                type: "fixed_size_list",
                fields: [fieldToJson(fixedSizeList.children[0])],
                length: fixedSizeList.listSize,
            };
        }
        case apache_arrow_1.Type.Struct:
            return {
                type: "struct",
                fields: dataType.children.map(fieldToJson),
            };
        case apache_arrow_1.Type.Date: {
            const unit = dataType.unit;
            return {
                type: unit === apache_arrow_1.DateUnit.DAY ? "date32:day" : "date64:ms",
            };
        }
        case apache_arrow_1.Type.Timestamp: {
            const timestamp = dataType;
            const timezone = timestamp.timezone || "-";
            return {
                type: `timestamp:${timestamp.unit}:${timezone}`,
            };
        }
        case apache_arrow_1.Type.Decimal: {
            const decimal = dataType;
            return {
                type: `decimal:${decimal.bitWidth}:${decimal.precision}:${decimal.scale}`,
            };
        }
        case apache_arrow_1.Type.Duration: {
            const duration = dataType;
            return { type: `duration:${duration.unit}` };
        }
        case apache_arrow_1.Type.FixedSizeBinary: {
            const byteWidth = dataType.byteWidth;
            return { type: `fixed_size_binary:${byteWidth}` };
        }
        case apache_arrow_1.Type.Dictionary: {
            const dict = dataType;
            const indexType = dataTypeToJson(dict.indices);
            const valueType = dataTypeToJson(dict.valueType);
            return {
                type: `dict:${valueType.type}:${indexType.type}:false`,
            };
        }
    }
    throw new Error("Unsupported data type");
}
function fieldToJson(field) {
    return {
        name: field.name,
        type: dataTypeToJson(field.type),
        nullable: field.nullable,
        metadata: field.metadata,
    };
}
function alignTableToSchema(table, targetSchema) {
    const existingColumns = new Map();
    // Map existing columns
    for (const field of table.schema.fields) {
        existingColumns.set(field.name, table.getChild(field.name));
    }
    // Create vectors for all fields in target schema
    const alignedColumns = {};
    for (const field of targetSchema.fields) {
        if (existingColumns.has(field.name)) {
            // Column exists, use it
            alignedColumns[field.name] = existingColumns.get(field.name);
        }
        else {
            // Column missing, create null vector
            alignedColumns[field.name] = createNullVector(field, table.numRows);
        }
    }
    // Create new table with aligned schema and columns
    return new apache_arrow_1.Table(targetSchema, alignedColumns);
}
function createNullVector(field, numRows) {
    if (field.type.constructor.name === "Struct") {
        // For struct types, create a struct with null fields
        const structType = field.type;
        const childVectors = structType.children.map((childField) => createNullVector(childField, numRows));
        // Create struct data
        const structData = (0, apache_arrow_1.makeData)({
            type: structType,
            length: numRows,
            nullCount: 0,
            children: childVectors.map((v) => v.data[0]),
        });
        return (0, apache_arrow_1.makeVector)(structData);
    }
    else {
        // For other types, create a vector of nulls
        const nullBitmap = new Uint8Array(Math.ceil(numRows / 8));
        // All bits are 0, meaning all values are null
        const data = (0, apache_arrow_1.makeData)({
            type: field.type,
            length: numRows,
            nullCount: numRows,
            nullBitmap,
        });
        return (0, apache_arrow_1.makeVector)(data);
    }
}


/***/ }),
/* 40 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(41);
const adapters_js_1 = __webpack_require__(42);
const builder_js_1 = __webpack_require__(46);
const reader_js_1 = __webpack_require__(124);
const writer_js_1 = __webpack_require__(166);
const iterable_js_1 = __webpack_require__(170);
const builder_js_2 = __webpack_require__(172);
const reader_js_2 = __webpack_require__(173);
const writer_js_2 = __webpack_require__(174);
adapters_js_1.default.toNodeStream = iterable_js_1.toNodeStream;
builder_js_1.Builder['throughNode'] = builder_js_2.builderThroughNodeStream;
reader_js_1.RecordBatchReader['throughNode'] = reader_js_2.recordBatchReaderThroughNodeStream;
writer_js_1.RecordBatchWriter['throughNode'] = writer_js_2.recordBatchWriterThroughNodeStream;
tslib_1.__exportStar(__webpack_require__(175), exports);

//# sourceMappingURL=Arrow.node.js.map


/***/ }),
/* 41 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   __addDisposableResource: () => (/* binding */ __addDisposableResource),
/* harmony export */   __assign: () => (/* binding */ __assign),
/* harmony export */   __asyncDelegator: () => (/* binding */ __asyncDelegator),
/* harmony export */   __asyncGenerator: () => (/* binding */ __asyncGenerator),
/* harmony export */   __asyncValues: () => (/* binding */ __asyncValues),
/* harmony export */   __await: () => (/* binding */ __await),
/* harmony export */   __awaiter: () => (/* binding */ __awaiter),
/* harmony export */   __classPrivateFieldGet: () => (/* binding */ __classPrivateFieldGet),
/* harmony export */   __classPrivateFieldIn: () => (/* binding */ __classPrivateFieldIn),
/* harmony export */   __classPrivateFieldSet: () => (/* binding */ __classPrivateFieldSet),
/* harmony export */   __createBinding: () => (/* binding */ __createBinding),
/* harmony export */   __decorate: () => (/* binding */ __decorate),
/* harmony export */   __disposeResources: () => (/* binding */ __disposeResources),
/* harmony export */   __esDecorate: () => (/* binding */ __esDecorate),
/* harmony export */   __exportStar: () => (/* binding */ __exportStar),
/* harmony export */   __extends: () => (/* binding */ __extends),
/* harmony export */   __generator: () => (/* binding */ __generator),
/* harmony export */   __importDefault: () => (/* binding */ __importDefault),
/* harmony export */   __importStar: () => (/* binding */ __importStar),
/* harmony export */   __makeTemplateObject: () => (/* binding */ __makeTemplateObject),
/* harmony export */   __metadata: () => (/* binding */ __metadata),
/* harmony export */   __param: () => (/* binding */ __param),
/* harmony export */   __propKey: () => (/* binding */ __propKey),
/* harmony export */   __read: () => (/* binding */ __read),
/* harmony export */   __rest: () => (/* binding */ __rest),
/* harmony export */   __rewriteRelativeImportExtension: () => (/* binding */ __rewriteRelativeImportExtension),
/* harmony export */   __runInitializers: () => (/* binding */ __runInitializers),
/* harmony export */   __setFunctionName: () => (/* binding */ __setFunctionName),
/* harmony export */   __spread: () => (/* binding */ __spread),
/* harmony export */   __spreadArray: () => (/* binding */ __spreadArray),
/* harmony export */   __spreadArrays: () => (/* binding */ __spreadArrays),
/* harmony export */   __values: () => (/* binding */ __values),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */

var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
  return extendStatics(d, b);
};

function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() { this.constructor = d; }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
  __assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
      return t;
  }
  return __assign.apply(this, arguments);
}

function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
      }
  return t;
}

function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
  return function (target, key) { decorator(target, key, paramIndex); }
}

function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
      var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind === "accessor") {
          if (result === void 0) continue;
          if (result === null || typeof result !== "object") throw new TypeError("Object expected");
          if (_ = accept(result.get)) descriptor.get = _;
          if (_ = accept(result.set)) descriptor.set = _;
          if (_ = accept(result.init)) initializers.unshift(_);
      }
      else if (_ = accept(result)) {
          if (kind === "field") initializers.unshift(_);
          else descriptor[key] = _;
      }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};

function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};

function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
};

function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};

function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
  return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
      function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
  function verb(n) { return function (v) { return step([n, v]); }; }
  function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
              case 0: case 1: t = op; break;
              case 4: _.label++; return { value: op[1], done: false };
              case 5: _.label++; y = op[1]; op = [0]; continue;
              case 7: op = _.ops.pop(); _.trys.pop(); continue;
              default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                  if (t[2]) _.ops.pop();
                  _.trys.pop(); continue;
          }
          op = body.call(thisArg, _);
      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
  }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
  }
  Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
      next: function () {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
      }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  }
  catch (error) { e = { error: error }; }
  finally {
      try {
          if (r && !r.done && (m = i["return"])) m.call(i);
      }
      finally { if (e) throw e.error; }
  }
  return ar;
}

/** @deprecated */
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
  return ar;
}

/** @deprecated */
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
  return r;
}

function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
      }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;
  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }
  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }
  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
  function fulfill(value) { resume("next", value); }
  function reject(value) { resume("throw", value); }
  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
  return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
  o["default"] = v;
};

var ownKeys = function(o) {
  ownKeys = Object.getOwnPropertyNames || function (o) {
    var ar = [];
    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
    return ar;
  };
  return ownKeys(o);
};

function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
  __setModuleDefault(result, mod);
  return result;
}

function __importDefault(mod) {
  return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}

function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };
    env.stack.push({ value: value, dispose: dispose, async: async });
  }
  else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}

var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  var r, s = 0;
  function next() {
    while (r = env.stack.pop()) {
      try {
        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
        if (r.dispose) {
          var result = r.dispose.call(r.value);
          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
        }
        else s |= 1;
      }
      catch (e) {
        fail(e);
      }
    }
    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
    if (env.hasError) throw env.error;
  }
  return next();
}

function __rewriteRelativeImportExtension(path, preserveJsx) {
  if (typeof path === "string" && /^\.\.?\//.test(path)) {
      return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {
          return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : (d + ext + "." + cm.toLowerCase() + "js");
      });
  }
  return path;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __esDecorate,
  __runInitializers,
  __propKey,
  __setFunctionName,
  __metadata,
  __awaiter,
  __generator,
  __createBinding,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
  __rewriteRelativeImportExtension,
});


/***/ }),
/* 42 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(41);
const buffer_js_1 = __webpack_require__(43);
/** @ignore */
exports["default"] = {
    fromIterable(source) {
        return pump(fromIterable(source));
    },
    fromAsyncIterable(source) {
        return pump(fromAsyncIterable(source));
    },
    fromDOMStream(source) {
        return pump(fromDOMStream(source));
    },
    fromNodeStream(stream) {
        return pump(fromNodeStream(stream));
    },
    // @ts-ignore
    toDOMStream(source, options) {
        throw new Error(`"toDOMStream" not available in this environment`);
    },
    // @ts-ignore
    toNodeStream(source, options) {
        throw new Error(`"toNodeStream" not available in this environment`);
    },
};
/** @ignore */
const pump = (iterator) => { iterator.next(); return iterator; };
/** @ignore */
function* fromIterable(source) {
    let done, threw = false;
    let buffers = [], buffer;
    let cmd, size, bufferLength = 0;
    function byteRange() {
        if (cmd === 'peek') {
            return (0, buffer_js_1.joinUint8Arrays)(buffers, size)[0];
        }
        [buffer, buffers, bufferLength] = (0, buffer_js_1.joinUint8Arrays)(buffers, size);
        return buffer;
    }
    // Yield so the caller can inject the read command before creating the source Iterator
    ({ cmd, size } = (yield (() => null)()) || { cmd: 'read', size: 0 });
    // initialize the iterator
    const it = (0, buffer_js_1.toUint8ArrayIterator)(source)[Symbol.iterator]();
    try {
        do {
            // read the next value
            ({ done, value: buffer } = Number.isNaN(size - bufferLength) ?
                it.next() : it.next(size - bufferLength));
            // if chunk is not null or empty, push it onto the queue
            if (!done && buffer.byteLength > 0) {
                buffers.push(buffer);
                bufferLength += buffer.byteLength;
            }
            // If we have enough bytes in our buffer, yield chunks until we don't
            if (done || size <= bufferLength) {
                do {
                    ({ cmd, size } = yield byteRange());
                } while (size < bufferLength);
            }
        } while (!done);
    }
    catch (e) {
        (threw = true) && (typeof it.throw === 'function') && (it.throw(e));
    }
    finally {
        (threw === false) && (typeof it.return === 'function') && (it.return(null));
    }
    return null;
}
/** @ignore */
function fromAsyncIterable(source) {
    return tslib_1.__asyncGenerator(this, arguments, function* fromAsyncIterable_1() {
        let done, threw = false;
        let buffers = [], buffer;
        let cmd, size, bufferLength = 0;
        function byteRange() {
            if (cmd === 'peek') {
                return (0, buffer_js_1.joinUint8Arrays)(buffers, size)[0];
            }
            [buffer, buffers, bufferLength] = (0, buffer_js_1.joinUint8Arrays)(buffers, size);
            return buffer;
        }
        // Yield so the caller can inject the read command before creating the source AsyncIterator
        ({ cmd, size } = (yield yield tslib_1.__await((() => null)())) || { cmd: 'read', size: 0 });
        // initialize the iterator
        const it = (0, buffer_js_1.toUint8ArrayAsyncIterator)(source)[Symbol.asyncIterator]();
        try {
            do {
                // read the next value
                ({ done, value: buffer } = Number.isNaN(size - bufferLength)
                    ? yield tslib_1.__await(it.next())
                    : yield tslib_1.__await(it.next(size - bufferLength)));
                // if chunk is not null or empty, push it onto the queue
                if (!done && buffer.byteLength > 0) {
                    buffers.push(buffer);
                    bufferLength += buffer.byteLength;
                }
                // If we have enough bytes in our buffer, yield chunks until we don't
                if (done || size <= bufferLength) {
                    do {
                        ({ cmd, size } = yield yield tslib_1.__await(byteRange()));
                    } while (size < bufferLength);
                }
            } while (!done);
        }
        catch (e) {
            (threw = true) && (typeof it.throw === 'function') && (yield tslib_1.__await(it.throw(e)));
        }
        finally {
            (threw === false) && (typeof it.return === 'function') && (yield tslib_1.__await(it.return(new Uint8Array(0))));
        }
        return yield tslib_1.__await(null);
    });
}
// All this manual Uint8Array chunk management can be avoided if/when engines
// add support for ArrayBuffer.transfer() or ArrayBuffer.prototype.realloc():
// https://github.com/domenic/proposal-arraybuffer-transfer
/** @ignore */
function fromDOMStream(source) {
    return tslib_1.__asyncGenerator(this, arguments, function* fromDOMStream_1() {
        let done = false, threw = false;
        let buffers = [], buffer;
        let cmd, size, bufferLength = 0;
        function byteRange() {
            if (cmd === 'peek') {
                return (0, buffer_js_1.joinUint8Arrays)(buffers, size)[0];
            }
            [buffer, buffers, bufferLength] = (0, buffer_js_1.joinUint8Arrays)(buffers, size);
            return buffer;
        }
        // Yield so the caller can inject the read command before we establish the ReadableStream lock
        ({ cmd, size } = (yield yield tslib_1.__await((() => null)())) || { cmd: 'read', size: 0 });
        // initialize the reader and lock the stream
        const it = new AdaptiveByteReader(source);
        try {
            do {
                // read the next value
                ({ done, value: buffer } = Number.isNaN(size - bufferLength)
                    ? yield tslib_1.__await(it['read']())
                    : yield tslib_1.__await(it['read'](size - bufferLength)));
                // if chunk is not null or empty, push it onto the queue
                if (!done && buffer.byteLength > 0) {
                    buffers.push((0, buffer_js_1.toUint8Array)(buffer));
                    bufferLength += buffer.byteLength;
                }
                // If we have enough bytes in our buffer, yield chunks until we don't
                if (done || size <= bufferLength) {
                    do {
                        ({ cmd, size } = yield yield tslib_1.__await(byteRange()));
                    } while (size < bufferLength);
                }
            } while (!done);
        }
        catch (e) {
            (threw = true) && (yield tslib_1.__await(it['cancel'](e)));
        }
        finally {
            (threw === false) ? (yield tslib_1.__await(it['cancel']()))
                : source['locked'] && it.releaseLock();
        }
        return yield tslib_1.__await(null);
    });
}
/** @ignore */
class AdaptiveByteReader {
    constructor(source) {
        this.source = source;
        this.reader = null;
        this.reader = this.source['getReader']();
        // We have to catch and swallow errors here to avoid uncaught promise rejection exceptions
        // that seem to be raised when we call `releaseLock()` on this reader. I'm still mystified
        // about why these errors are raised, but I'm sure there's some important spec reason that
        // I haven't considered. I hate to employ such an anti-pattern here, but it seems like the
        // only solution in this case :/
        this.reader['closed'].catch(() => { });
    }
    get closed() {
        return this.reader ? this.reader['closed'].catch(() => { }) : Promise.resolve();
    }
    releaseLock() {
        if (this.reader) {
            this.reader.releaseLock();
        }
        this.reader = null;
    }
    cancel(reason) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { reader, source } = this;
            reader && (yield reader['cancel'](reason).catch(() => { }));
            source && (source['locked'] && this.releaseLock());
        });
    }
    read(size) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (size === 0) {
                return { done: this.reader == null, value: new Uint8Array(0) };
            }
            const result = yield this.reader.read();
            !result.done && (result.value = (0, buffer_js_1.toUint8Array)(result));
            return result;
        });
    }
}
/** @ignore */
const onEvent = (stream, event) => {
    const handler = (_) => resolve([event, _]);
    let resolve;
    return [event, handler, new Promise((r) => (resolve = r) && stream['once'](event, handler))];
};
/** @ignore */
function fromNodeStream(stream) {
    return tslib_1.__asyncGenerator(this, arguments, function* fromNodeStream_1() {
        const events = [];
        let event = 'error';
        let done = false, err = null;
        let cmd, size, bufferLength = 0;
        let buffers = [], buffer;
        function byteRange() {
            if (cmd === 'peek') {
                return (0, buffer_js_1.joinUint8Arrays)(buffers, size)[0];
            }
            [buffer, buffers, bufferLength] = (0, buffer_js_1.joinUint8Arrays)(buffers, size);
            return buffer;
        }
        // Yield so the caller can inject the read command before we
        // add the listener for the source stream's 'readable' event.
        ({ cmd, size } = (yield yield tslib_1.__await((() => null)())) || { cmd: 'read', size: 0 });
        // ignore stdin if it's a TTY
        if (stream['isTTY']) {
            yield yield tslib_1.__await(new Uint8Array(0));
            return yield tslib_1.__await(null);
        }
        try {
            // initialize the stream event handlers
            events[0] = onEvent(stream, 'end');
            events[1] = onEvent(stream, 'error');
            do {
                events[2] = onEvent(stream, 'readable');
                // wait on the first message event from the stream
                [event, err] = yield tslib_1.__await(Promise.race(events.map((x) => x[2])));
                // if the stream emitted an Error, rethrow it
                if (event === 'error') {
                    break;
                }
                if (!(done = event === 'end')) {
                    // If the size is NaN, request to read everything in the stream's internal buffer
                    if (!Number.isFinite(size - bufferLength)) {
                        buffer = (0, buffer_js_1.toUint8Array)(stream['read']());
                    }
                    else {
                        buffer = (0, buffer_js_1.toUint8Array)(stream['read'](size - bufferLength));
                        // If the byteLength is 0, then the requested amount is more than the stream has
                        // in its internal buffer. In this case the stream needs a "kick" to tell it to
                        // continue emitting readable events, so request to read everything the stream
                        // has in its internal buffer right now.
                        if (buffer.byteLength < (size - bufferLength)) {
                            buffer = (0, buffer_js_1.toUint8Array)(stream['read']());
                        }
                    }
                    // if chunk is not null or empty, push it onto the queue
                    if (buffer.byteLength > 0) {
                        buffers.push(buffer);
                        bufferLength += buffer.byteLength;
                    }
                }
                // If we have enough bytes in our buffer, yield chunks until we don't
                if (done || size <= bufferLength) {
                    do {
                        ({ cmd, size } = yield yield tslib_1.__await(byteRange()));
                    } while (size < bufferLength);
                }
            } while (!done);
        }
        finally {
            yield tslib_1.__await(cleanup(events, event === 'error' ? err : null));
        }
        return yield tslib_1.__await(null);
        function cleanup(events, err) {
            buffer = buffers = null;
            return new Promise((resolve, reject) => {
                for (const [evt, fn] of events) {
                    stream['off'](evt, fn);
                }
                try {
                    // Some stream implementations don't call the destroy callback,
                    // because it's really a node-internal API. Just calling `destroy`
                    // here should be enough to conform to the ReadableStream contract
                    const destroy = stream['destroy'];
                    destroy && destroy.call(stream, err);
                    err = undefined;
                }
                catch (e) {
                    err = e || err;
                }
                finally {
                    err != null ? reject(err) : resolve();
                }
            });
        }
    });
}

//# sourceMappingURL=adapters.js.map


/***/ }),
/* 43 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.compareArrayLike = exports.rebaseValueOffsets = exports.toUint8ClampedArrayAsyncIterator = exports.toFloat64ArrayAsyncIterator = exports.toFloat32ArrayAsyncIterator = exports.toUint32ArrayAsyncIterator = exports.toUint16ArrayAsyncIterator = exports.toUint8ArrayAsyncIterator = exports.toInt32ArrayAsyncIterator = exports.toInt16ArrayAsyncIterator = exports.toInt8ArrayAsyncIterator = exports.toArrayBufferViewAsyncIterator = exports.toUint8ClampedArrayIterator = exports.toFloat64ArrayIterator = exports.toFloat32ArrayIterator = exports.toUint32ArrayIterator = exports.toUint16ArrayIterator = exports.toUint8ArrayIterator = exports.toInt32ArrayIterator = exports.toInt16ArrayIterator = exports.toInt8ArrayIterator = exports.toArrayBufferViewIterator = exports.toUint8ClampedArray = exports.toFloat64Array = exports.toFloat32Array = exports.toBigUint64Array = exports.toUint32Array = exports.toUint16Array = exports.toUint8Array = exports.toBigInt64Array = exports.toInt32Array = exports.toInt16Array = exports.toInt8Array = exports.toArrayBufferView = exports.joinUint8Arrays = exports.memcpy = void 0;
const tslib_1 = __webpack_require__(41);
const utf8_js_1 = __webpack_require__(44);
const compat_js_1 = __webpack_require__(45);
/** @ignore */
const SharedArrayBuf = (typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : ArrayBuffer);
/** @ignore */
function collapseContiguousByteRanges(chunks) {
    const result = chunks[0] ? [chunks[0]] : [];
    let xOffset, yOffset, xLen, yLen;
    for (let x, y, i = 0, j = 0, n = chunks.length; ++i < n;) {
        x = result[j];
        y = chunks[i];
        // continue if x and y don't share the same underlying ArrayBuffer, or if x isn't before y
        if (!x || !y || x.buffer !== y.buffer || y.byteOffset < x.byteOffset) {
            y && (result[++j] = y);
            continue;
        }
        ({ byteOffset: xOffset, byteLength: xLen } = x);
        ({ byteOffset: yOffset, byteLength: yLen } = y);
        // continue if the byte ranges of x and y aren't contiguous
        if ((xOffset + xLen) < yOffset || (yOffset + yLen) < xOffset) {
            y && (result[++j] = y);
            continue;
        }
        result[j] = new Uint8Array(x.buffer, xOffset, yOffset - xOffset + yLen);
    }
    return result;
}
/** @ignore */
function memcpy(target, source, targetByteOffset = 0, sourceByteLength = source.byteLength) {
    const targetByteLength = target.byteLength;
    const dst = new Uint8Array(target.buffer, target.byteOffset, targetByteLength);
    const src = new Uint8Array(source.buffer, source.byteOffset, Math.min(sourceByteLength, targetByteLength));
    dst.set(src, targetByteOffset);
    return target;
}
exports.memcpy = memcpy;
/** @ignore */
function joinUint8Arrays(chunks, size) {
    // collapse chunks that share the same underlying ArrayBuffer and whose byte ranges overlap,
    // to avoid unnecessarily copying the bytes to do this buffer join. This is a common case during
    // streaming, where we may be reading partial byte ranges out of the same underlying ArrayBuffer
    const result = collapseContiguousByteRanges(chunks);
    const byteLength = result.reduce((x, b) => x + b.byteLength, 0);
    let source, sliced, buffer;
    let offset = 0, index = -1;
    const length = Math.min(size || Number.POSITIVE_INFINITY, byteLength);
    for (const n = result.length; ++index < n;) {
        source = result[index];
        sliced = source.subarray(0, Math.min(source.length, length - offset));
        if (length <= (offset + sliced.length)) {
            if (sliced.length < source.length) {
                result[index] = source.subarray(sliced.length);
            }
            else if (sliced.length === source.length) {
                index++;
            }
            buffer ? memcpy(buffer, sliced, offset) : (buffer = sliced);
            break;
        }
        memcpy(buffer || (buffer = new Uint8Array(length)), sliced, offset);
        offset += sliced.length;
    }
    return [buffer || new Uint8Array(0), result.slice(index), byteLength - (buffer ? buffer.byteLength : 0)];
}
exports.joinUint8Arrays = joinUint8Arrays;
/** @ignore */
function toArrayBufferView(ArrayBufferViewCtor, input) {
    let value = (0, compat_js_1.isIteratorResult)(input) ? input.value : input;
    if (value instanceof ArrayBufferViewCtor) {
        if (ArrayBufferViewCtor === Uint8Array) {
            // Node's `Buffer` class passes the `instanceof Uint8Array` check, but we need
            // a real Uint8Array, since Buffer#slice isn't the same as Uint8Array#slice :/
            return new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength);
        }
        return value;
    }
    if (!value) {
        return new ArrayBufferViewCtor(0);
    }
    if (typeof value === 'string') {
        value = (0, utf8_js_1.encodeUtf8)(value);
    }
    if (value instanceof ArrayBuffer) {
        return new ArrayBufferViewCtor(value);
    }
    if (value instanceof SharedArrayBuf) {
        return new ArrayBufferViewCtor(value);
    }
    if ((0, compat_js_1.isFlatbuffersByteBuffer)(value)) {
        return toArrayBufferView(ArrayBufferViewCtor, value.bytes());
    }
    return !ArrayBuffer.isView(value) ? ArrayBufferViewCtor.from(value) : (value.byteLength <= 0 ? new ArrayBufferViewCtor(0)
        : new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength / ArrayBufferViewCtor.BYTES_PER_ELEMENT));
}
exports.toArrayBufferView = toArrayBufferView;
/** @ignore */ const toInt8Array = (input) => toArrayBufferView(Int8Array, input);
exports.toInt8Array = toInt8Array;
/** @ignore */ const toInt16Array = (input) => toArrayBufferView(Int16Array, input);
exports.toInt16Array = toInt16Array;
/** @ignore */ const toInt32Array = (input) => toArrayBufferView(Int32Array, input);
exports.toInt32Array = toInt32Array;
/** @ignore */ const toBigInt64Array = (input) => toArrayBufferView(BigInt64Array, input);
exports.toBigInt64Array = toBigInt64Array;
/** @ignore */ const toUint8Array = (input) => toArrayBufferView(Uint8Array, input);
exports.toUint8Array = toUint8Array;
/** @ignore */ const toUint16Array = (input) => toArrayBufferView(Uint16Array, input);
exports.toUint16Array = toUint16Array;
/** @ignore */ const toUint32Array = (input) => toArrayBufferView(Uint32Array, input);
exports.toUint32Array = toUint32Array;
/** @ignore */ const toBigUint64Array = (input) => toArrayBufferView(BigUint64Array, input);
exports.toBigUint64Array = toBigUint64Array;
/** @ignore */ const toFloat32Array = (input) => toArrayBufferView(Float32Array, input);
exports.toFloat32Array = toFloat32Array;
/** @ignore */ const toFloat64Array = (input) => toArrayBufferView(Float64Array, input);
exports.toFloat64Array = toFloat64Array;
/** @ignore */ const toUint8ClampedArray = (input) => toArrayBufferView(Uint8ClampedArray, input);
exports.toUint8ClampedArray = toUint8ClampedArray;
/** @ignore */
const pump = (iterator) => { iterator.next(); return iterator; };
/** @ignore */
function* toArrayBufferViewIterator(ArrayCtor, source) {
    const wrap = function* (x) { yield x; };
    const buffers = (typeof source === 'string') ? wrap(source)
        : (ArrayBuffer.isView(source)) ? wrap(source)
            : (source instanceof ArrayBuffer) ? wrap(source)
                : (source instanceof SharedArrayBuf) ? wrap(source)
                    : !(0, compat_js_1.isIterable)(source) ? wrap(source) : source;
    yield* pump((function* (it) {
        let r = null;
        do {
            r = it.next(yield toArrayBufferView(ArrayCtor, r));
        } while (!r.done);
    })(buffers[Symbol.iterator]()));
    return new ArrayCtor();
}
exports.toArrayBufferViewIterator = toArrayBufferViewIterator;
/** @ignore */ const toInt8ArrayIterator = (input) => toArrayBufferViewIterator(Int8Array, input);
exports.toInt8ArrayIterator = toInt8ArrayIterator;
/** @ignore */ const toInt16ArrayIterator = (input) => toArrayBufferViewIterator(Int16Array, input);
exports.toInt16ArrayIterator = toInt16ArrayIterator;
/** @ignore */ const toInt32ArrayIterator = (input) => toArrayBufferViewIterator(Int32Array, input);
exports.toInt32ArrayIterator = toInt32ArrayIterator;
/** @ignore */ const toUint8ArrayIterator = (input) => toArrayBufferViewIterator(Uint8Array, input);
exports.toUint8ArrayIterator = toUint8ArrayIterator;
/** @ignore */ const toUint16ArrayIterator = (input) => toArrayBufferViewIterator(Uint16Array, input);
exports.toUint16ArrayIterator = toUint16ArrayIterator;
/** @ignore */ const toUint32ArrayIterator = (input) => toArrayBufferViewIterator(Uint32Array, input);
exports.toUint32ArrayIterator = toUint32ArrayIterator;
/** @ignore */ const toFloat32ArrayIterator = (input) => toArrayBufferViewIterator(Float32Array, input);
exports.toFloat32ArrayIterator = toFloat32ArrayIterator;
/** @ignore */ const toFloat64ArrayIterator = (input) => toArrayBufferViewIterator(Float64Array, input);
exports.toFloat64ArrayIterator = toFloat64ArrayIterator;
/** @ignore */ const toUint8ClampedArrayIterator = (input) => toArrayBufferViewIterator(Uint8ClampedArray, input);
exports.toUint8ClampedArrayIterator = toUint8ClampedArrayIterator;
/** @ignore */
function toArrayBufferViewAsyncIterator(ArrayCtor, source) {
    return tslib_1.__asyncGenerator(this, arguments, function* toArrayBufferViewAsyncIterator_1() {
        // if a Promise, unwrap the Promise and iterate the resolved value
        if ((0, compat_js_1.isPromise)(source)) {
            return yield tslib_1.__await(yield tslib_1.__await(yield* tslib_1.__asyncDelegator(tslib_1.__asyncValues(toArrayBufferViewAsyncIterator(ArrayCtor, yield tslib_1.__await(source))))));
        }
        const wrap = function (x) { return tslib_1.__asyncGenerator(this, arguments, function* () { yield yield tslib_1.__await(yield tslib_1.__await(x)); }); };
        const emit = function (source) {
            return tslib_1.__asyncGenerator(this, arguments, function* () {
                yield tslib_1.__await(yield* tslib_1.__asyncDelegator(tslib_1.__asyncValues(pump((function* (it) {
                    let r = null;
                    do {
                        r = it.next(yield r === null || r === void 0 ? void 0 : r.value);
                    } while (!r.done);
                })(source[Symbol.iterator]())))));
            });
        };
        const buffers = (typeof source === 'string') ? wrap(source) // if string, wrap in an AsyncIterableIterator
            : (ArrayBuffer.isView(source)) ? wrap(source) // if TypedArray, wrap in an AsyncIterableIterator
                : (source instanceof ArrayBuffer) ? wrap(source) // if ArrayBuffer, wrap in an AsyncIterableIterator
                    : (source instanceof SharedArrayBuf) ? wrap(source) // if SharedArrayBuffer, wrap in an AsyncIterableIterator
                        : (0, compat_js_1.isIterable)(source) ? emit(source) // If Iterable, wrap in an AsyncIterableIterator and compose the `next` values
                            : !(0, compat_js_1.isAsyncIterable)(source) ? wrap(source) // If not an AsyncIterable, treat as a sentinel and wrap in an AsyncIterableIterator
                                : source; // otherwise if AsyncIterable, use it
        yield tslib_1.__await(// otherwise if AsyncIterable, use it
        yield* tslib_1.__asyncDelegator(tslib_1.__asyncValues(pump((function (it) {
            return tslib_1.__asyncGenerator(this, arguments, function* () {
                let r = null;
                do {
                    r = yield tslib_1.__await(it.next(yield yield tslib_1.__await(toArrayBufferView(ArrayCtor, r))));
                } while (!r.done);
            });
        })(buffers[Symbol.asyncIterator]())))));
        return yield tslib_1.__await(new ArrayCtor());
    });
}
exports.toArrayBufferViewAsyncIterator = toArrayBufferViewAsyncIterator;
/** @ignore */ const toInt8ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int8Array, input);
exports.toInt8ArrayAsyncIterator = toInt8ArrayAsyncIterator;
/** @ignore */ const toInt16ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int16Array, input);
exports.toInt16ArrayAsyncIterator = toInt16ArrayAsyncIterator;
/** @ignore */ const toInt32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int32Array, input);
exports.toInt32ArrayAsyncIterator = toInt32ArrayAsyncIterator;
/** @ignore */ const toUint8ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint8Array, input);
exports.toUint8ArrayAsyncIterator = toUint8ArrayAsyncIterator;
/** @ignore */ const toUint16ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint16Array, input);
exports.toUint16ArrayAsyncIterator = toUint16ArrayAsyncIterator;
/** @ignore */ const toUint32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint32Array, input);
exports.toUint32ArrayAsyncIterator = toUint32ArrayAsyncIterator;
/** @ignore */ const toFloat32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Float32Array, input);
exports.toFloat32ArrayAsyncIterator = toFloat32ArrayAsyncIterator;
/** @ignore */ const toFloat64ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Float64Array, input);
exports.toFloat64ArrayAsyncIterator = toFloat64ArrayAsyncIterator;
/** @ignore */ const toUint8ClampedArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint8ClampedArray, input);
exports.toUint8ClampedArrayAsyncIterator = toUint8ClampedArrayAsyncIterator;
function rebaseValueOffsets(offset, length, valueOffsets) {
    // If we have a non-zero offset, create a new offsets array with the values
    // shifted by the start offset, such that the new start offset is 0
    if (offset !== 0) {
        valueOffsets = valueOffsets.slice(0, length);
        for (let i = -1, n = valueOffsets.length; ++i < n;) {
            valueOffsets[i] += offset;
        }
    }
    return valueOffsets.subarray(0, length);
}
exports.rebaseValueOffsets = rebaseValueOffsets;
/** @ignore */
function compareArrayLike(a, b) {
    let i = 0;
    const n = a.length;
    if (n !== b.length) {
        return false;
    }
    if (n > 0) {
        do {
            if (a[i] !== b[i]) {
                return false;
            }
        } while (++i < n);
    }
    return true;
}
exports.compareArrayLike = compareArrayLike;

//# sourceMappingURL=buffer.js.map


/***/ }),
/* 44 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeUtf8 = exports.decodeUtf8 = void 0;
const decoder = new TextDecoder('utf-8');
/** @ignore */
const decodeUtf8 = (buffer) => decoder.decode(buffer);
exports.decodeUtf8 = decodeUtf8;
const encoder = new TextEncoder();
/** @ignore */
const encodeUtf8 = (value) => encoder.encode(value);
exports.encodeUtf8 = encodeUtf8;

//# sourceMappingURL=utf8.js.map


/***/ }),
/* 45 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isFlatbuffersByteBuffer = exports.isReadableNodeStream = exports.isWritableNodeStream = exports.isReadableDOMStream = exports.isWritableDOMStream = exports.isFetchResponse = exports.isFSReadStream = exports.isFileHandle = exports.isUnderlyingSink = exports.isIteratorResult = exports.isArrayLike = exports.isArrowJSON = exports.isAsyncIterable = exports.isIterable = exports.isObservable = exports.isPromise = exports.isObject = void 0;
/** @ignore */ const isNumber = (x) => typeof x === 'number';
/** @ignore */ const isBoolean = (x) => typeof x === 'boolean';
/** @ignore */ const isFunction = (x) => typeof x === 'function';
/** @ignore */
// eslint-disable-next-line @typescript-eslint/ban-types
const isObject = (x) => x != null && Object(x) === x;
exports.isObject = isObject;
/** @ignore */
const isPromise = (x) => {
    return (0, exports.isObject)(x) && isFunction(x.then);
};
exports.isPromise = isPromise;
/** @ignore */
const isObservable = (x) => {
    return (0, exports.isObject)(x) && isFunction(x.subscribe);
};
exports.isObservable = isObservable;
/** @ignore */
const isIterable = (x) => {
    return (0, exports.isObject)(x) && isFunction(x[Symbol.iterator]);
};
exports.isIterable = isIterable;
/** @ignore */
const isAsyncIterable = (x) => {
    return (0, exports.isObject)(x) && isFunction(x[Symbol.asyncIterator]);
};
exports.isAsyncIterable = isAsyncIterable;
/** @ignore */
const isArrowJSON = (x) => {
    return (0, exports.isObject)(x) && (0, exports.isObject)(x['schema']);
};
exports.isArrowJSON = isArrowJSON;
/** @ignore */
const isArrayLike = (x) => {
    return (0, exports.isObject)(x) && isNumber(x['length']);
};
exports.isArrayLike = isArrayLike;
/** @ignore */
const isIteratorResult = (x) => {
    return (0, exports.isObject)(x) && ('done' in x) && ('value' in x);
};
exports.isIteratorResult = isIteratorResult;
/** @ignore */
const isUnderlyingSink = (x) => {
    return (0, exports.isObject)(x) &&
        isFunction(x['abort']) &&
        isFunction(x['close']) &&
        isFunction(x['start']) &&
        isFunction(x['write']);
};
exports.isUnderlyingSink = isUnderlyingSink;
/** @ignore */
const isFileHandle = (x) => {
    return (0, exports.isObject)(x) && isFunction(x['stat']) && isNumber(x['fd']);
};
exports.isFileHandle = isFileHandle;
/** @ignore */
const isFSReadStream = (x) => {
    return (0, exports.isReadableNodeStream)(x) && isNumber(x['bytesRead']);
};
exports.isFSReadStream = isFSReadStream;
/** @ignore */
const isFetchResponse = (x) => {
    return (0, exports.isObject)(x) && (0, exports.isReadableDOMStream)(x['body']);
};
exports.isFetchResponse = isFetchResponse;
const isReadableInterop = (x) => ('_getDOMStream' in x && '_getNodeStream' in x);
/** @ignore */
const isWritableDOMStream = (x) => {
    return (0, exports.isObject)(x) &&
        isFunction(x['abort']) &&
        isFunction(x['getWriter']) &&
        !isReadableInterop(x);
};
exports.isWritableDOMStream = isWritableDOMStream;
/** @ignore */
const isReadableDOMStream = (x) => {
    return (0, exports.isObject)(x) &&
        isFunction(x['cancel']) &&
        isFunction(x['getReader']) &&
        !isReadableInterop(x);
};
exports.isReadableDOMStream = isReadableDOMStream;
/** @ignore */
const isWritableNodeStream = (x) => {
    return (0, exports.isObject)(x) &&
        isFunction(x['end']) &&
        isFunction(x['write']) &&
        isBoolean(x['writable']) &&
        !isReadableInterop(x);
};
exports.isWritableNodeStream = isWritableNodeStream;
/** @ignore */
const isReadableNodeStream = (x) => {
    return (0, exports.isObject)(x) &&
        isFunction(x['read']) &&
        isFunction(x['pipe']) &&
        isBoolean(x['readable']) &&
        !isReadableInterop(x);
};
exports.isReadableNodeStream = isReadableNodeStream;
/** @ignore */
const isFlatbuffersByteBuffer = (x) => {
    return (0, exports.isObject)(x) &&
        isFunction(x['clear']) &&
        isFunction(x['bytes']) &&
        isFunction(x['position']) &&
        isFunction(x['setPosition']) &&
        isFunction(x['capacity']) &&
        isFunction(x['getBufferIdentifier']) &&
        isFunction(x['createLong']);
};
exports.isFlatbuffersByteBuffer = isFlatbuffersByteBuffer;

//# sourceMappingURL=compat.js.map


/***/ }),
/* 46 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VariableWidthBuilder = exports.FixedWidthBuilder = exports.Builder = void 0;
const vector_js_1 = __webpack_require__(47);
const data_js_1 = __webpack_require__(117);
const map_js_1 = __webpack_require__(107);
const type_js_1 = __webpack_require__(113);
const valid_js_1 = __webpack_require__(122);
const buffer_js_1 = __webpack_require__(123);
/**
 * An abstract base class for types that construct Arrow Vectors from arbitrary JavaScript values.
 *
 * A `Builder` is responsible for writing arbitrary JavaScript values
 * to ArrayBuffers and/or child Builders according to the Arrow specification
 * for each DataType, creating or resizing the underlying ArrayBuffers as necessary.
 *
 * The `Builder` for each Arrow `DataType` handles converting and appending
 * values for a given `DataType`. The high-level {@link makeBuilder `makeBuilder()`} convenience
 * method creates the specific `Builder` subclass for the supplied `DataType`.
 *
 * Once created, `Builder` instances support both appending values to the end
 * of the `Builder`, and random-access writes to specific indices
 * (`Builder.prototype.append(value)` is a convenience method for
 * `builder.set(builder.length, value)`). Appending or setting values beyond the
 * Builder's current length may cause the builder to grow its underlying buffers
 * or child Builders (if applicable) to accommodate the new values.
 *
 * After enough values have been written to a `Builder`, `Builder.prototype.flush()`
 * will commit the values to the underlying ArrayBuffers (or child Builders). The
 * internal Builder state will be reset, and an instance of `Data<T>` is returned.
 * Alternatively, `Builder.prototype.toVector()` will flush the `Builder` and return
 * an instance of `Vector<T>` instead.
 *
 * When there are no more values to write, use `Builder.prototype.finish()` to
 * finalize the `Builder`. This does not reset the internal state, so it is
 * necessary to call `Builder.prototype.flush()` or `toVector()` one last time
 * if there are still values queued to be flushed.
 *
 * Note: calling `Builder.prototype.finish()` is required when using a `DictionaryBuilder`,
 * because this is when it flushes the values that have been enqueued in its internal
 * dictionary's `Builder`, and creates the `dictionaryVector` for the `Dictionary` `DataType`.
 *
 * @example
 * ```ts
 * import { makeBuilder, Utf8 } from 'apache-arrow';
 *
 * const utf8Builder = makeBuilder({
 *     type: new Utf8(),
 *     nullValues: [null, 'n/a']
 * });
 *
 * utf8Builder
 *     .append('hello')
 *     .append('n/a')
 *     .append('world')
 *     .append(null);
 *
 * const utf8Vector = utf8Builder.finish().toVector();
 *
 * console.log(utf8Vector.toJSON());
 * // > ["hello", null, "world", null]
 * ```
 *
 * @typeparam T The `DataType` of this `Builder`.
 * @typeparam TNull The type(s) of values which will be considered null-value sentinels.
 */
class Builder {
    /** @nocollapse */
    // @ts-ignore
    static throughNode(options) {
        throw new Error(`"throughNode" not available in this environment`);
    }
    /** @nocollapse */
    // @ts-ignore
    static throughDOM(options) {
        throw new Error(`"throughDOM" not available in this environment`);
    }
    /**
     * Construct a builder with the given Arrow DataType with optional null values,
     * which will be interpreted as "null" when set or appended to the `Builder`.
     * @param {{ type: T, nullValues?: any[] }} options A `BuilderOptions` object used to create this `Builder`.
     */
    constructor({ 'type': type, 'nullValues': nulls }) {
        /**
         * The number of values written to the `Builder` that haven't been flushed yet.
         * @readonly
         */
        this.length = 0;
        /**
         * A boolean indicating whether `Builder.prototype.finish()` has been called on this `Builder`.
         * @readonly
         */
        this.finished = false;
        this.type = type;
        this.children = [];
        this.nullValues = nulls;
        this.stride = (0, type_js_1.strideForType)(type);
        this._nulls = new buffer_js_1.BitmapBufferBuilder();
        if (nulls && nulls.length > 0) {
            this._isValid = (0, valid_js_1.createIsValidFunction)(nulls);
        }
    }
    /**
     * Flush the `Builder` and return a `Vector<T>`.
     * @returns {Vector<T>} A `Vector<T>` of the flushed values.
     */
    toVector() { return new vector_js_1.Vector([this.flush()]); }
    get ArrayType() { return this.type.ArrayType; }
    get nullCount() { return this._nulls.numInvalid; }
    get numChildren() { return this.children.length; }
    /**
     * @returns The aggregate length (in bytes) of the values that have been written.
     */
    get byteLength() {
        let size = 0;
        const { _offsets, _values, _nulls, _typeIds, children } = this;
        _offsets && (size += _offsets.byteLength);
        _values && (size += _values.byteLength);
        _nulls && (size += _nulls.byteLength);
        _typeIds && (size += _typeIds.byteLength);
        return children.reduce((size, child) => size + child.byteLength, size);
    }
    /**
     * @returns The aggregate number of rows that have been reserved to write new values.
     */
    get reservedLength() {
        return this._nulls.reservedLength;
    }
    /**
     * @returns The aggregate length (in bytes) that has been reserved to write new values.
     */
    get reservedByteLength() {
        let size = 0;
        this._offsets && (size += this._offsets.reservedByteLength);
        this._values && (size += this._values.reservedByteLength);
        this._nulls && (size += this._nulls.reservedByteLength);
        this._typeIds && (size += this._typeIds.reservedByteLength);
        return this.children.reduce((size, child) => size + child.reservedByteLength, size);
    }
    get valueOffsets() { return this._offsets ? this._offsets.buffer : null; }
    get values() { return this._values ? this._values.buffer : null; }
    get nullBitmap() { return this._nulls ? this._nulls.buffer : null; }
    get typeIds() { return this._typeIds ? this._typeIds.buffer : null; }
    /**
     * Appends a value (or null) to this `Builder`.
     * This is equivalent to `builder.set(builder.length, value)`.
     * @param {T['TValue'] | TNull } value The value to append.
     */
    append(value) { return this.set(this.length, value); }
    /**
     * Validates whether a value is valid (true), or null (false)
     * @param {T['TValue'] | TNull } value The value to compare against null the value representations
     */
    isValid(value) { return this._isValid(value); }
    /**
     * Write a value (or null-value sentinel) at the supplied index.
     * If the value matches one of the null-value representations, a 1-bit is
     * written to the null `BitmapBufferBuilder`. Otherwise, a 0 is written to
     * the null `BitmapBufferBuilder`, and the value is passed to
     * `Builder.prototype.setValue()`.
     * @param {number} index The index of the value to write.
     * @param {T['TValue'] | TNull } value The value to write at the supplied index.
     * @returns {this} The updated `Builder` instance.
     */
    set(index, value) {
        if (this.setValid(index, this.isValid(value))) {
            this.setValue(index, value);
        }
        return this;
    }
    /**
     * Write a value to the underlying buffers at the supplied index, bypassing
     * the null-value check. This is a low-level method that
     * @param {number} index
     * @param {T['TValue'] | TNull } value
     */
    setValue(index, value) { this._setValue(this, index, value); }
    setValid(index, valid) {
        this.length = this._nulls.set(index, +valid).length;
        return valid;
    }
    // @ts-ignore
    addChild(child, name = `${this.numChildren}`) {
        throw new Error(`Cannot append children to non-nested type "${this.type}"`);
    }
    /**
     * Retrieve the child `Builder` at the supplied `index`, or null if no child
     * exists at that index.
     * @param {number} index The index of the child `Builder` to retrieve.
     * @returns {Builder | null} The child Builder at the supplied index or null.
     */
    getChildAt(index) {
        return this.children[index] || null;
    }
    /**
     * Commit all the values that have been written to their underlying
     * ArrayBuffers, including any child Builders if applicable, and reset
     * the internal `Builder` state.
     * @returns A `Data<T>` of the buffers and children representing the values written.
     */
    flush() {
        let data;
        let typeIds;
        let nullBitmap;
        let valueOffsets;
        const { type, length, nullCount, _typeIds, _offsets, _values, _nulls } = this;
        if (typeIds = _typeIds === null || _typeIds === void 0 ? void 0 : _typeIds.flush(length)) { // Unions, DenseUnions
            valueOffsets = _offsets === null || _offsets === void 0 ? void 0 : _offsets.flush(length);
        }
        else if (valueOffsets = _offsets === null || _offsets === void 0 ? void 0 : _offsets.flush(length)) { // Variable-width primitives (Binary, LargeBinary, Utf8, LargeUtf8), and Lists
            data = _values === null || _values === void 0 ? void 0 : _values.flush(_offsets.last());
        }
        else { // Fixed-width primitives (Int, Float, Decimal, Time, Timestamp, Duration and Interval)
            data = _values === null || _values === void 0 ? void 0 : _values.flush(length);
        }
        if (nullCount > 0) {
            nullBitmap = _nulls === null || _nulls === void 0 ? void 0 : _nulls.flush(length);
        }
        const children = this.children.map((child) => child.flush());
        this.clear();
        return (0, data_js_1.makeData)({
            type, length, nullCount,
            children, 'child': children[0],
            data, typeIds, nullBitmap, valueOffsets,
        });
    }
    /**
     * Finalize this `Builder`, and child builders if applicable.
     * @returns {this} The finalized `Builder` instance.
     */
    finish() {
        this.finished = true;
        for (const child of this.children)
            child.finish();
        return this;
    }
    /**
     * Clear this Builder's internal state, including child Builders if applicable, and reset the length to 0.
     * @returns {this} The cleared `Builder` instance.
     */
    clear() {
        var _a, _b, _c, _d;
        this.length = 0;
        (_a = this._nulls) === null || _a === void 0 ? void 0 : _a.clear();
        (_b = this._values) === null || _b === void 0 ? void 0 : _b.clear();
        (_c = this._offsets) === null || _c === void 0 ? void 0 : _c.clear();
        (_d = this._typeIds) === null || _d === void 0 ? void 0 : _d.clear();
        for (const child of this.children)
            child.clear();
        return this;
    }
}
exports.Builder = Builder;
Builder.prototype.length = 1;
Builder.prototype.stride = 1;
Builder.prototype.children = null;
Builder.prototype.finished = false;
Builder.prototype.nullValues = null;
Builder.prototype._isValid = () => true;
/** @ignore */
class FixedWidthBuilder extends Builder {
    constructor(opts) {
        super(opts);
        this._values = new buffer_js_1.DataBufferBuilder(this.ArrayType, 0, this.stride);
    }
    setValue(index, value) {
        const values = this._values;
        values.reserve(index - values.length + 1);
        return super.setValue(index, value);
    }
}
exports.FixedWidthBuilder = FixedWidthBuilder;
/** @ignore */
class VariableWidthBuilder extends Builder {
    constructor(opts) {
        super(opts);
        this._pendingLength = 0;
        this._offsets = new buffer_js_1.OffsetsBufferBuilder(opts.type);
    }
    setValue(index, value) {
        const pending = this._pending || (this._pending = new Map());
        const current = pending.get(index);
        current && (this._pendingLength -= current.length);
        this._pendingLength += (value instanceof map_js_1.MapRow) ? value[map_js_1.kKeys].length : value.length;
        pending.set(index, value);
    }
    setValid(index, isValid) {
        if (!super.setValid(index, isValid)) {
            (this._pending || (this._pending = new Map())).set(index, undefined);
            return false;
        }
        return true;
    }
    clear() {
        this._pendingLength = 0;
        this._pending = undefined;
        return super.clear();
    }
    flush() {
        this._flush();
        return super.flush();
    }
    finish() {
        this._flush();
        return super.finish();
    }
    _flush() {
        const pending = this._pending;
        const pendingLength = this._pendingLength;
        this._pendingLength = 0;
        this._pending = undefined;
        if (pending && pending.size > 0) {
            this._flushPending(pending, pendingLength);
        }
        return this;
    }
}
exports.VariableWidthBuilder = VariableWidthBuilder;

//# sourceMappingURL=builder.js.map


/***/ }),
/* 47 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.makeVector = exports.Vector = void 0;
const enum_js_1 = __webpack_require__(48);
const vector_js_1 = __webpack_require__(106);
const type_js_1 = __webpack_require__(113);
const data_js_1 = __webpack_require__(117);
const chunk_js_1 = __webpack_require__(119);
const get_js_1 = __webpack_require__(109);
const set_js_1 = __webpack_require__(115);
const indexof_js_1 = __webpack_require__(120);
const iterator_js_1 = __webpack_require__(121);
const visitorsByTypeId = {};
const vectorPrototypesByTypeId = {};
/**
 * Array-like data structure. Use the convenience method {@link makeVector} and {@link vectorFromArray} to create vectors.
 */
class Vector {
    constructor(input) {
        var _b, _c, _d;
        const data = input[0] instanceof Vector
            ? input.flatMap(x => x.data)
            : input;
        if (data.length === 0 || data.some((x) => !(x instanceof data_js_1.Data))) {
            throw new TypeError('Vector constructor expects an Array of Data instances.');
        }
        const type = (_b = data[0]) === null || _b === void 0 ? void 0 : _b.type;
        switch (data.length) {
            case 0:
                this._offsets = [0];
                break;
            case 1: {
                // special case for unchunked vectors
                const { get, set, indexOf } = visitorsByTypeId[type.typeId];
                const unchunkedData = data[0];
                this.isValid = (index) => (0, chunk_js_1.isChunkedValid)(unchunkedData, index);
                this.get = (index) => get(unchunkedData, index);
                this.set = (index, value) => set(unchunkedData, index, value);
                this.indexOf = (index) => indexOf(unchunkedData, index);
                this._offsets = [0, unchunkedData.length];
                break;
            }
            default:
                Object.setPrototypeOf(this, vectorPrototypesByTypeId[type.typeId]);
                this._offsets = (0, chunk_js_1.computeChunkOffsets)(data);
                break;
        }
        this.data = data;
        this.type = type;
        this.stride = (0, type_js_1.strideForType)(type);
        this.numChildren = (_d = (_c = type.children) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0;
        this.length = this._offsets.at(-1);
    }
    /**
     * The aggregate size (in bytes) of this Vector's buffers and/or child Vectors.
     */
    get byteLength() {
        return this.data.reduce((byteLength, data) => byteLength + data.byteLength, 0);
    }
    /**
     * Whether this Vector's elements can contain null values.
     */
    get nullable() {
        return (0, chunk_js_1.computeChunkNullable)(this.data);
    }
    /**
     * The number of null elements in this Vector.
     */
    get nullCount() {
        return (0, chunk_js_1.computeChunkNullCounts)(this.data);
    }
    /**
     * The Array or TypedArray constructor used for the JS representation
     *  of the element's values in {@link Vector.prototype.toArray `toArray()`}.
     */
    get ArrayType() { return this.type.ArrayType; }
    /**
     * The name that should be printed when the Vector is logged in a message.
     */
    get [Symbol.toStringTag]() {
        return `${this.VectorName}<${this.type[Symbol.toStringTag]}>`;
    }
    /**
     * The name of this Vector.
     */
    get VectorName() { return `${enum_js_1.Type[this.type.typeId]}Vector`; }
    /**
     * Check whether an element is null.
     * @param index The index at which to read the validity bitmap.
     */
    // @ts-ignore
    isValid(index) { return false; }
    /**
     * Get an element value by position.
     * @param index The index of the element to read.
     */
    // @ts-ignore
    get(index) { return null; }
    /**
     * Get an element value by position.
     * @param index The index of the element to read. A negative index will count back from the last element.
     */
    at(index) {
        return this.get((0, vector_js_1.wrapIndex)(index, this.length));
    }
    /**
     * Set an element value by position.
     * @param index The index of the element to write.
     * @param value The value to set.
     */
    // @ts-ignore
    set(index, value) { return; }
    /**
     * Retrieve the index of the first occurrence of a value in an Vector.
     * @param element The value to locate in the Vector.
     * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
     */
    // @ts-ignore
    indexOf(element, offset) { return -1; }
    includes(element, offset) {
        // eslint-disable-next-line unicorn/prefer-includes
        return this.indexOf(element, offset) > -1;
    }
    /**
     * Iterator for the Vector's elements.
     */
    [Symbol.iterator]() {
        return iterator_js_1.instance.visit(this);
    }
    /**
     * Combines two or more Vectors of the same type.
     * @param others Additional Vectors to add to the end of this Vector.
     */
    concat(...others) {
        return new Vector(this.data.concat(others.flatMap((x) => x.data).flat(Number.POSITIVE_INFINITY)));
    }
    /**
     * Return a zero-copy sub-section of this Vector.
     * @param start The beginning of the specified portion of the Vector.
     * @param end The end of the specified portion of the Vector. This is exclusive of the element at the index 'end'.
     */
    slice(begin, end) {
        return new Vector((0, vector_js_1.clampRange)(this, begin, end, ({ data, _offsets }, begin, end) => (0, chunk_js_1.sliceChunks)(data, _offsets, begin, end)));
    }
    toJSON() { return [...this]; }
    /**
     * Return a JavaScript Array or TypedArray of the Vector's elements.
     *
     * @note If this Vector contains a single Data chunk and the Vector's type is a
     *  primitive numeric type corresponding to one of the JavaScript TypedArrays, this
     *  method returns a zero-copy slice of the underlying TypedArray values. If there's
     *  more than one chunk, the resulting TypedArray will be a copy of the data from each
     *  chunk's underlying TypedArray values.
     *
     * @returns An Array or TypedArray of the Vector's elements, based on the Vector's DataType.
     */
    toArray() {
        const { type, data, length, stride, ArrayType } = this;
        // Fast case, return subarray if possible
        switch (type.typeId) {
            case enum_js_1.Type.Int:
            case enum_js_1.Type.Float:
            case enum_js_1.Type.Decimal:
            case enum_js_1.Type.Time:
            case enum_js_1.Type.Timestamp:
                switch (data.length) {
                    case 0: return new ArrayType();
                    case 1: return data[0].values.subarray(0, length * stride);
                    default: return data.reduce((memo, { values, length: chunk_length }) => {
                        memo.array.set(values.subarray(0, chunk_length * stride), memo.offset);
                        memo.offset += chunk_length * stride;
                        return memo;
                    }, { array: new ArrayType(length * stride), offset: 0 }).array;
                }
        }
        // Otherwise if not primitive, slow copy
        return [...this];
    }
    /**
     * Returns a string representation of the Vector.
     *
     * @returns A string representation of the Vector.
     */
    toString() {
        return `[${[...this].join(',')}]`;
    }
    /**
     * Returns a child Vector by name, or null if this Vector has no child with the given name.
     * @param name The name of the child to retrieve.
     */
    getChild(name) {
        var _b;
        return this.getChildAt((_b = this.type.children) === null || _b === void 0 ? void 0 : _b.findIndex((f) => f.name === name));
    }
    /**
     * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
     * @param index The index of the child to retrieve.
     */
    getChildAt(index) {
        if (index > -1 && index < this.numChildren) {
            return new Vector(this.data.map(({ children }) => children[index]));
        }
        return null;
    }
    get isMemoized() {
        if (type_js_1.DataType.isDictionary(this.type)) {
            return this.data[0].dictionary.isMemoized;
        }
        return false;
    }
    /**
     * Adds memoization to the Vector's {@link get} method. For dictionary
     * vectors, this method return a vector that memoizes only the dictionary
     * values.
     *
     * Memoization is very useful when decoding a value is expensive such as
     * Utf8. The memoization creates a cache of the size of the Vector and
     * therefore increases memory usage.
     *
     * @returns A new vector that memoizes calls to {@link get}.
     */
    memoize() {
        if (type_js_1.DataType.isDictionary(this.type)) {
            const dictionary = new MemoizedVector(this.data[0].dictionary);
            const newData = this.data.map((data) => {
                const cloned = data.clone();
                cloned.dictionary = dictionary;
                return cloned;
            });
            return new Vector(newData);
        }
        return new MemoizedVector(this);
    }
    /**
     * Returns a vector without memoization of the {@link get} method. If this
     * vector is not memoized, this method returns this vector.
     *
     * @returns A new vector without memoization.
     */
    unmemoize() {
        if (type_js_1.DataType.isDictionary(this.type) && this.isMemoized) {
            const dictionary = this.data[0].dictionary.unmemoize();
            const newData = this.data.map((data) => {
                const newData = data.clone();
                newData.dictionary = dictionary;
                return newData;
            });
            return new Vector(newData);
        }
        return this;
    }
}
exports.Vector = Vector;
_a = Symbol.toStringTag;
// Initialize this static property via an IIFE so bundlers don't tree-shake
// out this logic, but also so we're still compliant with `"sideEffects": false`
Vector[_a] = ((proto) => {
    proto.type = type_js_1.DataType.prototype;
    proto.data = [];
    proto.length = 0;
    proto.stride = 1;
    proto.numChildren = 0;
    proto._offsets = new Uint32Array([0]);
    proto[Symbol.isConcatSpreadable] = true;
    const typeIds = Object.keys(enum_js_1.Type)
        .map((T) => enum_js_1.Type[T])
        .filter((T) => typeof T === 'number' && T !== enum_js_1.Type.NONE);
    for (const typeId of typeIds) {
        const get = get_js_1.instance.getVisitFnByTypeId(typeId);
        const set = set_js_1.instance.getVisitFnByTypeId(typeId);
        const indexOf = indexof_js_1.instance.getVisitFnByTypeId(typeId);
        visitorsByTypeId[typeId] = { get, set, indexOf };
        vectorPrototypesByTypeId[typeId] = Object.create(proto, {
            ['isValid']: { value: (0, chunk_js_1.wrapChunkedCall1)(chunk_js_1.isChunkedValid) },
            ['get']: { value: (0, chunk_js_1.wrapChunkedCall1)(get_js_1.instance.getVisitFnByTypeId(typeId)) },
            ['set']: { value: (0, chunk_js_1.wrapChunkedCall2)(set_js_1.instance.getVisitFnByTypeId(typeId)) },
            ['indexOf']: { value: (0, chunk_js_1.wrapChunkedIndexOf)(indexof_js_1.instance.getVisitFnByTypeId(typeId)) },
        });
    }
    return 'Vector';
})(Vector.prototype);
class MemoizedVector extends Vector {
    constructor(vector) {
        super(vector.data);
        const get = this.get;
        const set = this.set;
        const slice = this.slice;
        const cache = new Array(this.length);
        Object.defineProperty(this, 'get', {
            value(index) {
                const cachedValue = cache[index];
                if (cachedValue !== undefined) {
                    return cachedValue;
                }
                const value = get.call(this, index);
                cache[index] = value;
                return value;
            }
        });
        Object.defineProperty(this, 'set', {
            value(index, value) {
                set.call(this, index, value);
                cache[index] = value;
            }
        });
        Object.defineProperty(this, 'slice', {
            value: (begin, end) => new MemoizedVector(slice.call(this, begin, end))
        });
        Object.defineProperty(this, 'isMemoized', { value: true });
        Object.defineProperty(this, 'unmemoize', {
            value: () => new Vector(this.data)
        });
        Object.defineProperty(this, 'memoize', {
            value: () => this
        });
    }
}
const dtypes = __webpack_require__(113);
function makeVector(init) {
    if (init) {
        if (init instanceof data_js_1.Data) {
            return new Vector([init]);
        }
        if (init instanceof Vector) {
            return new Vector(init.data);
        }
        if (init.type instanceof type_js_1.DataType) {
            return new Vector([(0, data_js_1.makeData)(init)]);
        }
        if (Array.isArray(init)) {
            return new Vector(init.flatMap(v => unwrapInputs(v)));
        }
        if (ArrayBuffer.isView(init)) {
            if (init instanceof DataView) {
                init = new Uint8Array(init.buffer);
            }
            const props = { offset: 0, length: init.length, nullCount: -1, data: init };
            if (init instanceof Int8Array) {
                return new Vector([(0, data_js_1.makeData)(Object.assign(Object.assign({}, props), { type: new dtypes.Int8 }))]);
            }
            if (init instanceof Int16Array) {
                return new Vector([(0, data_js_1.makeData)(Object.assign(Object.assign({}, props), { type: new dtypes.Int16 }))]);
            }
            if (init instanceof Int32Array) {
                return new Vector([(0, data_js_1.makeData)(Object.assign(Object.assign({}, props), { type: new dtypes.Int32 }))]);
            }
            if (init instanceof BigInt64Array) {
                return new Vector([(0, data_js_1.makeData)(Object.assign(Object.assign({}, props), { type: new dtypes.Int64 }))]);
            }
            if (init instanceof Uint8Array || init instanceof Uint8ClampedArray) {
                return new Vector([(0, data_js_1.makeData)(Object.assign(Object.assign({}, props), { type: new dtypes.Uint8 }))]);
            }
            if (init instanceof Uint16Array) {
                return new Vector([(0, data_js_1.makeData)(Object.assign(Object.assign({}, props), { type: new dtypes.Uint16 }))]);
            }
            if (init instanceof Uint32Array) {
                return new Vector([(0, data_js_1.makeData)(Object.assign(Object.assign({}, props), { type: new dtypes.Uint32 }))]);
            }
            if (init instanceof BigUint64Array) {
                return new Vector([(0, data_js_1.makeData)(Object.assign(Object.assign({}, props), { type: new dtypes.Uint64 }))]);
            }
            if (init instanceof Float32Array) {
                return new Vector([(0, data_js_1.makeData)(Object.assign(Object.assign({}, props), { type: new dtypes.Float32 }))]);
            }
            if (init instanceof Float64Array) {
                return new Vector([(0, data_js_1.makeData)(Object.assign(Object.assign({}, props), { type: new dtypes.Float64 }))]);
            }
            throw new Error('Unrecognized input');
        }
    }
    throw new Error('Unrecognized input');
}
exports.makeVector = makeVector;
function unwrapInputs(x) {
    return x instanceof data_js_1.Data ? [x] : (x instanceof Vector ? x.data : makeVector(x).data);
}

//# sourceMappingURL=vector.js.map


/***/ }),
/* 48 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BufferType = exports.Type = exports.MessageHeader = exports.IntervalUnit = exports.TimeUnit = exports.DateUnit = exports.Precision = exports.UnionMode = exports.MetadataVersion = void 0;
var metadata_version_js_1 = __webpack_require__(49);
Object.defineProperty(exports, "MetadataVersion", ({ enumerable: true, get: function () { return metadata_version_js_1.MetadataVersion; } }));
var union_mode_js_1 = __webpack_require__(50);
Object.defineProperty(exports, "UnionMode", ({ enumerable: true, get: function () { return union_mode_js_1.UnionMode; } }));
var precision_js_1 = __webpack_require__(51);
Object.defineProperty(exports, "Precision", ({ enumerable: true, get: function () { return precision_js_1.Precision; } }));
var date_unit_js_1 = __webpack_require__(52);
Object.defineProperty(exports, "DateUnit", ({ enumerable: true, get: function () { return date_unit_js_1.DateUnit; } }));
var time_unit_js_1 = __webpack_require__(53);
Object.defineProperty(exports, "TimeUnit", ({ enumerable: true, get: function () { return time_unit_js_1.TimeUnit; } }));
var interval_unit_js_1 = __webpack_require__(54);
Object.defineProperty(exports, "IntervalUnit", ({ enumerable: true, get: function () { return interval_unit_js_1.IntervalUnit; } }));
var message_header_js_1 = __webpack_require__(55);
Object.defineProperty(exports, "MessageHeader", ({ enumerable: true, get: function () { return message_header_js_1.MessageHeader; } }));
/**
 * Main data type enumeration.
 *
 * Data types in this library are all *logical*. They can be expressed as
 * either a primitive physical type (bytes or bits of some fixed size), a
 * nested type consisting of other data types, or another data type (e.g. a
 * timestamp encoded as an int64).
 *
 * **Note**: Only non-negative enum values are written to an Arrow IPC payload.
 *
 * The rest of the values are specified here so TypeScript can narrow the type
 * signatures further beyond the base Arrow Types. The Arrow DataTypes include
 * metadata like `bitWidth` that impact the type signatures of the values we
 * accept and return.
 *
 * For example, the `Int8Vector` reads 1-byte numbers from an `Int8Array`, an
 * `Int32Vector` reads a 4-byte number from an `Int32Array`, and an `Int64Vector`
 * reads a pair of 4-byte lo, hi 32-bit integers as a zero-copy slice from the
 * underlying `Int32Array`.
 *
 * Library consumers benefit by knowing the narrowest type, since we can ensure
 * the types across all public methods are propagated, and never bail to `any`.
 * These values are _never_ used at runtime, and they will _never_ be written
 * to the flatbuffers metadata of serialized Arrow IPC payloads.
 */
var Type;
(function (Type) {
    Type[Type["NONE"] = 0] = "NONE";
    Type[Type["Null"] = 1] = "Null";
    Type[Type["Int"] = 2] = "Int";
    Type[Type["Float"] = 3] = "Float";
    Type[Type["Binary"] = 4] = "Binary";
    Type[Type["Utf8"] = 5] = "Utf8";
    Type[Type["Bool"] = 6] = "Bool";
    Type[Type["Decimal"] = 7] = "Decimal";
    Type[Type["Date"] = 8] = "Date";
    Type[Type["Time"] = 9] = "Time";
    Type[Type["Timestamp"] = 10] = "Timestamp";
    Type[Type["Interval"] = 11] = "Interval";
    Type[Type["List"] = 12] = "List";
    Type[Type["Struct"] = 13] = "Struct";
    Type[Type["Union"] = 14] = "Union";
    Type[Type["FixedSizeBinary"] = 15] = "FixedSizeBinary";
    Type[Type["FixedSizeList"] = 16] = "FixedSizeList";
    Type[Type["Map"] = 17] = "Map";
    Type[Type["Duration"] = 18] = "Duration";
    Type[Type["LargeBinary"] = 19] = "LargeBinary";
    Type[Type["LargeUtf8"] = 20] = "LargeUtf8";
    Type[Type["Dictionary"] = -1] = "Dictionary";
    Type[Type["Int8"] = -2] = "Int8";
    Type[Type["Int16"] = -3] = "Int16";
    Type[Type["Int32"] = -4] = "Int32";
    Type[Type["Int64"] = -5] = "Int64";
    Type[Type["Uint8"] = -6] = "Uint8";
    Type[Type["Uint16"] = -7] = "Uint16";
    Type[Type["Uint32"] = -8] = "Uint32";
    Type[Type["Uint64"] = -9] = "Uint64";
    Type[Type["Float16"] = -10] = "Float16";
    Type[Type["Float32"] = -11] = "Float32";
    Type[Type["Float64"] = -12] = "Float64";
    Type[Type["DateDay"] = -13] = "DateDay";
    Type[Type["DateMillisecond"] = -14] = "DateMillisecond";
    Type[Type["TimestampSecond"] = -15] = "TimestampSecond";
    Type[Type["TimestampMillisecond"] = -16] = "TimestampMillisecond";
    Type[Type["TimestampMicrosecond"] = -17] = "TimestampMicrosecond";
    Type[Type["TimestampNanosecond"] = -18] = "TimestampNanosecond";
    Type[Type["TimeSecond"] = -19] = "TimeSecond";
    Type[Type["TimeMillisecond"] = -20] = "TimeMillisecond";
    Type[Type["TimeMicrosecond"] = -21] = "TimeMicrosecond";
    Type[Type["TimeNanosecond"] = -22] = "TimeNanosecond";
    Type[Type["DenseUnion"] = -23] = "DenseUnion";
    Type[Type["SparseUnion"] = -24] = "SparseUnion";
    Type[Type["IntervalDayTime"] = -25] = "IntervalDayTime";
    Type[Type["IntervalYearMonth"] = -26] = "IntervalYearMonth";
    Type[Type["DurationSecond"] = -27] = "DurationSecond";
    Type[Type["DurationMillisecond"] = -28] = "DurationMillisecond";
    Type[Type["DurationMicrosecond"] = -29] = "DurationMicrosecond";
    Type[Type["DurationNanosecond"] = -30] = "DurationNanosecond";
})(Type || (exports.Type = Type = {}));
var BufferType;
(function (BufferType) {
    /**
     * used in List type, Dense Union and variable length primitive types (String, Binary)
     */
    BufferType[BufferType["OFFSET"] = 0] = "OFFSET";
    /**
     * actual data, either fixed width primitive types in slots or variable width delimited by an OFFSET vector
     */
    BufferType[BufferType["DATA"] = 1] = "DATA";
    /**
     * Bit vector indicating if each value is null
     */
    BufferType[BufferType["VALIDITY"] = 2] = "VALIDITY";
    /**
     * Type vector used in Union type
     */
    BufferType[BufferType["TYPE"] = 3] = "TYPE";
})(BufferType || (exports.BufferType = BufferType = {}));

//# sourceMappingURL=enum.js.map


/***/ }),
/* 49 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetadataVersion = void 0;
/**
 * Logical types, vector layouts, and schemas
 * Format Version History.
 * Version 1.0 - Forward and backwards compatibility guaranteed.
 * Version 1.1 - Add Decimal256.
 * Version 1.2 - Add Interval MONTH_DAY_NANO.
 * Version 1.3 - Add Run-End Encoded.
 */
var MetadataVersion;
(function (MetadataVersion) {
    /**
     * 0.1.0 (October 2016).
     */
    MetadataVersion[MetadataVersion["V1"] = 0] = "V1";
    /**
     * 0.2.0 (February 2017). Non-backwards compatible with V1.
     */
    MetadataVersion[MetadataVersion["V2"] = 1] = "V2";
    /**
     * 0.3.0 -> 0.7.1 (May - December 2017). Non-backwards compatible with V2.
     */
    MetadataVersion[MetadataVersion["V3"] = 2] = "V3";
    /**
     * >= 0.8.0 (December 2017). Non-backwards compatible with V3.
     */
    MetadataVersion[MetadataVersion["V4"] = 3] = "V4";
    /**
     * >= 1.0.0 (July 2020. Backwards compatible with V4 (V5 readers can read V4
     * metadata and IPC messages). Implementations are recommended to provide a
     * V4 compatibility mode with V5 format changes disabled.
     *
     * Incompatible changes between V4 and V5:
     * - Union buffer layout has changed. In V5, Unions don't have a validity
     *   bitmap buffer.
     */
    MetadataVersion[MetadataVersion["V5"] = 4] = "V5";
})(MetadataVersion || (exports.MetadataVersion = MetadataVersion = {}));

//# sourceMappingURL=metadata-version.js.map


/***/ }),
/* 50 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UnionMode = void 0;
var UnionMode;
(function (UnionMode) {
    UnionMode[UnionMode["Sparse"] = 0] = "Sparse";
    UnionMode[UnionMode["Dense"] = 1] = "Dense";
})(UnionMode || (exports.UnionMode = UnionMode = {}));

//# sourceMappingURL=union-mode.js.map


/***/ }),
/* 51 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Precision = void 0;
var Precision;
(function (Precision) {
    Precision[Precision["HALF"] = 0] = "HALF";
    Precision[Precision["SINGLE"] = 1] = "SINGLE";
    Precision[Precision["DOUBLE"] = 2] = "DOUBLE";
})(Precision || (exports.Precision = Precision = {}));

//# sourceMappingURL=precision.js.map


/***/ }),
/* 52 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DateUnit = void 0;
var DateUnit;
(function (DateUnit) {
    DateUnit[DateUnit["DAY"] = 0] = "DAY";
    DateUnit[DateUnit["MILLISECOND"] = 1] = "MILLISECOND";
})(DateUnit || (exports.DateUnit = DateUnit = {}));

//# sourceMappingURL=date-unit.js.map


/***/ }),
/* 53 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimeUnit = void 0;
var TimeUnit;
(function (TimeUnit) {
    TimeUnit[TimeUnit["SECOND"] = 0] = "SECOND";
    TimeUnit[TimeUnit["MILLISECOND"] = 1] = "MILLISECOND";
    TimeUnit[TimeUnit["MICROSECOND"] = 2] = "MICROSECOND";
    TimeUnit[TimeUnit["NANOSECOND"] = 3] = "NANOSECOND";
})(TimeUnit || (exports.TimeUnit = TimeUnit = {}));

//# sourceMappingURL=time-unit.js.map


/***/ }),
/* 54 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IntervalUnit = void 0;
var IntervalUnit;
(function (IntervalUnit) {
    IntervalUnit[IntervalUnit["YEAR_MONTH"] = 0] = "YEAR_MONTH";
    IntervalUnit[IntervalUnit["DAY_TIME"] = 1] = "DAY_TIME";
    IntervalUnit[IntervalUnit["MONTH_DAY_NANO"] = 2] = "MONTH_DAY_NANO";
})(IntervalUnit || (exports.IntervalUnit = IntervalUnit = {}));

//# sourceMappingURL=interval-unit.js.map


/***/ }),
/* 55 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unionListToMessageHeader = exports.unionToMessageHeader = exports.MessageHeader = void 0;
const dictionary_batch_js_1 = __webpack_require__(56);
const record_batch_js_1 = __webpack_require__(63);
const schema_js_1 = __webpack_require__(69);
const sparse_tensor_js_1 = __webpack_require__(98);
const tensor_js_1 = __webpack_require__(105);
/**
 * ----------------------------------------------------------------------
 * The root Message type
 * This union enables us to easily send different message types without
 * redundant storage, and in the future we can easily add new message types.
 *
 * Arrow implementations do not need to implement all of the message types,
 * which may include experimental metadata types. For maximum compatibility,
 * it is best to send data using RecordBatch
 */
var MessageHeader;
(function (MessageHeader) {
    MessageHeader[MessageHeader["NONE"] = 0] = "NONE";
    MessageHeader[MessageHeader["Schema"] = 1] = "Schema";
    MessageHeader[MessageHeader["DictionaryBatch"] = 2] = "DictionaryBatch";
    MessageHeader[MessageHeader["RecordBatch"] = 3] = "RecordBatch";
    MessageHeader[MessageHeader["Tensor"] = 4] = "Tensor";
    MessageHeader[MessageHeader["SparseTensor"] = 5] = "SparseTensor";
})(MessageHeader || (exports.MessageHeader = MessageHeader = {}));
function unionToMessageHeader(type, accessor) {
    switch (MessageHeader[type]) {
        case 'NONE': return null;
        case 'Schema': return accessor(new schema_js_1.Schema());
        case 'DictionaryBatch': return accessor(new dictionary_batch_js_1.DictionaryBatch());
        case 'RecordBatch': return accessor(new record_batch_js_1.RecordBatch());
        case 'Tensor': return accessor(new tensor_js_1.Tensor());
        case 'SparseTensor': return accessor(new sparse_tensor_js_1.SparseTensor());
        default: return null;
    }
}
exports.unionToMessageHeader = unionToMessageHeader;
function unionListToMessageHeader(type, accessor, index) {
    switch (MessageHeader[type]) {
        case 'NONE': return null;
        case 'Schema': return accessor(index, new schema_js_1.Schema());
        case 'DictionaryBatch': return accessor(index, new dictionary_batch_js_1.DictionaryBatch());
        case 'RecordBatch': return accessor(index, new record_batch_js_1.RecordBatch());
        case 'Tensor': return accessor(index, new tensor_js_1.Tensor());
        case 'SparseTensor': return accessor(index, new sparse_tensor_js_1.SparseTensor());
        default: return null;
    }
}
exports.unionListToMessageHeader = unionListToMessageHeader;

//# sourceMappingURL=message-header.js.map


/***/ }),
/* 56 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DictionaryBatch = void 0;
const flatbuffers = __webpack_require__(57);
const record_batch_js_1 = __webpack_require__(63);
/**
 * For sending dictionary encoding information. Any Field can be
 * dictionary-encoded, but in this case none of its children may be
 * dictionary-encoded.
 * There is one vector / column per dictionary, but that vector / column
 * may be spread across multiple dictionary batches by using the isDelta
 * flag
 */
class DictionaryBatch {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsDictionaryBatch(bb, obj) {
        return (obj || new DictionaryBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDictionaryBatch(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new DictionaryBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    id() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt('0');
    }
    data(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new record_batch_js_1.RecordBatch()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * If isDelta is true the values in the dictionary are to be appended to a
     * dictionary with the indicated id. If isDelta is false this dictionary
     * should replace the existing dictionary.
     */
    isDelta() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startDictionaryBatch(builder) {
        builder.startObject(3);
    }
    static addId(builder, id) {
        builder.addFieldInt64(0, id, BigInt('0'));
    }
    static addData(builder, dataOffset) {
        builder.addFieldOffset(1, dataOffset, 0);
    }
    static addIsDelta(builder, isDelta) {
        builder.addFieldInt8(2, +isDelta, +false);
    }
    static endDictionaryBatch(builder) {
        const offset = builder.endObject();
        return offset;
    }
}
exports.DictionaryBatch = DictionaryBatch;

//# sourceMappingURL=dictionary-batch.js.map


/***/ }),
/* 57 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Builder: () => (/* reexport safe */ _builder_js__WEBPACK_IMPORTED_MODULE_3__.Builder),
/* harmony export */   ByteBuffer: () => (/* reexport safe */ _byte_buffer_js__WEBPACK_IMPORTED_MODULE_4__.ByteBuffer),
/* harmony export */   Encoding: () => (/* reexport safe */ _encoding_js__WEBPACK_IMPORTED_MODULE_2__.Encoding),
/* harmony export */   FILE_IDENTIFIER_LENGTH: () => (/* reexport safe */ _constants_js__WEBPACK_IMPORTED_MODULE_0__.FILE_IDENTIFIER_LENGTH),
/* harmony export */   SIZEOF_INT: () => (/* reexport safe */ _constants_js__WEBPACK_IMPORTED_MODULE_0__.SIZEOF_INT),
/* harmony export */   SIZEOF_SHORT: () => (/* reexport safe */ _constants_js__WEBPACK_IMPORTED_MODULE_0__.SIZEOF_SHORT),
/* harmony export */   SIZE_PREFIX_LENGTH: () => (/* reexport safe */ _constants_js__WEBPACK_IMPORTED_MODULE_0__.SIZE_PREFIX_LENGTH),
/* harmony export */   float32: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_1__.float32),
/* harmony export */   float64: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_1__.float64),
/* harmony export */   int32: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_1__.int32),
/* harmony export */   isLittleEndian: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_1__.isLittleEndian)
/* harmony export */ });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(58);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(59);
/* harmony import */ var _encoding_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(60);
/* harmony import */ var _builder_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(61);
/* harmony import */ var _byte_buffer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(62);










/***/ }),
/* 58 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FILE_IDENTIFIER_LENGTH: () => (/* binding */ FILE_IDENTIFIER_LENGTH),
/* harmony export */   SIZEOF_INT: () => (/* binding */ SIZEOF_INT),
/* harmony export */   SIZEOF_SHORT: () => (/* binding */ SIZEOF_SHORT),
/* harmony export */   SIZE_PREFIX_LENGTH: () => (/* binding */ SIZE_PREFIX_LENGTH)
/* harmony export */ });
const SIZEOF_SHORT = 2;
const SIZEOF_INT = 4;
const FILE_IDENTIFIER_LENGTH = 4;
const SIZE_PREFIX_LENGTH = 4;


/***/ }),
/* 59 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   float32: () => (/* binding */ float32),
/* harmony export */   float64: () => (/* binding */ float64),
/* harmony export */   int32: () => (/* binding */ int32),
/* harmony export */   isLittleEndian: () => (/* binding */ isLittleEndian)
/* harmony export */ });
const int32 = new Int32Array(2);
const float32 = new Float32Array(int32.buffer);
const float64 = new Float64Array(int32.buffer);
const isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;


/***/ }),
/* 60 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Encoding: () => (/* binding */ Encoding)
/* harmony export */ });
var Encoding;
(function (Encoding) {
    Encoding[Encoding["UTF8_BYTES"] = 1] = "UTF8_BYTES";
    Encoding[Encoding["UTF16_STRING"] = 2] = "UTF16_STRING";
})(Encoding || (Encoding = {}));


/***/ }),
/* 61 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Builder: () => (/* binding */ Builder)
/* harmony export */ });
/* harmony import */ var _byte_buffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(62);
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(58);


class Builder {
    /**
     * Create a FlatBufferBuilder.
     */
    constructor(opt_initial_size) {
        /** Minimum alignment encountered so far. */
        this.minalign = 1;
        /** The vtable for the current table. */
        this.vtable = null;
        /** The amount of fields we're actually using. */
        this.vtable_in_use = 0;
        /** Whether we are currently serializing a table. */
        this.isNested = false;
        /** Starting offset of the current struct/table. */
        this.object_start = 0;
        /** List of offsets of all vtables. */
        this.vtables = [];
        /** For the current vector being built. */
        this.vector_num_elems = 0;
        /** False omits default values from the serialized data */
        this.force_defaults = false;
        this.string_maps = null;
        this.text_encoder = new TextEncoder();
        let initial_size;
        if (!opt_initial_size) {
            initial_size = 1024;
        }
        else {
            initial_size = opt_initial_size;
        }
        /**
         * @type {ByteBuffer}
         * @private
         */
        this.bb = _byte_buffer_js__WEBPACK_IMPORTED_MODULE_0__.ByteBuffer.allocate(initial_size);
        this.space = initial_size;
    }
    clear() {
        this.bb.clear();
        this.space = this.bb.capacity();
        this.minalign = 1;
        this.vtable = null;
        this.vtable_in_use = 0;
        this.isNested = false;
        this.object_start = 0;
        this.vtables = [];
        this.vector_num_elems = 0;
        this.force_defaults = false;
        this.string_maps = null;
    }
    /**
     * In order to save space, fields that are set to their default value
     * don't get serialized into the buffer. Forcing defaults provides a
     * way to manually disable this optimization.
     *
     * @param forceDefaults true always serializes default values
     */
    forceDefaults(forceDefaults) {
        this.force_defaults = forceDefaults;
    }
    /**
     * Get the ByteBuffer representing the FlatBuffer. Only call this after you've
     * called finish(). The actual data starts at the ByteBuffer's current position,
     * not necessarily at 0.
     */
    dataBuffer() {
        return this.bb;
    }
    /**
     * Get the bytes representing the FlatBuffer. Only call this after you've
     * called finish().
     */
    asUint8Array() {
        return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
    }
    /**
     * Prepare to write an element of `size` after `additional_bytes` have been
     * written, e.g. if you write a string, you need to align such the int length
     * field is aligned to 4 bytes, and the string data follows it directly. If all
     * you need to do is alignment, `additional_bytes` will be 0.
     *
     * @param size This is the of the new element to write
     * @param additional_bytes The padding size
     */
    prep(size, additional_bytes) {
        // Track the biggest thing we've ever aligned to.
        if (size > this.minalign) {
            this.minalign = size;
        }
        // Find the amount of alignment needed such that `size` is properly
        // aligned after `additional_bytes`
        const align_size = ((~(this.bb.capacity() - this.space + additional_bytes)) + 1) & (size - 1);
        // Reallocate the buffer if needed.
        while (this.space < align_size + size + additional_bytes) {
            const old_buf_size = this.bb.capacity();
            this.bb = Builder.growByteBuffer(this.bb);
            this.space += this.bb.capacity() - old_buf_size;
        }
        this.pad(align_size);
    }
    pad(byte_size) {
        for (let i = 0; i < byte_size; i++) {
            this.bb.writeInt8(--this.space, 0);
        }
    }
    writeInt8(value) {
        this.bb.writeInt8(this.space -= 1, value);
    }
    writeInt16(value) {
        this.bb.writeInt16(this.space -= 2, value);
    }
    writeInt32(value) {
        this.bb.writeInt32(this.space -= 4, value);
    }
    writeInt64(value) {
        this.bb.writeInt64(this.space -= 8, value);
    }
    writeFloat32(value) {
        this.bb.writeFloat32(this.space -= 4, value);
    }
    writeFloat64(value) {
        this.bb.writeFloat64(this.space -= 8, value);
    }
    /**
     * Add an `int8` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `int8` to add the buffer.
     */
    addInt8(value) {
        this.prep(1, 0);
        this.writeInt8(value);
    }
    /**
     * Add an `int16` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `int16` to add the buffer.
     */
    addInt16(value) {
        this.prep(2, 0);
        this.writeInt16(value);
    }
    /**
     * Add an `int32` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `int32` to add the buffer.
     */
    addInt32(value) {
        this.prep(4, 0);
        this.writeInt32(value);
    }
    /**
     * Add an `int64` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `int64` to add the buffer.
     */
    addInt64(value) {
        this.prep(8, 0);
        this.writeInt64(value);
    }
    /**
     * Add a `float32` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `float32` to add the buffer.
     */
    addFloat32(value) {
        this.prep(4, 0);
        this.writeFloat32(value);
    }
    /**
     * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `float64` to add the buffer.
     */
    addFloat64(value) {
        this.prep(8, 0);
        this.writeFloat64(value);
    }
    addFieldInt8(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
            this.addInt8(value);
            this.slot(voffset);
        }
    }
    addFieldInt16(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
            this.addInt16(value);
            this.slot(voffset);
        }
    }
    addFieldInt32(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
            this.addInt32(value);
            this.slot(voffset);
        }
    }
    addFieldInt64(voffset, value, defaultValue) {
        if (this.force_defaults || value !== defaultValue) {
            this.addInt64(value);
            this.slot(voffset);
        }
    }
    addFieldFloat32(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
            this.addFloat32(value);
            this.slot(voffset);
        }
    }
    addFieldFloat64(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
            this.addFloat64(value);
            this.slot(voffset);
        }
    }
    addFieldOffset(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
            this.addOffset(value);
            this.slot(voffset);
        }
    }
    /**
     * Structs are stored inline, so nothing additional is being added. `d` is always 0.
     */
    addFieldStruct(voffset, value, defaultValue) {
        if (value != defaultValue) {
            this.nested(value);
            this.slot(voffset);
        }
    }
    /**
     * Structures are always stored inline, they need to be created right
     * where they're used.  You'll get this assertion failure if you
     * created it elsewhere.
     */
    nested(obj) {
        if (obj != this.offset()) {
            throw new TypeError('FlatBuffers: struct must be serialized inline.');
        }
    }
    /**
     * Should not be creating any other object, string or vector
     * while an object is being constructed
     */
    notNested() {
        if (this.isNested) {
            throw new TypeError('FlatBuffers: object serialization must not be nested.');
        }
    }
    /**
     * Set the current vtable at `voffset` to the current location in the buffer.
     */
    slot(voffset) {
        if (this.vtable !== null)
            this.vtable[voffset] = this.offset();
    }
    /**
     * @returns Offset relative to the end of the buffer.
     */
    offset() {
        return this.bb.capacity() - this.space;
    }
    /**
     * Doubles the size of the backing ByteBuffer and copies the old data towards
     * the end of the new buffer (since we build the buffer backwards).
     *
     * @param bb The current buffer with the existing data
     * @returns A new byte buffer with the old data copied
     * to it. The data is located at the end of the buffer.
     *
     * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass
     * it a uint8Array we need to suppress the type check:
     * @suppress {checkTypes}
     */
    static growByteBuffer(bb) {
        const old_buf_size = bb.capacity();
        // Ensure we don't grow beyond what fits in an int.
        if (old_buf_size & 0xC0000000) {
            throw new Error('FlatBuffers: cannot grow buffer beyond 2 gigabytes.');
        }
        const new_buf_size = old_buf_size << 1;
        const nbb = _byte_buffer_js__WEBPACK_IMPORTED_MODULE_0__.ByteBuffer.allocate(new_buf_size);
        nbb.setPosition(new_buf_size - old_buf_size);
        nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);
        return nbb;
    }
    /**
     * Adds on offset, relative to where it will be written.
     *
     * @param offset The offset to add.
     */
    addOffset(offset) {
        this.prep(_constants_js__WEBPACK_IMPORTED_MODULE_1__.SIZEOF_INT, 0); // Ensure alignment is already done.
        this.writeInt32(this.offset() - offset + _constants_js__WEBPACK_IMPORTED_MODULE_1__.SIZEOF_INT);
    }
    /**
     * Start encoding a new object in the buffer.  Users will not usually need to
     * call this directly. The FlatBuffers compiler will generate helper methods
     * that call this method internally.
     */
    startObject(numfields) {
        this.notNested();
        if (this.vtable == null) {
            this.vtable = [];
        }
        this.vtable_in_use = numfields;
        for (let i = 0; i < numfields; i++) {
            this.vtable[i] = 0; // This will push additional elements as needed
        }
        this.isNested = true;
        this.object_start = this.offset();
    }
    /**
     * Finish off writing the object that is under construction.
     *
     * @returns The offset to the object inside `dataBuffer`
     */
    endObject() {
        if (this.vtable == null || !this.isNested) {
            throw new Error('FlatBuffers: endObject called without startObject');
        }
        this.addInt32(0);
        const vtableloc = this.offset();
        // Trim trailing zeroes.
        let i = this.vtable_in_use - 1;
        // eslint-disable-next-line no-empty
        for (; i >= 0 && this.vtable[i] == 0; i--) { }
        const trimmed_size = i + 1;
        // Write out the current vtable.
        for (; i >= 0; i--) {
            // Offset relative to the start of the table.
            this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);
        }
        const standard_fields = 2; // The fields below:
        this.addInt16(vtableloc - this.object_start);
        const len = (trimmed_size + standard_fields) * _constants_js__WEBPACK_IMPORTED_MODULE_1__.SIZEOF_SHORT;
        this.addInt16(len);
        // Search for an existing vtable that matches the current one.
        let existing_vtable = 0;
        const vt1 = this.space;
        outer_loop: for (i = 0; i < this.vtables.length; i++) {
            const vt2 = this.bb.capacity() - this.vtables[i];
            if (len == this.bb.readInt16(vt2)) {
                for (let j = _constants_js__WEBPACK_IMPORTED_MODULE_1__.SIZEOF_SHORT; j < len; j += _constants_js__WEBPACK_IMPORTED_MODULE_1__.SIZEOF_SHORT) {
                    if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {
                        continue outer_loop;
                    }
                }
                existing_vtable = this.vtables[i];
                break;
            }
        }
        if (existing_vtable) {
            // Found a match:
            // Remove the current vtable.
            this.space = this.bb.capacity() - vtableloc;
            // Point table to existing vtable.
            this.bb.writeInt32(this.space, existing_vtable - vtableloc);
        }
        else {
            // No match:
            // Add the location of the current vtable to the list of vtables.
            this.vtables.push(this.offset());
            // Point table to current vtable.
            this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);
        }
        this.isNested = false;
        return vtableloc;
    }
    /**
     * Finalize a buffer, poiting to the given `root_table`.
     */
    finish(root_table, opt_file_identifier, opt_size_prefix) {
        const size_prefix = opt_size_prefix ? _constants_js__WEBPACK_IMPORTED_MODULE_1__.SIZE_PREFIX_LENGTH : 0;
        if (opt_file_identifier) {
            const file_identifier = opt_file_identifier;
            this.prep(this.minalign, _constants_js__WEBPACK_IMPORTED_MODULE_1__.SIZEOF_INT +
                _constants_js__WEBPACK_IMPORTED_MODULE_1__.FILE_IDENTIFIER_LENGTH + size_prefix);
            if (file_identifier.length != _constants_js__WEBPACK_IMPORTED_MODULE_1__.FILE_IDENTIFIER_LENGTH) {
                throw new TypeError('FlatBuffers: file identifier must be length ' +
                    _constants_js__WEBPACK_IMPORTED_MODULE_1__.FILE_IDENTIFIER_LENGTH);
            }
            for (let i = _constants_js__WEBPACK_IMPORTED_MODULE_1__.FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {
                this.writeInt8(file_identifier.charCodeAt(i));
            }
        }
        this.prep(this.minalign, _constants_js__WEBPACK_IMPORTED_MODULE_1__.SIZEOF_INT + size_prefix);
        this.addOffset(root_table);
        if (size_prefix) {
            this.addInt32(this.bb.capacity() - this.space);
        }
        this.bb.setPosition(this.space);
    }
    /**
     * Finalize a size prefixed buffer, pointing to the given `root_table`.
     */
    finishSizePrefixed(root_table, opt_file_identifier) {
        this.finish(root_table, opt_file_identifier, true);
    }
    /**
     * This checks a required field has been set in a given table that has
     * just been constructed.
     */
    requiredField(table, field) {
        const table_start = this.bb.capacity() - table;
        const vtable_start = table_start - this.bb.readInt32(table_start);
        const ok = field < this.bb.readInt16(vtable_start) &&
            this.bb.readInt16(vtable_start + field) != 0;
        // If this fails, the caller will show what field needs to be set.
        if (!ok) {
            throw new TypeError('FlatBuffers: field ' + field + ' must be set');
        }
    }
    /**
     * Start a new array/vector of objects.  Users usually will not call
     * this directly. The FlatBuffers compiler will create a start/end
     * method for vector types in generated code.
     *
     * @param elem_size The size of each element in the array
     * @param num_elems The number of elements in the array
     * @param alignment The alignment of the array
     */
    startVector(elem_size, num_elems, alignment) {
        this.notNested();
        this.vector_num_elems = num_elems;
        this.prep(_constants_js__WEBPACK_IMPORTED_MODULE_1__.SIZEOF_INT, elem_size * num_elems);
        this.prep(alignment, elem_size * num_elems); // Just in case alignment > int.
    }
    /**
     * Finish off the creation of an array and all its elements. The array must be
     * created with `startVector`.
     *
     * @returns The offset at which the newly created array
     * starts.
     */
    endVector() {
        this.writeInt32(this.vector_num_elems);
        return this.offset();
    }
    /**
     * Encode the string `s` in the buffer using UTF-8. If the string passed has
     * already been seen, we return the offset of the already written string
     *
     * @param s The string to encode
     * @return The offset in the buffer where the encoded string starts
     */
    createSharedString(s) {
        if (!s) {
            return 0;
        }
        if (!this.string_maps) {
            this.string_maps = new Map();
        }
        if (this.string_maps.has(s)) {
            return this.string_maps.get(s);
        }
        const offset = this.createString(s);
        this.string_maps.set(s, offset);
        return offset;
    }
    /**
     * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed
     * instead of a string, it is assumed to contain valid UTF-8 encoded data.
     *
     * @param s The string to encode
     * @return The offset in the buffer where the encoded string starts
     */
    createString(s) {
        if (s === null || s === undefined) {
            return 0;
        }
        let utf8;
        if (s instanceof Uint8Array) {
            utf8 = s;
        }
        else {
            utf8 = this.text_encoder.encode(s);
        }
        this.addInt8(0);
        this.startVector(1, utf8.length, 1);
        this.bb.setPosition(this.space -= utf8.length);
        this.bb.bytes().set(utf8, this.space);
        return this.endVector();
    }
    /**
     * Create a byte vector.
     *
     * @param v The bytes to add
     * @returns The offset in the buffer where the byte vector starts
     */
    createByteVector(v) {
        if (v === null || v === undefined) {
            return 0;
        }
        this.startVector(1, v.length, 1);
        this.bb.setPosition(this.space -= v.length);
        this.bb.bytes().set(v, this.space);
        return this.endVector();
    }
    /**
     * A helper function to pack an object
     *
     * @returns offset of obj
     */
    createObjectOffset(obj) {
        if (obj === null) {
            return 0;
        }
        if (typeof obj === 'string') {
            return this.createString(obj);
        }
        else {
            return obj.pack(this);
        }
    }
    /**
     * A helper function to pack a list of object
     *
     * @returns list of offsets of each non null object
     */
    createObjectOffsetList(list) {
        const ret = [];
        for (let i = 0; i < list.length; ++i) {
            const val = list[i];
            if (val !== null) {
                ret.push(this.createObjectOffset(val));
            }
            else {
                throw new TypeError('FlatBuffers: Argument for createObjectOffsetList cannot contain null.');
            }
        }
        return ret;
    }
    createStructOffsetList(list, startFunc) {
        startFunc(this, list.length);
        this.createObjectOffsetList(list.slice().reverse());
        return this.endVector();
    }
}


/***/ }),
/* 62 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ByteBuffer: () => (/* binding */ ByteBuffer)
/* harmony export */ });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(58);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(59);
/* harmony import */ var _encoding_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(60);



class ByteBuffer {
    /**
     * Create a new ByteBuffer with a given array of bytes (`Uint8Array`)
     */
    constructor(bytes_) {
        this.bytes_ = bytes_;
        this.position_ = 0;
        this.text_decoder_ = new TextDecoder();
    }
    /**
     * Create and allocate a new ByteBuffer with a given size.
     */
    static allocate(byte_size) {
        return new ByteBuffer(new Uint8Array(byte_size));
    }
    clear() {
        this.position_ = 0;
    }
    /**
     * Get the underlying `Uint8Array`.
     */
    bytes() {
        return this.bytes_;
    }
    /**
     * Get the buffer's position.
     */
    position() {
        return this.position_;
    }
    /**
     * Set the buffer's position.
     */
    setPosition(position) {
        this.position_ = position;
    }
    /**
     * Get the buffer's capacity.
     */
    capacity() {
        return this.bytes_.length;
    }
    readInt8(offset) {
        return this.readUint8(offset) << 24 >> 24;
    }
    readUint8(offset) {
        return this.bytes_[offset];
    }
    readInt16(offset) {
        return this.readUint16(offset) << 16 >> 16;
    }
    readUint16(offset) {
        return this.bytes_[offset] | this.bytes_[offset + 1] << 8;
    }
    readInt32(offset) {
        return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;
    }
    readUint32(offset) {
        return this.readInt32(offset) >>> 0;
    }
    readInt64(offset) {
        return BigInt.asIntN(64, BigInt(this.readUint32(offset)) + (BigInt(this.readUint32(offset + 4)) << BigInt(32)));
    }
    readUint64(offset) {
        return BigInt.asUintN(64, BigInt(this.readUint32(offset)) + (BigInt(this.readUint32(offset + 4)) << BigInt(32)));
    }
    readFloat32(offset) {
        _utils_js__WEBPACK_IMPORTED_MODULE_1__.int32[0] = this.readInt32(offset);
        return _utils_js__WEBPACK_IMPORTED_MODULE_1__.float32[0];
    }
    readFloat64(offset) {
        _utils_js__WEBPACK_IMPORTED_MODULE_1__.int32[_utils_js__WEBPACK_IMPORTED_MODULE_1__.isLittleEndian ? 0 : 1] = this.readInt32(offset);
        _utils_js__WEBPACK_IMPORTED_MODULE_1__.int32[_utils_js__WEBPACK_IMPORTED_MODULE_1__.isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);
        return _utils_js__WEBPACK_IMPORTED_MODULE_1__.float64[0];
    }
    writeInt8(offset, value) {
        this.bytes_[offset] = value;
    }
    writeUint8(offset, value) {
        this.bytes_[offset] = value;
    }
    writeInt16(offset, value) {
        this.bytes_[offset] = value;
        this.bytes_[offset + 1] = value >> 8;
    }
    writeUint16(offset, value) {
        this.bytes_[offset] = value;
        this.bytes_[offset + 1] = value >> 8;
    }
    writeInt32(offset, value) {
        this.bytes_[offset] = value;
        this.bytes_[offset + 1] = value >> 8;
        this.bytes_[offset + 2] = value >> 16;
        this.bytes_[offset + 3] = value >> 24;
    }
    writeUint32(offset, value) {
        this.bytes_[offset] = value;
        this.bytes_[offset + 1] = value >> 8;
        this.bytes_[offset + 2] = value >> 16;
        this.bytes_[offset + 3] = value >> 24;
    }
    writeInt64(offset, value) {
        this.writeInt32(offset, Number(BigInt.asIntN(32, value)));
        this.writeInt32(offset + 4, Number(BigInt.asIntN(32, value >> BigInt(32))));
    }
    writeUint64(offset, value) {
        this.writeUint32(offset, Number(BigInt.asUintN(32, value)));
        this.writeUint32(offset + 4, Number(BigInt.asUintN(32, value >> BigInt(32))));
    }
    writeFloat32(offset, value) {
        _utils_js__WEBPACK_IMPORTED_MODULE_1__.float32[0] = value;
        this.writeInt32(offset, _utils_js__WEBPACK_IMPORTED_MODULE_1__.int32[0]);
    }
    writeFloat64(offset, value) {
        _utils_js__WEBPACK_IMPORTED_MODULE_1__.float64[0] = value;
        this.writeInt32(offset, _utils_js__WEBPACK_IMPORTED_MODULE_1__.int32[_utils_js__WEBPACK_IMPORTED_MODULE_1__.isLittleEndian ? 0 : 1]);
        this.writeInt32(offset + 4, _utils_js__WEBPACK_IMPORTED_MODULE_1__.int32[_utils_js__WEBPACK_IMPORTED_MODULE_1__.isLittleEndian ? 1 : 0]);
    }
    /**
     * Return the file identifier.   Behavior is undefined for FlatBuffers whose
     * schema does not include a file_identifier (likely points at padding or the
     * start of a the root vtable).
     */
    getBufferIdentifier() {
        if (this.bytes_.length < this.position_ + _constants_js__WEBPACK_IMPORTED_MODULE_0__.SIZEOF_INT +
            _constants_js__WEBPACK_IMPORTED_MODULE_0__.FILE_IDENTIFIER_LENGTH) {
            throw new Error('FlatBuffers: ByteBuffer is too short to contain an identifier.');
        }
        let result = "";
        for (let i = 0; i < _constants_js__WEBPACK_IMPORTED_MODULE_0__.FILE_IDENTIFIER_LENGTH; i++) {
            result += String.fromCharCode(this.readInt8(this.position_ + _constants_js__WEBPACK_IMPORTED_MODULE_0__.SIZEOF_INT + i));
        }
        return result;
    }
    /**
     * Look up a field in the vtable, return an offset into the object, or 0 if the
     * field is not present.
     */
    __offset(bb_pos, vtable_offset) {
        const vtable = bb_pos - this.readInt32(bb_pos);
        return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;
    }
    /**
     * Initialize any Table-derived type to point to the union at the given offset.
     */
    __union(t, offset) {
        t.bb_pos = offset + this.readInt32(offset);
        t.bb = this;
        return t;
    }
    /**
     * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.
     * This allocates a new string and converts to wide chars upon each access.
     *
     * To avoid the conversion to string, pass Encoding.UTF8_BYTES as the
     * "optionalEncoding" argument. This is useful for avoiding conversion when
     * the data will just be packaged back up in another FlatBuffer later on.
     *
     * @param offset
     * @param opt_encoding Defaults to UTF16_STRING
     */
    __string(offset, opt_encoding) {
        offset += this.readInt32(offset);
        const length = this.readInt32(offset);
        offset += _constants_js__WEBPACK_IMPORTED_MODULE_0__.SIZEOF_INT;
        const utf8bytes = this.bytes_.subarray(offset, offset + length);
        if (opt_encoding === _encoding_js__WEBPACK_IMPORTED_MODULE_2__.Encoding.UTF8_BYTES)
            return utf8bytes;
        else
            return this.text_decoder_.decode(utf8bytes);
    }
    /**
     * Handle unions that can contain string as its member, if a Table-derived type then initialize it,
     * if a string then return a new one
     *
     * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this
     * makes the behaviour of __union_with_string different compared to __union
     */
    __union_with_string(o, offset) {
        if (typeof o === 'string') {
            return this.__string(offset);
        }
        return this.__union(o, offset);
    }
    /**
     * Retrieve the relative offset stored at "offset"
     */
    __indirect(offset) {
        return offset + this.readInt32(offset);
    }
    /**
     * Get the start of data of a vector whose offset is stored at "offset" in this object.
     */
    __vector(offset) {
        return offset + this.readInt32(offset) + _constants_js__WEBPACK_IMPORTED_MODULE_0__.SIZEOF_INT; // data starts after the length
    }
    /**
     * Get the length of a vector whose offset is stored at "offset" in this object.
     */
    __vector_len(offset) {
        return this.readInt32(offset + this.readInt32(offset));
    }
    __has_identifier(ident) {
        if (ident.length != _constants_js__WEBPACK_IMPORTED_MODULE_0__.FILE_IDENTIFIER_LENGTH) {
            throw new Error('FlatBuffers: file identifier must be length ' +
                _constants_js__WEBPACK_IMPORTED_MODULE_0__.FILE_IDENTIFIER_LENGTH);
        }
        for (let i = 0; i < _constants_js__WEBPACK_IMPORTED_MODULE_0__.FILE_IDENTIFIER_LENGTH; i++) {
            if (ident.charCodeAt(i) != this.readInt8(this.position() + _constants_js__WEBPACK_IMPORTED_MODULE_0__.SIZEOF_INT + i)) {
                return false;
            }
        }
        return true;
    }
    /**
     * A helper function for generating list for obj api
     */
    createScalarList(listAccessor, listLength) {
        const ret = [];
        for (let i = 0; i < listLength; ++i) {
            const val = listAccessor(i);
            if (val !== null) {
                ret.push(val);
            }
        }
        return ret;
    }
    /**
     * A helper function for generating list for obj api
     * @param listAccessor function that accepts an index and return data at that index
     * @param listLength listLength
     * @param res result list
     */
    createObjList(listAccessor, listLength) {
        const ret = [];
        for (let i = 0; i < listLength; ++i) {
            const val = listAccessor(i);
            if (val !== null) {
                ret.push(val.unpack());
            }
        }
        return ret;
    }
}


/***/ }),
/* 63 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RecordBatch = void 0;
const flatbuffers = __webpack_require__(57);
const body_compression_js_1 = __webpack_require__(64);
const buffer_js_1 = __webpack_require__(67);
const field_node_js_1 = __webpack_require__(68);
/**
 * A data header describing the shared memory layout of a "record" or "row"
 * batch. Some systems call this a "row batch" internally and others a "record
 * batch".
 */
class RecordBatch {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsRecordBatch(bb, obj) {
        return (obj || new RecordBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsRecordBatch(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new RecordBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * number of records / rows. The arrays in the batch should all have this
     * length
     */
    length() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt('0');
    }
    /**
     * Nodes correspond to the pre-ordered flattened logical schema
     */
    nodes(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new field_node_js_1.FieldNode()).__init(this.bb.__vector(this.bb_pos + offset) + index * 16, this.bb) : null;
    }
    nodesLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * Buffers correspond to the pre-ordered flattened buffer tree
     *
     * The number of buffers appended to this list depends on the schema. For
     * example, most primitive arrays will have 2 buffers, 1 for the validity
     * bitmap and 1 for the values. For struct arrays, there will only be a
     * single buffer for the validity (nulls) bitmap
     */
    buffers(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new buffer_js_1.Buffer()).__init(this.bb.__vector(this.bb_pos + offset) + index * 16, this.bb) : null;
    }
    buffersLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * Optional compression of the message body
     */
    compression(obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new body_compression_js_1.BodyCompression()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static startRecordBatch(builder) {
        builder.startObject(4);
    }
    static addLength(builder, length) {
        builder.addFieldInt64(0, length, BigInt('0'));
    }
    static addNodes(builder, nodesOffset) {
        builder.addFieldOffset(1, nodesOffset, 0);
    }
    static startNodesVector(builder, numElems) {
        builder.startVector(16, numElems, 8);
    }
    static addBuffers(builder, buffersOffset) {
        builder.addFieldOffset(2, buffersOffset, 0);
    }
    static startBuffersVector(builder, numElems) {
        builder.startVector(16, numElems, 8);
    }
    static addCompression(builder, compressionOffset) {
        builder.addFieldOffset(3, compressionOffset, 0);
    }
    static endRecordBatch(builder) {
        const offset = builder.endObject();
        return offset;
    }
}
exports.RecordBatch = RecordBatch;

//# sourceMappingURL=record-batch.js.map


/***/ }),
/* 64 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BodyCompression = void 0;
const flatbuffers = __webpack_require__(57);
const body_compression_method_js_1 = __webpack_require__(65);
const compression_type_js_1 = __webpack_require__(66);
/**
 * Optional compression for the memory buffers constituting IPC message
 * bodies. Intended for use with RecordBatch but could be used for other
 * message types
 */
class BodyCompression {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsBodyCompression(bb, obj) {
        return (obj || new BodyCompression()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsBodyCompression(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new BodyCompression()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * Compressor library.
     * For LZ4_FRAME, each compressed buffer must consist of a single frame.
     */
    codec() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : compression_type_js_1.CompressionType.LZ4_FRAME;
    }
    /**
     * Indicates the way the record batch body was compressed
     */
    method() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : body_compression_method_js_1.BodyCompressionMethod.BUFFER;
    }
    static startBodyCompression(builder) {
        builder.startObject(2);
    }
    static addCodec(builder, codec) {
        builder.addFieldInt8(0, codec, compression_type_js_1.CompressionType.LZ4_FRAME);
    }
    static addMethod(builder, method) {
        builder.addFieldInt8(1, method, body_compression_method_js_1.BodyCompressionMethod.BUFFER);
    }
    static endBodyCompression(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createBodyCompression(builder, codec, method) {
        BodyCompression.startBodyCompression(builder);
        BodyCompression.addCodec(builder, codec);
        BodyCompression.addMethod(builder, method);
        return BodyCompression.endBodyCompression(builder);
    }
}
exports.BodyCompression = BodyCompression;

//# sourceMappingURL=body-compression.js.map


/***/ }),
/* 65 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BodyCompressionMethod = void 0;
/**
 * Provided for forward compatibility in case we need to support different
 * strategies for compressing the IPC message body (like whole-body
 * compression rather than buffer-level) in the future
 */
var BodyCompressionMethod;
(function (BodyCompressionMethod) {
    /**
     * Each constituent buffer is first compressed with the indicated
     * compressor, and then written with the uncompressed length in the first 8
     * bytes as a 64-bit little-endian signed integer followed by the compressed
     * buffer bytes (and then padding as required by the protocol). The
     * uncompressed length may be set to -1 to indicate that the data that
     * follows is not compressed, which can be useful for cases where
     * compression does not yield appreciable savings.
     */
    BodyCompressionMethod[BodyCompressionMethod["BUFFER"] = 0] = "BUFFER";
})(BodyCompressionMethod || (exports.BodyCompressionMethod = BodyCompressionMethod = {}));

//# sourceMappingURL=body-compression-method.js.map


/***/ }),
/* 66 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CompressionType = void 0;
var CompressionType;
(function (CompressionType) {
    CompressionType[CompressionType["LZ4_FRAME"] = 0] = "LZ4_FRAME";
    CompressionType[CompressionType["ZSTD"] = 1] = "ZSTD";
})(CompressionType || (exports.CompressionType = CompressionType = {}));

//# sourceMappingURL=compression-type.js.map


/***/ }),
/* 67 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Buffer = void 0;
/**
 * ----------------------------------------------------------------------
 * A Buffer represents a single contiguous memory segment
 */
class Buffer {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    /**
     * The relative offset into the shared memory page where the bytes for this
     * buffer starts
     */
    offset() {
        return this.bb.readInt64(this.bb_pos);
    }
    /**
     * The absolute length (in bytes) of the memory buffer. The memory is found
     * from offset (inclusive) to offset + length (non-inclusive). When building
     * messages using the encapsulated IPC message, padding bytes may be written
     * after a buffer, but such padding bytes do not need to be accounted for in
     * the size here.
     */
    length() {
        return this.bb.readInt64(this.bb_pos + 8);
    }
    static sizeOf() {
        return 16;
    }
    static createBuffer(builder, offset, length) {
        builder.prep(8, 16);
        builder.writeInt64(BigInt(length !== null && length !== void 0 ? length : 0));
        builder.writeInt64(BigInt(offset !== null && offset !== void 0 ? offset : 0));
        return builder.offset();
    }
}
exports.Buffer = Buffer;

//# sourceMappingURL=buffer.js.map


/***/ }),
/* 68 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FieldNode = void 0;
/**
 * ----------------------------------------------------------------------
 * Data structures for describing a table row batch (a collection of
 * equal-length Arrow arrays)
 * Metadata about a field at some level of a nested type tree (but not
 * its children).
 *
 * For example, a List<Int16> with values `[[1, 2, 3], null, [4], [5, 6], null]`
 * would have {length: 5, null_count: 2} for its List node, and {length: 6,
 * null_count: 0} for its Int16 node, as separate FieldNode structs
 */
class FieldNode {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    /**
     * The number of value slots in the Arrow array at this level of a nested
     * tree
     */
    length() {
        return this.bb.readInt64(this.bb_pos);
    }
    /**
     * The number of observed nulls. Fields with null_count == 0 may choose not
     * to write their physical validity bitmap out as a materialized buffer,
     * instead setting the length of the bitmap buffer to 0.
     */
    nullCount() {
        return this.bb.readInt64(this.bb_pos + 8);
    }
    static sizeOf() {
        return 16;
    }
    static createFieldNode(builder, length, null_count) {
        builder.prep(8, 16);
        builder.writeInt64(BigInt(null_count !== null && null_count !== void 0 ? null_count : 0));
        builder.writeInt64(BigInt(length !== null && length !== void 0 ? length : 0));
        return builder.offset();
    }
}
exports.FieldNode = FieldNode;

//# sourceMappingURL=field-node.js.map


/***/ }),
/* 69 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Schema = void 0;
const flatbuffers = __webpack_require__(57);
const endianness_js_1 = __webpack_require__(70);
const field_js_1 = __webpack_require__(71);
const key_value_js_1 = __webpack_require__(75);
/**
 * ----------------------------------------------------------------------
 * A Schema describes the columns in a row batch
 */
class Schema {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSchema(bb, obj) {
        return (obj || new Schema()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSchema(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Schema()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * endianness of the buffer
     * it is Little Endian by default
     * if endianness doesn't match the underlying system then the vectors need to be converted
     */
    endianness() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : endianness_js_1.Endianness.Little;
    }
    fields(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new field_js_1.Field()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    fieldsLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    customMetadata(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new key_value_js_1.KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    customMetadataLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * Features used in the stream/file.
     */
    features(index) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8) : BigInt(0);
    }
    featuresLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startSchema(builder) {
        builder.startObject(4);
    }
    static addEndianness(builder, endianness) {
        builder.addFieldInt16(0, endianness, endianness_js_1.Endianness.Little);
    }
    static addFields(builder, fieldsOffset) {
        builder.addFieldOffset(1, fieldsOffset, 0);
    }
    static createFieldsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startFieldsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addCustomMetadata(builder, customMetadataOffset) {
        builder.addFieldOffset(2, customMetadataOffset, 0);
    }
    static createCustomMetadataVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startCustomMetadataVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addFeatures(builder, featuresOffset) {
        builder.addFieldOffset(3, featuresOffset, 0);
    }
    static createFeaturesVector(builder, data) {
        builder.startVector(8, data.length, 8);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt64(data[i]);
        }
        return builder.endVector();
    }
    static startFeaturesVector(builder, numElems) {
        builder.startVector(8, numElems, 8);
    }
    static endSchema(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static finishSchemaBuffer(builder, offset) {
        builder.finish(offset);
    }
    static finishSizePrefixedSchemaBuffer(builder, offset) {
        builder.finish(offset, undefined, true);
    }
    static createSchema(builder, endianness, fieldsOffset, customMetadataOffset, featuresOffset) {
        Schema.startSchema(builder);
        Schema.addEndianness(builder, endianness);
        Schema.addFields(builder, fieldsOffset);
        Schema.addCustomMetadata(builder, customMetadataOffset);
        Schema.addFeatures(builder, featuresOffset);
        return Schema.endSchema(builder);
    }
}
exports.Schema = Schema;

//# sourceMappingURL=schema.js.map


/***/ }),
/* 70 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Endianness = void 0;
/**
 * ----------------------------------------------------------------------
 * Endianness of the platform producing the data
 */
var Endianness;
(function (Endianness) {
    Endianness[Endianness["Little"] = 0] = "Little";
    Endianness[Endianness["Big"] = 1] = "Big";
})(Endianness || (exports.Endianness = Endianness = {}));

//# sourceMappingURL=endianness.js.map


/***/ }),
/* 71 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Field = void 0;
const flatbuffers = __webpack_require__(57);
const dictionary_encoding_js_1 = __webpack_require__(72);
const key_value_js_1 = __webpack_require__(75);
const type_js_1 = __webpack_require__(76);
/**
 * ----------------------------------------------------------------------
 * A field represents a named column in a record / row batch or child of a
 * nested type.
 */
class Field {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsField(bb, obj) {
        return (obj || new Field()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsField(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Field()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    name(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Whether or not this field can contain nulls. Should be true in general.
     */
    nullable() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    typeType() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : type_js_1.Type.NONE;
    }
    /**
     * This is the type of the decoded value if the field is dictionary encoded.
     */
    type(obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    /**
     * Present only if the field is dictionary encoded.
     */
    dictionary(obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? (obj || new dictionary_encoding_js_1.DictionaryEncoding()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * children apply only to nested data types like Struct, List and Union. For
     * primitive types children will have length 0.
     */
    children(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? (obj || new Field()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    childrenLength() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * User-defined metadata
     */
    customMetadata(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? (obj || new key_value_js_1.KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    customMetadataLength() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startField(builder) {
        builder.startObject(7);
    }
    static addName(builder, nameOffset) {
        builder.addFieldOffset(0, nameOffset, 0);
    }
    static addNullable(builder, nullable) {
        builder.addFieldInt8(1, +nullable, +false);
    }
    static addTypeType(builder, typeType) {
        builder.addFieldInt8(2, typeType, type_js_1.Type.NONE);
    }
    static addType(builder, typeOffset) {
        builder.addFieldOffset(3, typeOffset, 0);
    }
    static addDictionary(builder, dictionaryOffset) {
        builder.addFieldOffset(4, dictionaryOffset, 0);
    }
    static addChildren(builder, childrenOffset) {
        builder.addFieldOffset(5, childrenOffset, 0);
    }
    static createChildrenVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startChildrenVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addCustomMetadata(builder, customMetadataOffset) {
        builder.addFieldOffset(6, customMetadataOffset, 0);
    }
    static createCustomMetadataVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startCustomMetadataVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endField(builder) {
        const offset = builder.endObject();
        return offset;
    }
}
exports.Field = Field;

//# sourceMappingURL=field.js.map


/***/ }),
/* 72 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DictionaryEncoding = void 0;
const flatbuffers = __webpack_require__(57);
const dictionary_kind_js_1 = __webpack_require__(73);
const int_js_1 = __webpack_require__(74);
class DictionaryEncoding {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsDictionaryEncoding(bb, obj) {
        return (obj || new DictionaryEncoding()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDictionaryEncoding(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new DictionaryEncoding()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * The known dictionary id in the application where this data is used. In
     * the file or streaming formats, the dictionary ids are found in the
     * DictionaryBatch messages
     */
    id() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt('0');
    }
    /**
     * The dictionary indices are constrained to be non-negative integers. If
     * this field is null, the indices must be signed int32. To maximize
     * cross-language compatibility and performance, implementations are
     * recommended to prefer signed integer types over unsigned integer types
     * and to avoid uint64 indices unless they are required by an application.
     */
    indexType(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new int_js_1.Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * By default, dictionaries are not ordered, or the order does not have
     * semantic meaning. In some statistical, applications, dictionary-encoding
     * is used to represent ordered categorical data, and we provide a way to
     * preserve that metadata here
     */
    isOrdered() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    dictionaryKind() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : dictionary_kind_js_1.DictionaryKind.DenseArray;
    }
    static startDictionaryEncoding(builder) {
        builder.startObject(4);
    }
    static addId(builder, id) {
        builder.addFieldInt64(0, id, BigInt('0'));
    }
    static addIndexType(builder, indexTypeOffset) {
        builder.addFieldOffset(1, indexTypeOffset, 0);
    }
    static addIsOrdered(builder, isOrdered) {
        builder.addFieldInt8(2, +isOrdered, +false);
    }
    static addDictionaryKind(builder, dictionaryKind) {
        builder.addFieldInt16(3, dictionaryKind, dictionary_kind_js_1.DictionaryKind.DenseArray);
    }
    static endDictionaryEncoding(builder) {
        const offset = builder.endObject();
        return offset;
    }
}
exports.DictionaryEncoding = DictionaryEncoding;

//# sourceMappingURL=dictionary-encoding.js.map


/***/ }),
/* 73 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DictionaryKind = void 0;
/**
 * ----------------------------------------------------------------------
 * Dictionary encoding metadata
 * Maintained for forwards compatibility, in the future
 * Dictionaries might be explicit maps between integers and values
 * allowing for non-contiguous index values
 */
var DictionaryKind;
(function (DictionaryKind) {
    DictionaryKind[DictionaryKind["DenseArray"] = 0] = "DenseArray";
})(DictionaryKind || (exports.DictionaryKind = DictionaryKind = {}));

//# sourceMappingURL=dictionary-kind.js.map


/***/ }),
/* 74 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Int = void 0;
const flatbuffers = __webpack_require__(57);
class Int {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsInt(bb, obj) {
        return (obj || new Int()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsInt(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Int()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    bitWidth() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    isSigned() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startInt(builder) {
        builder.startObject(2);
    }
    static addBitWidth(builder, bitWidth) {
        builder.addFieldInt32(0, bitWidth, 0);
    }
    static addIsSigned(builder, isSigned) {
        builder.addFieldInt8(1, +isSigned, +false);
    }
    static endInt(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createInt(builder, bitWidth, isSigned) {
        Int.startInt(builder);
        Int.addBitWidth(builder, bitWidth);
        Int.addIsSigned(builder, isSigned);
        return Int.endInt(builder);
    }
}
exports.Int = Int;

//# sourceMappingURL=int.js.map


/***/ }),
/* 75 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KeyValue = void 0;
const flatbuffers = __webpack_require__(57);
/**
 * ----------------------------------------------------------------------
 * user defined key value pairs to add custom metadata to arrow
 * key namespacing is the responsibility of the user
 */
class KeyValue {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsKeyValue(bb, obj) {
        return (obj || new KeyValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsKeyValue(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new KeyValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    key(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    value(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startKeyValue(builder) {
        builder.startObject(2);
    }
    static addKey(builder, keyOffset) {
        builder.addFieldOffset(0, keyOffset, 0);
    }
    static addValue(builder, valueOffset) {
        builder.addFieldOffset(1, valueOffset, 0);
    }
    static endKeyValue(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createKeyValue(builder, keyOffset, valueOffset) {
        KeyValue.startKeyValue(builder);
        KeyValue.addKey(builder, keyOffset);
        KeyValue.addValue(builder, valueOffset);
        return KeyValue.endKeyValue(builder);
    }
}
exports.KeyValue = KeyValue;

//# sourceMappingURL=key-value.js.map


/***/ }),
/* 76 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unionListToType = exports.unionToType = exports.Type = void 0;
const binary_js_1 = __webpack_require__(77);
const bool_js_1 = __webpack_require__(78);
const date_js_1 = __webpack_require__(79);
const decimal_js_1 = __webpack_require__(80);
const duration_js_1 = __webpack_require__(81);
const fixed_size_binary_js_1 = __webpack_require__(82);
const fixed_size_list_js_1 = __webpack_require__(83);
const floating_point_js_1 = __webpack_require__(84);
const int_js_1 = __webpack_require__(74);
const interval_js_1 = __webpack_require__(85);
const large_binary_js_1 = __webpack_require__(86);
const large_list_js_1 = __webpack_require__(87);
const large_utf8_js_1 = __webpack_require__(88);
const list_js_1 = __webpack_require__(89);
const map_js_1 = __webpack_require__(90);
const null_js_1 = __webpack_require__(91);
const run_end_encoded_js_1 = __webpack_require__(92);
const struct__js_1 = __webpack_require__(93);
const time_js_1 = __webpack_require__(94);
const timestamp_js_1 = __webpack_require__(95);
const union_js_1 = __webpack_require__(96);
const utf8_js_1 = __webpack_require__(97);
/**
 * ----------------------------------------------------------------------
 * Top-level Type value, enabling extensible type-specific metadata. We can
 * add new logical types to Type without breaking backwards compatibility
 */
var Type;
(function (Type) {
    Type[Type["NONE"] = 0] = "NONE";
    Type[Type["Null"] = 1] = "Null";
    Type[Type["Int"] = 2] = "Int";
    Type[Type["FloatingPoint"] = 3] = "FloatingPoint";
    Type[Type["Binary"] = 4] = "Binary";
    Type[Type["Utf8"] = 5] = "Utf8";
    Type[Type["Bool"] = 6] = "Bool";
    Type[Type["Decimal"] = 7] = "Decimal";
    Type[Type["Date"] = 8] = "Date";
    Type[Type["Time"] = 9] = "Time";
    Type[Type["Timestamp"] = 10] = "Timestamp";
    Type[Type["Interval"] = 11] = "Interval";
    Type[Type["List"] = 12] = "List";
    Type[Type["Struct_"] = 13] = "Struct_";
    Type[Type["Union"] = 14] = "Union";
    Type[Type["FixedSizeBinary"] = 15] = "FixedSizeBinary";
    Type[Type["FixedSizeList"] = 16] = "FixedSizeList";
    Type[Type["Map"] = 17] = "Map";
    Type[Type["Duration"] = 18] = "Duration";
    Type[Type["LargeBinary"] = 19] = "LargeBinary";
    Type[Type["LargeUtf8"] = 20] = "LargeUtf8";
    Type[Type["LargeList"] = 21] = "LargeList";
    Type[Type["RunEndEncoded"] = 22] = "RunEndEncoded";
})(Type || (exports.Type = Type = {}));
function unionToType(type, accessor) {
    switch (Type[type]) {
        case 'NONE': return null;
        case 'Null': return accessor(new null_js_1.Null());
        case 'Int': return accessor(new int_js_1.Int());
        case 'FloatingPoint': return accessor(new floating_point_js_1.FloatingPoint());
        case 'Binary': return accessor(new binary_js_1.Binary());
        case 'Utf8': return accessor(new utf8_js_1.Utf8());
        case 'Bool': return accessor(new bool_js_1.Bool());
        case 'Decimal': return accessor(new decimal_js_1.Decimal());
        case 'Date': return accessor(new date_js_1.Date());
        case 'Time': return accessor(new time_js_1.Time());
        case 'Timestamp': return accessor(new timestamp_js_1.Timestamp());
        case 'Interval': return accessor(new interval_js_1.Interval());
        case 'List': return accessor(new list_js_1.List());
        case 'Struct_': return accessor(new struct__js_1.Struct_());
        case 'Union': return accessor(new union_js_1.Union());
        case 'FixedSizeBinary': return accessor(new fixed_size_binary_js_1.FixedSizeBinary());
        case 'FixedSizeList': return accessor(new fixed_size_list_js_1.FixedSizeList());
        case 'Map': return accessor(new map_js_1.Map());
        case 'Duration': return accessor(new duration_js_1.Duration());
        case 'LargeBinary': return accessor(new large_binary_js_1.LargeBinary());
        case 'LargeUtf8': return accessor(new large_utf8_js_1.LargeUtf8());
        case 'LargeList': return accessor(new large_list_js_1.LargeList());
        case 'RunEndEncoded': return accessor(new run_end_encoded_js_1.RunEndEncoded());
        default: return null;
    }
}
exports.unionToType = unionToType;
function unionListToType(type, accessor, index) {
    switch (Type[type]) {
        case 'NONE': return null;
        case 'Null': return accessor(index, new null_js_1.Null());
        case 'Int': return accessor(index, new int_js_1.Int());
        case 'FloatingPoint': return accessor(index, new floating_point_js_1.FloatingPoint());
        case 'Binary': return accessor(index, new binary_js_1.Binary());
        case 'Utf8': return accessor(index, new utf8_js_1.Utf8());
        case 'Bool': return accessor(index, new bool_js_1.Bool());
        case 'Decimal': return accessor(index, new decimal_js_1.Decimal());
        case 'Date': return accessor(index, new date_js_1.Date());
        case 'Time': return accessor(index, new time_js_1.Time());
        case 'Timestamp': return accessor(index, new timestamp_js_1.Timestamp());
        case 'Interval': return accessor(index, new interval_js_1.Interval());
        case 'List': return accessor(index, new list_js_1.List());
        case 'Struct_': return accessor(index, new struct__js_1.Struct_());
        case 'Union': return accessor(index, new union_js_1.Union());
        case 'FixedSizeBinary': return accessor(index, new fixed_size_binary_js_1.FixedSizeBinary());
        case 'FixedSizeList': return accessor(index, new fixed_size_list_js_1.FixedSizeList());
        case 'Map': return accessor(index, new map_js_1.Map());
        case 'Duration': return accessor(index, new duration_js_1.Duration());
        case 'LargeBinary': return accessor(index, new large_binary_js_1.LargeBinary());
        case 'LargeUtf8': return accessor(index, new large_utf8_js_1.LargeUtf8());
        case 'LargeList': return accessor(index, new large_list_js_1.LargeList());
        case 'RunEndEncoded': return accessor(index, new run_end_encoded_js_1.RunEndEncoded());
        default: return null;
    }
}
exports.unionListToType = unionListToType;

//# sourceMappingURL=type.js.map


/***/ }),
/* 77 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Binary = void 0;
const flatbuffers = __webpack_require__(57);
/**
 * Opaque binary data
 */
class Binary {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsBinary(bb, obj) {
        return (obj || new Binary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsBinary(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Binary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startBinary(builder) {
        builder.startObject(0);
    }
    static endBinary(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createBinary(builder) {
        Binary.startBinary(builder);
        return Binary.endBinary(builder);
    }
}
exports.Binary = Binary;

//# sourceMappingURL=binary.js.map


/***/ }),
/* 78 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Bool = void 0;
const flatbuffers = __webpack_require__(57);
class Bool {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsBool(bb, obj) {
        return (obj || new Bool()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsBool(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Bool()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startBool(builder) {
        builder.startObject(0);
    }
    static endBool(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createBool(builder) {
        Bool.startBool(builder);
        return Bool.endBool(builder);
    }
}
exports.Bool = Bool;

//# sourceMappingURL=bool.js.map


/***/ }),
/* 79 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Date = void 0;
const flatbuffers = __webpack_require__(57);
const date_unit_js_1 = __webpack_require__(52);
/**
 * Date is either a 32-bit or 64-bit signed integer type representing an
 * elapsed time since UNIX epoch (1970-01-01), stored in either of two units:
 *
 * * Milliseconds (64 bits) indicating UNIX time elapsed since the epoch (no
 *   leap seconds), where the values are evenly divisible by 86400000
 * * Days (32 bits) since the UNIX epoch
 */
class Date {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsDate(bb, obj) {
        return (obj || new Date()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDate(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Date()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    unit() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : date_unit_js_1.DateUnit.MILLISECOND;
    }
    static startDate(builder) {
        builder.startObject(1);
    }
    static addUnit(builder, unit) {
        builder.addFieldInt16(0, unit, date_unit_js_1.DateUnit.MILLISECOND);
    }
    static endDate(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createDate(builder, unit) {
        Date.startDate(builder);
        Date.addUnit(builder, unit);
        return Date.endDate(builder);
    }
}
exports.Date = Date;

//# sourceMappingURL=date.js.map


/***/ }),
/* 80 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Decimal = void 0;
const flatbuffers = __webpack_require__(57);
/**
 * Exact decimal value represented as an integer value in two's
 * complement. Currently only 128-bit (16-byte) and 256-bit (32-byte) integers
 * are used. The representation uses the endianness indicated
 * in the Schema.
 */
class Decimal {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsDecimal(bb, obj) {
        return (obj || new Decimal()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDecimal(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Decimal()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * Total number of decimal digits
     */
    precision() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    /**
     * Number of digits after the decimal point "."
     */
    scale() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    /**
     * Number of bits per value. The only accepted widths are 128 and 256.
     * We use bitWidth for consistency with Int::bitWidth.
     */
    bitWidth() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 128;
    }
    static startDecimal(builder) {
        builder.startObject(3);
    }
    static addPrecision(builder, precision) {
        builder.addFieldInt32(0, precision, 0);
    }
    static addScale(builder, scale) {
        builder.addFieldInt32(1, scale, 0);
    }
    static addBitWidth(builder, bitWidth) {
        builder.addFieldInt32(2, bitWidth, 128);
    }
    static endDecimal(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createDecimal(builder, precision, scale, bitWidth) {
        Decimal.startDecimal(builder);
        Decimal.addPrecision(builder, precision);
        Decimal.addScale(builder, scale);
        Decimal.addBitWidth(builder, bitWidth);
        return Decimal.endDecimal(builder);
    }
}
exports.Decimal = Decimal;

//# sourceMappingURL=decimal.js.map


/***/ }),
/* 81 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Duration = void 0;
const flatbuffers = __webpack_require__(57);
const time_unit_js_1 = __webpack_require__(53);
class Duration {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsDuration(bb, obj) {
        return (obj || new Duration()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDuration(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Duration()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    unit() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : time_unit_js_1.TimeUnit.MILLISECOND;
    }
    static startDuration(builder) {
        builder.startObject(1);
    }
    static addUnit(builder, unit) {
        builder.addFieldInt16(0, unit, time_unit_js_1.TimeUnit.MILLISECOND);
    }
    static endDuration(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createDuration(builder, unit) {
        Duration.startDuration(builder);
        Duration.addUnit(builder, unit);
        return Duration.endDuration(builder);
    }
}
exports.Duration = Duration;

//# sourceMappingURL=duration.js.map


/***/ }),
/* 82 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FixedSizeBinary = void 0;
const flatbuffers = __webpack_require__(57);
class FixedSizeBinary {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsFixedSizeBinary(bb, obj) {
        return (obj || new FixedSizeBinary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsFixedSizeBinary(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new FixedSizeBinary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * Number of bytes per value
     */
    byteWidth() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    static startFixedSizeBinary(builder) {
        builder.startObject(1);
    }
    static addByteWidth(builder, byteWidth) {
        builder.addFieldInt32(0, byteWidth, 0);
    }
    static endFixedSizeBinary(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createFixedSizeBinary(builder, byteWidth) {
        FixedSizeBinary.startFixedSizeBinary(builder);
        FixedSizeBinary.addByteWidth(builder, byteWidth);
        return FixedSizeBinary.endFixedSizeBinary(builder);
    }
}
exports.FixedSizeBinary = FixedSizeBinary;

//# sourceMappingURL=fixed-size-binary.js.map


/***/ }),
/* 83 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FixedSizeList = void 0;
const flatbuffers = __webpack_require__(57);
class FixedSizeList {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsFixedSizeList(bb, obj) {
        return (obj || new FixedSizeList()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsFixedSizeList(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new FixedSizeList()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * Number of list items per value
     */
    listSize() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    static startFixedSizeList(builder) {
        builder.startObject(1);
    }
    static addListSize(builder, listSize) {
        builder.addFieldInt32(0, listSize, 0);
    }
    static endFixedSizeList(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createFixedSizeList(builder, listSize) {
        FixedSizeList.startFixedSizeList(builder);
        FixedSizeList.addListSize(builder, listSize);
        return FixedSizeList.endFixedSizeList(builder);
    }
}
exports.FixedSizeList = FixedSizeList;

//# sourceMappingURL=fixed-size-list.js.map


/***/ }),
/* 84 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FloatingPoint = void 0;
const flatbuffers = __webpack_require__(57);
const precision_js_1 = __webpack_require__(51);
class FloatingPoint {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsFloatingPoint(bb, obj) {
        return (obj || new FloatingPoint()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsFloatingPoint(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new FloatingPoint()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    precision() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : precision_js_1.Precision.HALF;
    }
    static startFloatingPoint(builder) {
        builder.startObject(1);
    }
    static addPrecision(builder, precision) {
        builder.addFieldInt16(0, precision, precision_js_1.Precision.HALF);
    }
    static endFloatingPoint(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createFloatingPoint(builder, precision) {
        FloatingPoint.startFloatingPoint(builder);
        FloatingPoint.addPrecision(builder, precision);
        return FloatingPoint.endFloatingPoint(builder);
    }
}
exports.FloatingPoint = FloatingPoint;

//# sourceMappingURL=floating-point.js.map


/***/ }),
/* 85 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Interval = void 0;
const flatbuffers = __webpack_require__(57);
const interval_unit_js_1 = __webpack_require__(54);
class Interval {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsInterval(bb, obj) {
        return (obj || new Interval()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsInterval(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Interval()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    unit() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : interval_unit_js_1.IntervalUnit.YEAR_MONTH;
    }
    static startInterval(builder) {
        builder.startObject(1);
    }
    static addUnit(builder, unit) {
        builder.addFieldInt16(0, unit, interval_unit_js_1.IntervalUnit.YEAR_MONTH);
    }
    static endInterval(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createInterval(builder, unit) {
        Interval.startInterval(builder);
        Interval.addUnit(builder, unit);
        return Interval.endInterval(builder);
    }
}
exports.Interval = Interval;

//# sourceMappingURL=interval.js.map


/***/ }),
/* 86 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LargeBinary = void 0;
const flatbuffers = __webpack_require__(57);
/**
 * Same as Binary, but with 64-bit offsets, allowing to represent
 * extremely large data values.
 */
class LargeBinary {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsLargeBinary(bb, obj) {
        return (obj || new LargeBinary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsLargeBinary(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new LargeBinary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startLargeBinary(builder) {
        builder.startObject(0);
    }
    static endLargeBinary(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createLargeBinary(builder) {
        LargeBinary.startLargeBinary(builder);
        return LargeBinary.endLargeBinary(builder);
    }
}
exports.LargeBinary = LargeBinary;

//# sourceMappingURL=large-binary.js.map


/***/ }),
/* 87 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LargeList = void 0;
const flatbuffers = __webpack_require__(57);
/**
 * Same as List, but with 64-bit offsets, allowing to represent
 * extremely large data values.
 */
class LargeList {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsLargeList(bb, obj) {
        return (obj || new LargeList()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsLargeList(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new LargeList()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startLargeList(builder) {
        builder.startObject(0);
    }
    static endLargeList(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createLargeList(builder) {
        LargeList.startLargeList(builder);
        return LargeList.endLargeList(builder);
    }
}
exports.LargeList = LargeList;

//# sourceMappingURL=large-list.js.map


/***/ }),
/* 88 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LargeUtf8 = void 0;
const flatbuffers = __webpack_require__(57);
/**
 * Same as Utf8, but with 64-bit offsets, allowing to represent
 * extremely large data values.
 */
class LargeUtf8 {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsLargeUtf8(bb, obj) {
        return (obj || new LargeUtf8()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsLargeUtf8(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new LargeUtf8()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startLargeUtf8(builder) {
        builder.startObject(0);
    }
    static endLargeUtf8(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createLargeUtf8(builder) {
        LargeUtf8.startLargeUtf8(builder);
        return LargeUtf8.endLargeUtf8(builder);
    }
}
exports.LargeUtf8 = LargeUtf8;

//# sourceMappingURL=large-utf8.js.map


/***/ }),
/* 89 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.List = void 0;
const flatbuffers = __webpack_require__(57);
class List {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsList(bb, obj) {
        return (obj || new List()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsList(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new List()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startList(builder) {
        builder.startObject(0);
    }
    static endList(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createList(builder) {
        List.startList(builder);
        return List.endList(builder);
    }
}
exports.List = List;

//# sourceMappingURL=list.js.map


/***/ }),
/* 90 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Map = void 0;
const flatbuffers = __webpack_require__(57);
/**
 * A Map is a logical nested type that is represented as
 *
 * List<entries: Struct<key: K, value: V>>
 *
 * In this layout, the keys and values are each respectively contiguous. We do
 * not constrain the key and value types, so the application is responsible
 * for ensuring that the keys are hashable and unique. Whether the keys are sorted
 * may be set in the metadata for this field.
 *
 * In a field with Map type, the field has a child Struct field, which then
 * has two children: key type and the second the value type. The names of the
 * child fields may be respectively "entries", "key", and "value", but this is
 * not enforced.
 *
 * Map
 * ```text
 *   - child[0] entries: Struct
 *     - child[0] key: K
 *     - child[1] value: V
 * ```
 * Neither the "entries" field nor the "key" field may be nullable.
 *
 * The metadata is structured so that Arrow systems without special handling
 * for Map can make Map an alias for List. The "layout" attribute for the Map
 * field must have the same contents as a List.
 */
class Map {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsMap(bb, obj) {
        return (obj || new Map()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsMap(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Map()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * Set to true if the keys within each value are sorted
     */
    keysSorted() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startMap(builder) {
        builder.startObject(1);
    }
    static addKeysSorted(builder, keysSorted) {
        builder.addFieldInt8(0, +keysSorted, +false);
    }
    static endMap(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createMap(builder, keysSorted) {
        Map.startMap(builder);
        Map.addKeysSorted(builder, keysSorted);
        return Map.endMap(builder);
    }
}
exports.Map = Map;

//# sourceMappingURL=map.js.map


/***/ }),
/* 91 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Null = void 0;
const flatbuffers = __webpack_require__(57);
/**
 * These are stored in the flatbuffer in the Type union below
 */
class Null {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsNull(bb, obj) {
        return (obj || new Null()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsNull(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Null()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startNull(builder) {
        builder.startObject(0);
    }
    static endNull(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createNull(builder) {
        Null.startNull(builder);
        return Null.endNull(builder);
    }
}
exports.Null = Null;

//# sourceMappingURL=null.js.map


/***/ }),
/* 92 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RunEndEncoded = void 0;
const flatbuffers = __webpack_require__(57);
/**
 * Contains two child arrays, run_ends and values.
 * The run_ends child array must be a 16/32/64-bit integer array
 * which encodes the indices at which the run with the value in
 * each corresponding index in the values child array ends.
 * Like list/struct types, the value array can be of any type.
 */
class RunEndEncoded {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsRunEndEncoded(bb, obj) {
        return (obj || new RunEndEncoded()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsRunEndEncoded(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new RunEndEncoded()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startRunEndEncoded(builder) {
        builder.startObject(0);
    }
    static endRunEndEncoded(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createRunEndEncoded(builder) {
        RunEndEncoded.startRunEndEncoded(builder);
        return RunEndEncoded.endRunEndEncoded(builder);
    }
}
exports.RunEndEncoded = RunEndEncoded;

//# sourceMappingURL=run-end-encoded.js.map


/***/ }),
/* 93 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Struct_ = void 0;
const flatbuffers = __webpack_require__(57);
/**
 * A Struct_ in the flatbuffer metadata is the same as an Arrow Struct
 * (according to the physical memory layout). We used Struct_ here as
 * Struct is a reserved word in Flatbuffers
 */
class Struct_ {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsStruct_(bb, obj) {
        return (obj || new Struct_()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsStruct_(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Struct_()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startStruct_(builder) {
        builder.startObject(0);
    }
    static endStruct_(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createStruct_(builder) {
        Struct_.startStruct_(builder);
        return Struct_.endStruct_(builder);
    }
}
exports.Struct_ = Struct_;

//# sourceMappingURL=struct-.js.map


/***/ }),
/* 94 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Time = void 0;
const flatbuffers = __webpack_require__(57);
const time_unit_js_1 = __webpack_require__(53);
/**
 * Time is either a 32-bit or 64-bit signed integer type representing an
 * elapsed time since midnight, stored in either of four units: seconds,
 * milliseconds, microseconds or nanoseconds.
 *
 * The integer `bitWidth` depends on the `unit` and must be one of the following:
 * * SECOND and MILLISECOND: 32 bits
 * * MICROSECOND and NANOSECOND: 64 bits
 *
 * The allowed values are between 0 (inclusive) and 86400 (=24*60*60) seconds
 * (exclusive), adjusted for the time unit (for example, up to 86400000
 * exclusive for the MILLISECOND unit).
 * This definition doesn't allow for leap seconds. Time values from
 * measurements with leap seconds will need to be corrected when ingesting
 * into Arrow (for example by replacing the value 86400 with 86399).
 */
class Time {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsTime(bb, obj) {
        return (obj || new Time()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsTime(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Time()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    unit() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : time_unit_js_1.TimeUnit.MILLISECOND;
    }
    bitWidth() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 32;
    }
    static startTime(builder) {
        builder.startObject(2);
    }
    static addUnit(builder, unit) {
        builder.addFieldInt16(0, unit, time_unit_js_1.TimeUnit.MILLISECOND);
    }
    static addBitWidth(builder, bitWidth) {
        builder.addFieldInt32(1, bitWidth, 32);
    }
    static endTime(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createTime(builder, unit, bitWidth) {
        Time.startTime(builder);
        Time.addUnit(builder, unit);
        Time.addBitWidth(builder, bitWidth);
        return Time.endTime(builder);
    }
}
exports.Time = Time;

//# sourceMappingURL=time.js.map


/***/ }),
/* 95 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Timestamp = void 0;
const flatbuffers = __webpack_require__(57);
const time_unit_js_1 = __webpack_require__(53);
/**
 * Timestamp is a 64-bit signed integer representing an elapsed time since a
 * fixed epoch, stored in either of four units: seconds, milliseconds,
 * microseconds or nanoseconds, and is optionally annotated with a timezone.
 *
 * Timestamp values do not include any leap seconds (in other words, all
 * days are considered 86400 seconds long).
 *
 * Timestamps with a non-empty timezone
 * ------------------------------------
 *
 * If a Timestamp column has a non-empty timezone value, its epoch is
 * 1970-01-01 00:00:00 (January 1st 1970, midnight) in the *UTC* timezone
 * (the Unix epoch), regardless of the Timestamp's own timezone.
 *
 * Therefore, timestamp values with a non-empty timezone correspond to
 * physical points in time together with some additional information about
 * how the data was obtained and/or how to display it (the timezone).
 *
 *   For example, the timestamp value 0 with the timezone string "Europe/Paris"
 *   corresponds to "January 1st 1970, 00h00" in the UTC timezone, but the
 *   application may prefer to display it as "January 1st 1970, 01h00" in
 *   the Europe/Paris timezone (which is the same physical point in time).
 *
 * One consequence is that timestamp values with a non-empty timezone
 * can be compared and ordered directly, since they all share the same
 * well-known point of reference (the Unix epoch).
 *
 * Timestamps with an unset / empty timezone
 * -----------------------------------------
 *
 * If a Timestamp column has no timezone value, its epoch is
 * 1970-01-01 00:00:00 (January 1st 1970, midnight) in an *unknown* timezone.
 *
 * Therefore, timestamp values without a timezone cannot be meaningfully
 * interpreted as physical points in time, but only as calendar / clock
 * indications ("wall clock time") in an unspecified timezone.
 *
 *   For example, the timestamp value 0 with an empty timezone string
 *   corresponds to "January 1st 1970, 00h00" in an unknown timezone: there
 *   is not enough information to interpret it as a well-defined physical
 *   point in time.
 *
 * One consequence is that timestamp values without a timezone cannot
 * be reliably compared or ordered, since they may have different points of
 * reference.  In particular, it is *not* possible to interpret an unset
 * or empty timezone as the same as "UTC".
 *
 * Conversion between timezones
 * ----------------------------
 *
 * If a Timestamp column has a non-empty timezone, changing the timezone
 * to a different non-empty value is a metadata-only operation:
 * the timestamp values need not change as their point of reference remains
 * the same (the Unix epoch).
 *
 * However, if a Timestamp column has no timezone value, changing it to a
 * non-empty value requires to think about the desired semantics.
 * One possibility is to assume that the original timestamp values are
 * relative to the epoch of the timezone being set; timestamp values should
 * then adjusted to the Unix epoch (for example, changing the timezone from
 * empty to "Europe/Paris" would require converting the timestamp values
 * from "Europe/Paris" to "UTC", which seems counter-intuitive but is
 * nevertheless correct).
 *
 * Guidelines for encoding data from external libraries
 * ----------------------------------------------------
 *
 * Date & time libraries often have multiple different data types for temporal
 * data. In order to ease interoperability between different implementations the
 * Arrow project has some recommendations for encoding these types into a Timestamp
 * column.
 *
 * An "instant" represents a physical point in time that has no relevant timezone
 * (for example, astronomical data). To encode an instant, use a Timestamp with
 * the timezone string set to "UTC", and make sure the Timestamp values
 * are relative to the UTC epoch (January 1st 1970, midnight).
 *
 * A "zoned date-time" represents a physical point in time annotated with an
 * informative timezone (for example, the timezone in which the data was
 * recorded).  To encode a zoned date-time, use a Timestamp with the timezone
 * string set to the name of the timezone, and make sure the Timestamp values
 * are relative to the UTC epoch (January 1st 1970, midnight).
 *
 *  (There is some ambiguity between an instant and a zoned date-time with the
 *   UTC timezone.  Both of these are stored the same in Arrow.  Typically,
 *   this distinction does not matter.  If it does, then an application should
 *   use custom metadata or an extension type to distinguish between the two cases.)
 *
 * An "offset date-time" represents a physical point in time combined with an
 * explicit offset from UTC.  To encode an offset date-time, use a Timestamp
 * with the timezone string set to the numeric timezone offset string
 * (e.g. "+03:00"), and make sure the Timestamp values are relative to
 * the UTC epoch (January 1st 1970, midnight).
 *
 * A "naive date-time" (also called "local date-time" in some libraries)
 * represents a wall clock time combined with a calendar date, but with
 * no indication of how to map this information to a physical point in time.
 * Naive date-times must be handled with care because of this missing
 * information, and also because daylight saving time (DST) may make
 * some values ambiguous or nonexistent. A naive date-time may be
 * stored as a struct with Date and Time fields. However, it may also be
 * encoded into a Timestamp column with an empty timezone. The timestamp
 * values should be computed "as if" the timezone of the date-time values
 * was UTC; for example, the naive date-time "January 1st 1970, 00h00" would
 * be encoded as timestamp value 0.
 */
class Timestamp {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsTimestamp(bb, obj) {
        return (obj || new Timestamp()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsTimestamp(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Timestamp()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    unit() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : time_unit_js_1.TimeUnit.SECOND;
    }
    timezone(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startTimestamp(builder) {
        builder.startObject(2);
    }
    static addUnit(builder, unit) {
        builder.addFieldInt16(0, unit, time_unit_js_1.TimeUnit.SECOND);
    }
    static addTimezone(builder, timezoneOffset) {
        builder.addFieldOffset(1, timezoneOffset, 0);
    }
    static endTimestamp(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createTimestamp(builder, unit, timezoneOffset) {
        Timestamp.startTimestamp(builder);
        Timestamp.addUnit(builder, unit);
        Timestamp.addTimezone(builder, timezoneOffset);
        return Timestamp.endTimestamp(builder);
    }
}
exports.Timestamp = Timestamp;

//# sourceMappingURL=timestamp.js.map


/***/ }),
/* 96 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Union = void 0;
const flatbuffers = __webpack_require__(57);
const union_mode_js_1 = __webpack_require__(50);
/**
 * A union is a complex type with children in Field
 * By default ids in the type vector refer to the offsets in the children
 * optionally typeIds provides an indirection between the child offset and the type id
 * for each child `typeIds[offset]` is the id used in the type vector
 */
class Union {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsUnion(bb, obj) {
        return (obj || new Union()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsUnion(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Union()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    mode() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : union_mode_js_1.UnionMode.Sparse;
    }
    typeIds(index) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
    }
    typeIdsLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    typeIdsArray() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    static startUnion(builder) {
        builder.startObject(2);
    }
    static addMode(builder, mode) {
        builder.addFieldInt16(0, mode, union_mode_js_1.UnionMode.Sparse);
    }
    static addTypeIds(builder, typeIdsOffset) {
        builder.addFieldOffset(1, typeIdsOffset, 0);
    }
    static createTypeIdsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt32(data[i]);
        }
        return builder.endVector();
    }
    static startTypeIdsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endUnion(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createUnion(builder, mode, typeIdsOffset) {
        Union.startUnion(builder);
        Union.addMode(builder, mode);
        Union.addTypeIds(builder, typeIdsOffset);
        return Union.endUnion(builder);
    }
}
exports.Union = Union;

//# sourceMappingURL=union.js.map


/***/ }),
/* 97 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Utf8 = void 0;
const flatbuffers = __webpack_require__(57);
/**
 * Unicode with UTF-8 encoding
 */
class Utf8 {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsUtf8(bb, obj) {
        return (obj || new Utf8()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsUtf8(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Utf8()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startUtf8(builder) {
        builder.startObject(0);
    }
    static endUtf8(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createUtf8(builder) {
        Utf8.startUtf8(builder);
        return Utf8.endUtf8(builder);
    }
}
exports.Utf8 = Utf8;

//# sourceMappingURL=utf8.js.map


/***/ }),
/* 98 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SparseTensor = void 0;
const flatbuffers = __webpack_require__(57);
const buffer_js_1 = __webpack_require__(67);
const sparse_tensor_index_js_1 = __webpack_require__(99);
const tensor_dim_js_1 = __webpack_require__(104);
const type_js_1 = __webpack_require__(76);
class SparseTensor {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSparseTensor(bb, obj) {
        return (obj || new SparseTensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSparseTensor(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new SparseTensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    typeType() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : type_js_1.Type.NONE;
    }
    /**
     * The type of data contained in a value cell.
     * Currently only fixed-width value types are supported,
     * no strings or nested types.
     */
    type(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    /**
     * The dimensions of the tensor, optionally named.
     */
    shape(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new tensor_dim_js_1.TensorDim()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    shapeLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * The number of non-zero values in a sparse tensor.
     */
    nonZeroLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt('0');
    }
    sparseIndexType() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : sparse_tensor_index_js_1.SparseTensorIndex.NONE;
    }
    /**
     * Sparse tensor index
     */
    sparseIndex(obj) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    /**
     * The location and size of the tensor's data
     */
    data(obj) {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? (obj || new buffer_js_1.Buffer()).__init(this.bb_pos + offset, this.bb) : null;
    }
    static startSparseTensor(builder) {
        builder.startObject(7);
    }
    static addTypeType(builder, typeType) {
        builder.addFieldInt8(0, typeType, type_js_1.Type.NONE);
    }
    static addType(builder, typeOffset) {
        builder.addFieldOffset(1, typeOffset, 0);
    }
    static addShape(builder, shapeOffset) {
        builder.addFieldOffset(2, shapeOffset, 0);
    }
    static createShapeVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startShapeVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addNonZeroLength(builder, nonZeroLength) {
        builder.addFieldInt64(3, nonZeroLength, BigInt('0'));
    }
    static addSparseIndexType(builder, sparseIndexType) {
        builder.addFieldInt8(4, sparseIndexType, sparse_tensor_index_js_1.SparseTensorIndex.NONE);
    }
    static addSparseIndex(builder, sparseIndexOffset) {
        builder.addFieldOffset(5, sparseIndexOffset, 0);
    }
    static addData(builder, dataOffset) {
        builder.addFieldStruct(6, dataOffset, 0);
    }
    static endSparseTensor(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 6); // type
        builder.requiredField(offset, 8); // shape
        builder.requiredField(offset, 14); // sparseIndex
        builder.requiredField(offset, 16); // data
        return offset;
    }
    static finishSparseTensorBuffer(builder, offset) {
        builder.finish(offset);
    }
    static finishSizePrefixedSparseTensorBuffer(builder, offset) {
        builder.finish(offset, undefined, true);
    }
}
exports.SparseTensor = SparseTensor;

//# sourceMappingURL=sparse-tensor.js.map


/***/ }),
/* 99 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unionListToSparseTensorIndex = exports.unionToSparseTensorIndex = exports.SparseTensorIndex = void 0;
const sparse_matrix_index_csx_js_1 = __webpack_require__(100);
const sparse_tensor_index_coo_js_1 = __webpack_require__(102);
const sparse_tensor_index_csf_js_1 = __webpack_require__(103);
var SparseTensorIndex;
(function (SparseTensorIndex) {
    SparseTensorIndex[SparseTensorIndex["NONE"] = 0] = "NONE";
    SparseTensorIndex[SparseTensorIndex["SparseTensorIndexCOO"] = 1] = "SparseTensorIndexCOO";
    SparseTensorIndex[SparseTensorIndex["SparseMatrixIndexCSX"] = 2] = "SparseMatrixIndexCSX";
    SparseTensorIndex[SparseTensorIndex["SparseTensorIndexCSF"] = 3] = "SparseTensorIndexCSF";
})(SparseTensorIndex || (exports.SparseTensorIndex = SparseTensorIndex = {}));
function unionToSparseTensorIndex(type, accessor) {
    switch (SparseTensorIndex[type]) {
        case 'NONE': return null;
        case 'SparseTensorIndexCOO': return accessor(new sparse_tensor_index_coo_js_1.SparseTensorIndexCOO());
        case 'SparseMatrixIndexCSX': return accessor(new sparse_matrix_index_csx_js_1.SparseMatrixIndexCSX());
        case 'SparseTensorIndexCSF': return accessor(new sparse_tensor_index_csf_js_1.SparseTensorIndexCSF());
        default: return null;
    }
}
exports.unionToSparseTensorIndex = unionToSparseTensorIndex;
function unionListToSparseTensorIndex(type, accessor, index) {
    switch (SparseTensorIndex[type]) {
        case 'NONE': return null;
        case 'SparseTensorIndexCOO': return accessor(index, new sparse_tensor_index_coo_js_1.SparseTensorIndexCOO());
        case 'SparseMatrixIndexCSX': return accessor(index, new sparse_matrix_index_csx_js_1.SparseMatrixIndexCSX());
        case 'SparseTensorIndexCSF': return accessor(index, new sparse_tensor_index_csf_js_1.SparseTensorIndexCSF());
        default: return null;
    }
}
exports.unionListToSparseTensorIndex = unionListToSparseTensorIndex;

//# sourceMappingURL=sparse-tensor-index.js.map


/***/ }),
/* 100 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SparseMatrixIndexCSX = void 0;
const flatbuffers = __webpack_require__(57);
const buffer_js_1 = __webpack_require__(67);
const int_js_1 = __webpack_require__(74);
const sparse_matrix_compressed_axis_js_1 = __webpack_require__(101);
/**
 * Compressed Sparse format, that is matrix-specific.
 */
class SparseMatrixIndexCSX {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSparseMatrixIndexCSX(bb, obj) {
        return (obj || new SparseMatrixIndexCSX()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSparseMatrixIndexCSX(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new SparseMatrixIndexCSX()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * Which axis, row or column, is compressed
     */
    compressedAxis() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : sparse_matrix_compressed_axis_js_1.SparseMatrixCompressedAxis.Row;
    }
    /**
     * The type of values in indptrBuffer
     */
    indptrType(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new int_js_1.Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * indptrBuffer stores the location and size of indptr array that
     * represents the range of the rows.
     * The i-th row spans from `indptr[i]` to `indptr[i+1]` in the data.
     * The length of this array is 1 + (the number of rows), and the type
     * of index value is long.
     *
     * For example, let X be the following 6x4 matrix:
     * ```text
     *   X := [[0, 1, 2, 0],
     *         [0, 0, 3, 0],
     *         [0, 4, 0, 5],
     *         [0, 0, 0, 0],
     *         [6, 0, 7, 8],
     *         [0, 9, 0, 0]].
     * ```
     * The array of non-zero values in X is:
     * ```text
     *   values(X) = [1, 2, 3, 4, 5, 6, 7, 8, 9].
     * ```
     * And the indptr of X is:
     * ```text
     *   indptr(X) = [0, 2, 3, 5, 5, 8, 10].
     * ```
     */
    indptrBuffer(obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new buffer_js_1.Buffer()).__init(this.bb_pos + offset, this.bb) : null;
    }
    /**
     * The type of values in indicesBuffer
     */
    indicesType(obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new int_js_1.Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * indicesBuffer stores the location and size of the array that
     * contains the column indices of the corresponding non-zero values.
     * The type of index value is long.
     *
     * For example, the indices of the above X is:
     * ```text
     *   indices(X) = [1, 2, 2, 1, 3, 0, 2, 3, 1].
     * ```
     * Note that the indices are sorted in lexicographical order for each row.
     */
    indicesBuffer(obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? (obj || new buffer_js_1.Buffer()).__init(this.bb_pos + offset, this.bb) : null;
    }
    static startSparseMatrixIndexCSX(builder) {
        builder.startObject(5);
    }
    static addCompressedAxis(builder, compressedAxis) {
        builder.addFieldInt16(0, compressedAxis, sparse_matrix_compressed_axis_js_1.SparseMatrixCompressedAxis.Row);
    }
    static addIndptrType(builder, indptrTypeOffset) {
        builder.addFieldOffset(1, indptrTypeOffset, 0);
    }
    static addIndptrBuffer(builder, indptrBufferOffset) {
        builder.addFieldStruct(2, indptrBufferOffset, 0);
    }
    static addIndicesType(builder, indicesTypeOffset) {
        builder.addFieldOffset(3, indicesTypeOffset, 0);
    }
    static addIndicesBuffer(builder, indicesBufferOffset) {
        builder.addFieldStruct(4, indicesBufferOffset, 0);
    }
    static endSparseMatrixIndexCSX(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 6); // indptrType
        builder.requiredField(offset, 8); // indptrBuffer
        builder.requiredField(offset, 10); // indicesType
        builder.requiredField(offset, 12); // indicesBuffer
        return offset;
    }
}
exports.SparseMatrixIndexCSX = SparseMatrixIndexCSX;

//# sourceMappingURL=sparse-matrix-index-csx.js.map


/***/ }),
/* 101 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SparseMatrixCompressedAxis = void 0;
var SparseMatrixCompressedAxis;
(function (SparseMatrixCompressedAxis) {
    SparseMatrixCompressedAxis[SparseMatrixCompressedAxis["Row"] = 0] = "Row";
    SparseMatrixCompressedAxis[SparseMatrixCompressedAxis["Column"] = 1] = "Column";
})(SparseMatrixCompressedAxis || (exports.SparseMatrixCompressedAxis = SparseMatrixCompressedAxis = {}));

//# sourceMappingURL=sparse-matrix-compressed-axis.js.map


/***/ }),
/* 102 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SparseTensorIndexCOO = void 0;
const flatbuffers = __webpack_require__(57);
const buffer_js_1 = __webpack_require__(67);
const int_js_1 = __webpack_require__(74);
/**
 * ----------------------------------------------------------------------
 * EXPERIMENTAL: Data structures for sparse tensors
 * Coordinate (COO) format of sparse tensor index.
 *
 * COO's index list are represented as a NxM matrix,
 * where N is the number of non-zero values,
 * and M is the number of dimensions of a sparse tensor.
 *
 * indicesBuffer stores the location and size of the data of this indices
 * matrix.  The value type and the stride of the indices matrix is
 * specified in indicesType and indicesStrides fields.
 *
 * For example, let X be a 2x3x4x5 tensor, and it has the following
 * 6 non-zero values:
 * ```text
 *   X[0, 1, 2, 0] := 1
 *   X[1, 1, 2, 3] := 2
 *   X[0, 2, 1, 0] := 3
 *   X[0, 1, 3, 0] := 4
 *   X[0, 1, 2, 1] := 5
 *   X[1, 2, 0, 4] := 6
 * ```
 * In COO format, the index matrix of X is the following 4x6 matrix:
 * ```text
 *   [[0, 0, 0, 0, 1, 1],
 *    [1, 1, 1, 2, 1, 2],
 *    [2, 2, 3, 1, 2, 0],
 *    [0, 1, 0, 0, 3, 4]]
 * ```
 * When isCanonical is true, the indices is sorted in lexicographical order
 * (row-major order), and it does not have duplicated entries.  Otherwise,
 * the indices may not be sorted, or may have duplicated entries.
 */
class SparseTensorIndexCOO {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSparseTensorIndexCOO(bb, obj) {
        return (obj || new SparseTensorIndexCOO()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSparseTensorIndexCOO(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new SparseTensorIndexCOO()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * The type of values in indicesBuffer
     */
    indicesType(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new int_js_1.Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * Non-negative byte offsets to advance one value cell along each dimension
     * If omitted, default to row-major order (C-like).
     */
    indicesStrides(index) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8) : BigInt(0);
    }
    indicesStridesLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * The location and size of the indices matrix's data
     */
    indicesBuffer(obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new buffer_js_1.Buffer()).__init(this.bb_pos + offset, this.bb) : null;
    }
    /**
     * This flag is true if and only if the indices matrix is sorted in
     * row-major order, and does not have duplicated entries.
     * This sort order is the same as of Tensorflow's SparseTensor,
     * but it is inverse order of SciPy's canonical coo_matrix
     * (SciPy employs column-major order for its coo_matrix).
     */
    isCanonical() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startSparseTensorIndexCOO(builder) {
        builder.startObject(4);
    }
    static addIndicesType(builder, indicesTypeOffset) {
        builder.addFieldOffset(0, indicesTypeOffset, 0);
    }
    static addIndicesStrides(builder, indicesStridesOffset) {
        builder.addFieldOffset(1, indicesStridesOffset, 0);
    }
    static createIndicesStridesVector(builder, data) {
        builder.startVector(8, data.length, 8);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt64(data[i]);
        }
        return builder.endVector();
    }
    static startIndicesStridesVector(builder, numElems) {
        builder.startVector(8, numElems, 8);
    }
    static addIndicesBuffer(builder, indicesBufferOffset) {
        builder.addFieldStruct(2, indicesBufferOffset, 0);
    }
    static addIsCanonical(builder, isCanonical) {
        builder.addFieldInt8(3, +isCanonical, +false);
    }
    static endSparseTensorIndexCOO(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // indicesType
        builder.requiredField(offset, 8); // indicesBuffer
        return offset;
    }
}
exports.SparseTensorIndexCOO = SparseTensorIndexCOO;

//# sourceMappingURL=sparse-tensor-index-coo.js.map


/***/ }),
/* 103 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SparseTensorIndexCSF = void 0;
const flatbuffers = __webpack_require__(57);
const buffer_js_1 = __webpack_require__(67);
const int_js_1 = __webpack_require__(74);
/**
 * Compressed Sparse Fiber (CSF) sparse tensor index.
 */
class SparseTensorIndexCSF {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSparseTensorIndexCSF(bb, obj) {
        return (obj || new SparseTensorIndexCSF()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSparseTensorIndexCSF(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new SparseTensorIndexCSF()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * CSF is a generalization of compressed sparse row (CSR) index.
     * See [smith2017knl](http://shaden.io/pub-files/smith2017knl.pdf)
     *
     * CSF index recursively compresses each dimension of a tensor into a set
     * of prefix trees. Each path from a root to leaf forms one tensor
     * non-zero index. CSF is implemented with two arrays of buffers and one
     * arrays of integers.
     *
     * For example, let X be a 2x3x4x5 tensor and let it have the following
     * 8 non-zero values:
     * ```text
     *   X[0, 0, 0, 1] := 1
     *   X[0, 0, 0, 2] := 2
     *   X[0, 1, 0, 0] := 3
     *   X[0, 1, 0, 2] := 4
     *   X[0, 1, 1, 0] := 5
     *   X[1, 1, 1, 0] := 6
     *   X[1, 1, 1, 1] := 7
     *   X[1, 1, 1, 2] := 8
     * ```
     * As a prefix tree this would be represented as:
     * ```text
     *         0          1
     *        / \         |
     *       0   1        1
     *      /   / \       |
     *     0   0   1      1
     *    /|  /|   |    /| |
     *   1 2 0 2   0   0 1 2
     * ```
     * The type of values in indptrBuffers
     */
    indptrType(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new int_js_1.Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * indptrBuffers stores the sparsity structure.
     * Each two consecutive dimensions in a tensor correspond to a buffer in
     * indptrBuffers. A pair of consecutive values at `indptrBuffers[dim][i]`
     * and `indptrBuffers[dim][i + 1]` signify a range of nodes in
     * `indicesBuffers[dim + 1]` who are children of `indicesBuffers[dim][i]` node.
     *
     * For example, the indptrBuffers for the above X is:
     * ```text
     *   indptrBuffer(X) = [
     *                       [0, 2, 3],
     *                       [0, 1, 3, 4],
     *                       [0, 2, 4, 5, 8]
     *                     ].
     * ```
     */
    indptrBuffers(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new buffer_js_1.Buffer()).__init(this.bb.__vector(this.bb_pos + offset) + index * 16, this.bb) : null;
    }
    indptrBuffersLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * The type of values in indicesBuffers
     */
    indicesType(obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new int_js_1.Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * indicesBuffers stores values of nodes.
     * Each tensor dimension corresponds to a buffer in indicesBuffers.
     * For example, the indicesBuffers for the above X is:
     * ```text
     *   indicesBuffer(X) = [
     *                        [0, 1],
     *                        [0, 1, 1],
     *                        [0, 0, 1, 1],
     *                        [1, 2, 0, 2, 0, 0, 1, 2]
     *                      ].
     * ```
     */
    indicesBuffers(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new buffer_js_1.Buffer()).__init(this.bb.__vector(this.bb_pos + offset) + index * 16, this.bb) : null;
    }
    indicesBuffersLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * axisOrder stores the sequence in which dimensions were traversed to
     * produce the prefix tree.
     * For example, the axisOrder for the above X is:
     * ```text
     *   axisOrder(X) = [0, 1, 2, 3].
     * ```
     */
    axisOrder(index) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
    }
    axisOrderLength() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    axisOrderArray() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    static startSparseTensorIndexCSF(builder) {
        builder.startObject(5);
    }
    static addIndptrType(builder, indptrTypeOffset) {
        builder.addFieldOffset(0, indptrTypeOffset, 0);
    }
    static addIndptrBuffers(builder, indptrBuffersOffset) {
        builder.addFieldOffset(1, indptrBuffersOffset, 0);
    }
    static startIndptrBuffersVector(builder, numElems) {
        builder.startVector(16, numElems, 8);
    }
    static addIndicesType(builder, indicesTypeOffset) {
        builder.addFieldOffset(2, indicesTypeOffset, 0);
    }
    static addIndicesBuffers(builder, indicesBuffersOffset) {
        builder.addFieldOffset(3, indicesBuffersOffset, 0);
    }
    static startIndicesBuffersVector(builder, numElems) {
        builder.startVector(16, numElems, 8);
    }
    static addAxisOrder(builder, axisOrderOffset) {
        builder.addFieldOffset(4, axisOrderOffset, 0);
    }
    static createAxisOrderVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt32(data[i]);
        }
        return builder.endVector();
    }
    static startAxisOrderVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endSparseTensorIndexCSF(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // indptrType
        builder.requiredField(offset, 6); // indptrBuffers
        builder.requiredField(offset, 8); // indicesType
        builder.requiredField(offset, 10); // indicesBuffers
        builder.requiredField(offset, 12); // axisOrder
        return offset;
    }
}
exports.SparseTensorIndexCSF = SparseTensorIndexCSF;

//# sourceMappingURL=sparse-tensor-index-csf.js.map


/***/ }),
/* 104 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TensorDim = void 0;
const flatbuffers = __webpack_require__(57);
/**
 * ----------------------------------------------------------------------
 * Data structures for dense tensors
 * Shape data for a single axis in a tensor
 */
class TensorDim {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsTensorDim(bb, obj) {
        return (obj || new TensorDim()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsTensorDim(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new TensorDim()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * Length of dimension
     */
    size() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt('0');
    }
    name(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startTensorDim(builder) {
        builder.startObject(2);
    }
    static addSize(builder, size) {
        builder.addFieldInt64(0, size, BigInt('0'));
    }
    static addName(builder, nameOffset) {
        builder.addFieldOffset(1, nameOffset, 0);
    }
    static endTensorDim(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createTensorDim(builder, size, nameOffset) {
        TensorDim.startTensorDim(builder);
        TensorDim.addSize(builder, size);
        TensorDim.addName(builder, nameOffset);
        return TensorDim.endTensorDim(builder);
    }
}
exports.TensorDim = TensorDim;

//# sourceMappingURL=tensor-dim.js.map


/***/ }),
/* 105 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Tensor = void 0;
const flatbuffers = __webpack_require__(57);
const buffer_js_1 = __webpack_require__(67);
const tensor_dim_js_1 = __webpack_require__(104);
const type_js_1 = __webpack_require__(76);
class Tensor {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsTensor(bb, obj) {
        return (obj || new Tensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsTensor(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Tensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    typeType() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : type_js_1.Type.NONE;
    }
    /**
     * The type of data contained in a value cell. Currently only fixed-width
     * value types are supported, no strings or nested types
     */
    type(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    /**
     * The dimensions of the tensor, optionally named
     */
    shape(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new tensor_dim_js_1.TensorDim()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    shapeLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * Non-negative byte offsets to advance one value cell along each dimension
     * If omitted, default to row-major order (C-like).
     */
    strides(index) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8) : BigInt(0);
    }
    stridesLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * The location and size of the tensor's data
     */
    data(obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? (obj || new buffer_js_1.Buffer()).__init(this.bb_pos + offset, this.bb) : null;
    }
    static startTensor(builder) {
        builder.startObject(5);
    }
    static addTypeType(builder, typeType) {
        builder.addFieldInt8(0, typeType, type_js_1.Type.NONE);
    }
    static addType(builder, typeOffset) {
        builder.addFieldOffset(1, typeOffset, 0);
    }
    static addShape(builder, shapeOffset) {
        builder.addFieldOffset(2, shapeOffset, 0);
    }
    static createShapeVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startShapeVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addStrides(builder, stridesOffset) {
        builder.addFieldOffset(3, stridesOffset, 0);
    }
    static createStridesVector(builder, data) {
        builder.startVector(8, data.length, 8);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt64(data[i]);
        }
        return builder.endVector();
    }
    static startStridesVector(builder, numElems) {
        builder.startVector(8, numElems, 8);
    }
    static addData(builder, dataOffset) {
        builder.addFieldStruct(4, dataOffset, 0);
    }
    static endTensor(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 6); // type
        builder.requiredField(offset, 8); // shape
        builder.requiredField(offset, 12); // data
        return offset;
    }
    static finishTensorBuffer(builder, offset) {
        builder.finish(offset);
    }
    static finishSizePrefixedTensorBuffer(builder, offset) {
        builder.finish(offset, undefined, true);
    }
}
exports.Tensor = Tensor;

//# sourceMappingURL=tensor.js.map


/***/ }),
/* 106 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createElementComparator = exports.wrapIndex = exports.clampRange = void 0;
const vector_js_1 = __webpack_require__(47);
const map_js_1 = __webpack_require__(107);
const struct_js_1 = __webpack_require__(114);
const buffer_js_1 = __webpack_require__(43);
/** @ignore */
let tmp;
/** @ignore */
function clampRange(source, begin, end, then) {
    // Adjust args similar to Array.prototype.slice. Normalize begin/end to
    // clamp between 0 and length, and wrap around on negative indices, e.g.
    // slice(-1, 5) or slice(5, -1)
    const { length: len = 0 } = source;
    let lhs = typeof begin !== 'number' ? 0 : begin;
    let rhs = typeof end !== 'number' ? len : end;
    // wrap around on negative start/end positions
    (lhs < 0) && (lhs = ((lhs % len) + len) % len);
    (rhs < 0) && (rhs = ((rhs % len) + len) % len);
    // ensure lhs <= rhs
    (rhs < lhs) && (tmp = lhs, lhs = rhs, rhs = tmp);
    // ensure rhs <= length
    (rhs > len) && (rhs = len);
    return then ? then(source, lhs, rhs) : [lhs, rhs];
}
exports.clampRange = clampRange;
/** @ignore */
const wrapIndex = (index, len) => index < 0 ? (len + index) : index;
exports.wrapIndex = wrapIndex;
const isNaNFast = (value) => value !== value;
/** @ignore */
function createElementComparator(search) {
    const typeofSearch = typeof search;
    // Compare primitives
    if (typeofSearch !== 'object' || search === null) {
        // Compare NaN
        if (isNaNFast(search)) {
            return isNaNFast;
        }
        return (value) => value === search;
    }
    // Compare Dates
    if (search instanceof Date) {
        const valueOfSearch = search.valueOf();
        return (value) => value instanceof Date ? (value.valueOf() === valueOfSearch) : false;
    }
    // Compare TypedArrays
    if (ArrayBuffer.isView(search)) {
        return (value) => value ? (0, buffer_js_1.compareArrayLike)(search, value) : false;
    }
    // Compare Maps and Rows
    if (search instanceof Map) {
        return createMapComparator(search);
    }
    // Compare Array-likes
    if (Array.isArray(search)) {
        return createArrayLikeComparator(search);
    }
    // Compare Vectors
    if (search instanceof vector_js_1.Vector) {
        return createVectorComparator(search);
    }
    return createObjectComparator(search, true);
    // Compare non-empty Objects
    // return createObjectComparator(search, search instanceof Proxy);
}
exports.createElementComparator = createElementComparator;
/** @ignore */
function createArrayLikeComparator(lhs) {
    const comparators = [];
    for (let i = -1, n = lhs.length; ++i < n;) {
        comparators[i] = createElementComparator(lhs[i]);
    }
    return createSubElementsComparator(comparators);
}
/** @ignore */
function createMapComparator(lhs) {
    let i = -1;
    const comparators = [];
    for (const v of lhs.values())
        comparators[++i] = createElementComparator(v);
    return createSubElementsComparator(comparators);
}
/** @ignore */
function createVectorComparator(lhs) {
    const comparators = [];
    for (let i = -1, n = lhs.length; ++i < n;) {
        comparators[i] = createElementComparator(lhs.get(i));
    }
    return createSubElementsComparator(comparators);
}
/** @ignore */
function createObjectComparator(lhs, allowEmpty = false) {
    const keys = Object.keys(lhs);
    // Only compare non-empty Objects
    if (!allowEmpty && keys.length === 0) {
        return () => false;
    }
    const comparators = [];
    for (let i = -1, n = keys.length; ++i < n;) {
        comparators[i] = createElementComparator(lhs[keys[i]]);
    }
    return createSubElementsComparator(comparators, keys);
}
function createSubElementsComparator(comparators, keys) {
    return (rhs) => {
        if (!rhs || typeof rhs !== 'object') {
            return false;
        }
        switch (rhs.constructor) {
            case Array: return compareArray(comparators, rhs);
            case Map:
                return compareObject(comparators, rhs, rhs.keys());
            case map_js_1.MapRow:
            case struct_js_1.StructRow:
            case Object:
            case undefined: // support `Object.create(null)` objects
                return compareObject(comparators, rhs, keys || Object.keys(rhs));
        }
        return rhs instanceof vector_js_1.Vector ? compareVector(comparators, rhs) : false;
    };
}
function compareArray(comparators, arr) {
    const n = comparators.length;
    if (arr.length !== n) {
        return false;
    }
    for (let i = -1; ++i < n;) {
        if (!(comparators[i](arr[i]))) {
            return false;
        }
    }
    return true;
}
function compareVector(comparators, vec) {
    const n = comparators.length;
    if (vec.length !== n) {
        return false;
    }
    for (let i = -1; ++i < n;) {
        if (!(comparators[i](vec.get(i)))) {
            return false;
        }
    }
    return true;
}
function compareObject(comparators, obj, keys) {
    const lKeyItr = keys[Symbol.iterator]();
    const rKeyItr = obj instanceof Map ? obj.keys() : Object.keys(obj)[Symbol.iterator]();
    const rValItr = obj instanceof Map ? obj.values() : Object.values(obj)[Symbol.iterator]();
    let i = 0;
    const n = comparators.length;
    let rVal = rValItr.next();
    let lKey = lKeyItr.next();
    let rKey = rKeyItr.next();
    for (; i < n && !lKey.done && !rKey.done && !rVal.done; ++i, lKey = lKeyItr.next(), rKey = rKeyItr.next(), rVal = rValItr.next()) {
        if (lKey.value !== rKey.value || !comparators[i](rVal.value)) {
            break;
        }
    }
    if (i === n && lKey.done && rKey.done && rVal.done) {
        return true;
    }
    lKeyItr.return && lKeyItr.return();
    rKeyItr.return && rKeyItr.return();
    rValItr.return && rValItr.return();
    return false;
}

//# sourceMappingURL=vector.js.map


/***/ }),
/* 107 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MapRow = exports._kKeysAsStrings = exports.kKeysAsStrings = exports.kVals = exports.kKeys = void 0;
const vector_js_1 = __webpack_require__(47);
const pretty_js_1 = __webpack_require__(108);
const get_js_1 = __webpack_require__(109);
const set_js_1 = __webpack_require__(115);
/** @ignore */ exports.kKeys = Symbol.for('keys');
/** @ignore */ exports.kVals = Symbol.for('vals');
/** @ignore */ exports.kKeysAsStrings = Symbol.for('kKeysAsStrings');
/** @ignore */ exports._kKeysAsStrings = Symbol.for('_kKeysAsStrings');
class MapRow {
    constructor(slice) {
        this[exports.kKeys] = new vector_js_1.Vector([slice.children[0]]).memoize();
        this[exports.kVals] = slice.children[1];
        return new Proxy(this, new MapRowProxyHandler());
    }
    /** @ignore */
    get [exports.kKeysAsStrings]() {
        return this[exports._kKeysAsStrings] || (this[exports._kKeysAsStrings] = Array.from(this[exports.kKeys].toArray(), String));
    }
    [Symbol.iterator]() {
        return new MapRowIterator(this[exports.kKeys], this[exports.kVals]);
    }
    get size() { return this[exports.kKeys].length; }
    toArray() { return Object.values(this.toJSON()); }
    toJSON() {
        const keys = this[exports.kKeys];
        const vals = this[exports.kVals];
        const json = {};
        for (let i = -1, n = keys.length; ++i < n;) {
            json[keys.get(i)] = get_js_1.instance.visit(vals, i);
        }
        return json;
    }
    toString() {
        return `{${[...this].map(([key, val]) => `${(0, pretty_js_1.valueToString)(key)}: ${(0, pretty_js_1.valueToString)(val)}`).join(', ')}}`;
    }
    [Symbol.for('nodejs.util.inspect.custom')]() {
        return this.toString();
    }
}
exports.MapRow = MapRow;
class MapRowIterator {
    constructor(keys, vals) {
        this.keys = keys;
        this.vals = vals;
        this.keyIndex = 0;
        this.numKeys = keys.length;
    }
    [Symbol.iterator]() { return this; }
    next() {
        const i = this.keyIndex;
        if (i === this.numKeys) {
            return { done: true, value: null };
        }
        this.keyIndex++;
        return {
            done: false,
            value: [
                this.keys.get(i),
                get_js_1.instance.visit(this.vals, i),
            ]
        };
    }
}
/** @ignore */
class MapRowProxyHandler {
    isExtensible() { return false; }
    deleteProperty() { return false; }
    preventExtensions() { return true; }
    ownKeys(row) {
        return row[exports.kKeysAsStrings];
    }
    has(row, key) {
        return row[exports.kKeysAsStrings].includes(key);
    }
    getOwnPropertyDescriptor(row, key) {
        const idx = row[exports.kKeysAsStrings].indexOf(key);
        if (idx !== -1) {
            return { writable: true, enumerable: true, configurable: true };
        }
        return;
    }
    get(row, key) {
        // Look up key in row first
        if (Reflect.has(row, key)) {
            return row[key];
        }
        const idx = row[exports.kKeysAsStrings].indexOf(key);
        if (idx !== -1) {
            const val = get_js_1.instance.visit(Reflect.get(row, exports.kVals), idx);
            // Cache key/val lookups
            Reflect.set(row, key, val);
            return val;
        }
    }
    set(row, key, val) {
        const idx = row[exports.kKeysAsStrings].indexOf(key);
        if (idx !== -1) {
            set_js_1.instance.visit(Reflect.get(row, exports.kVals), idx, val);
            // Cache key/val lookups
            return Reflect.set(row, key, val);
        }
        else if (Reflect.has(row, key)) {
            return Reflect.set(row, key, val);
        }
        return false;
    }
}
Object.defineProperties(MapRow.prototype, {
    [Symbol.toStringTag]: { enumerable: false, configurable: false, value: 'Row' },
    [exports.kKeys]: { writable: true, enumerable: false, configurable: false, value: null },
    [exports.kVals]: { writable: true, enumerable: false, configurable: false, value: null },
    [exports._kKeysAsStrings]: { writable: true, enumerable: false, configurable: false, value: null },
});

//# sourceMappingURL=map.js.map


/***/ }),
/* 108 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.valueToString = void 0;
/** @ignore */ const undf = void (0);
/** @ignore */
function valueToString(x) {
    if (x === null) {
        return 'null';
    }
    if (x === undf) {
        return 'undefined';
    }
    switch (typeof x) {
        case 'number': return `${x}`;
        case 'bigint': return `${x}`;
        case 'string': return `"${x}"`;
    }
    // If [Symbol.toPrimitive] is implemented (like in BN)
    // use it instead of JSON.stringify(). This ensures we
    // print BigInts, Decimals, and Binary in their native
    // representation
    if (typeof x[Symbol.toPrimitive] === 'function') {
        return x[Symbol.toPrimitive]('string');
    }
    if (ArrayBuffer.isView(x)) {
        if (x instanceof BigInt64Array || x instanceof BigUint64Array) {
            return `[${[...x].map(x => valueToString(x))}]`;
        }
        return `[${x}]`;
    }
    return ArrayBuffer.isView(x) ? `[${x}]` : JSON.stringify(x, (_, y) => typeof y === 'bigint' ? `${y}` : y);
}
exports.valueToString = valueToString;

//# sourceMappingURL=pretty.js.map


/***/ }),
/* 109 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.instance = exports.GetVisitor = void 0;
const bn_js_1 = __webpack_require__(110);
const vector_js_1 = __webpack_require__(47);
const visitor_js_1 = __webpack_require__(112);
const map_js_1 = __webpack_require__(107);
const struct_js_1 = __webpack_require__(114);
const bigint_js_1 = __webpack_require__(111);
const utf8_js_1 = __webpack_require__(44);
const math_js_1 = __webpack_require__(116);
const enum_js_1 = __webpack_require__(48);
/** @ignore */
class GetVisitor extends visitor_js_1.Visitor {
}
exports.GetVisitor = GetVisitor;
/** @ignore */
function wrapGet(fn) {
    return (data, _1) => data.getValid(_1) ? fn(data, _1) : null;
}
/** @ignore */ const epochDaysToMs = (data, index) => 86400000 * data[index];
/** @ignore */
const getNull = (_data, _index) => null;
/** @ignore */
const getVariableWidthBytes = (values, valueOffsets, index) => {
    if (index + 1 >= valueOffsets.length) {
        return null;
    }
    const x = (0, bigint_js_1.bigIntToNumber)(valueOffsets[index]);
    const y = (0, bigint_js_1.bigIntToNumber)(valueOffsets[index + 1]);
    return values.subarray(x, y);
};
/** @ignore */
const getBool = ({ offset, values }, index) => {
    const idx = offset + index;
    const byte = values[idx >> 3];
    return (byte & 1 << (idx % 8)) !== 0;
};
/** @ignore */
const getDateDay = ({ values }, index) => epochDaysToMs(values, index);
/** @ignore */
const getDateMillisecond = ({ values }, index) => (0, bigint_js_1.bigIntToNumber)(values[index]);
/** @ignore */
const getNumeric = ({ stride, values }, index) => values[stride * index];
/** @ignore */
const getFloat16 = ({ stride, values }, index) => (0, math_js_1.uint16ToFloat64)(values[stride * index]);
/** @ignore */
const getBigInts = ({ values }, index) => values[index];
/** @ignore */
const getFixedSizeBinary = ({ stride, values }, index) => values.subarray(stride * index, stride * (index + 1));
/** @ignore */
const getBinary = ({ values, valueOffsets }, index) => getVariableWidthBytes(values, valueOffsets, index);
/** @ignore */
const getUtf8 = ({ values, valueOffsets }, index) => {
    const bytes = getVariableWidthBytes(values, valueOffsets, index);
    return bytes !== null ? (0, utf8_js_1.decodeUtf8)(bytes) : null;
};
/* istanbul ignore next */
/** @ignore */
const getInt = ({ values }, index) => values[index];
/* istanbul ignore next */
/** @ignore */
const getFloat = ({ type, values }, index) => (type.precision !== enum_js_1.Precision.HALF ? values[index] : (0, math_js_1.uint16ToFloat64)(values[index]));
/* istanbul ignore next */
/** @ignore */
const getDate = (data, index) => (data.type.unit === enum_js_1.DateUnit.DAY
    ? getDateDay(data, index)
    : getDateMillisecond(data, index));
/** @ignore */
const getTimestampSecond = ({ values }, index) => 1000 * (0, bigint_js_1.bigIntToNumber)(values[index]);
/** @ignore */
const getTimestampMillisecond = ({ values }, index) => (0, bigint_js_1.bigIntToNumber)(values[index]);
/** @ignore */
const getTimestampMicrosecond = ({ values }, index) => (0, bigint_js_1.divideBigInts)(values[index], BigInt(1000));
/** @ignore */
const getTimestampNanosecond = ({ values }, index) => (0, bigint_js_1.divideBigInts)(values[index], BigInt(1000000));
/* istanbul ignore next */
/** @ignore */
const getTimestamp = (data, index) => {
    switch (data.type.unit) {
        case enum_js_1.TimeUnit.SECOND: return getTimestampSecond(data, index);
        case enum_js_1.TimeUnit.MILLISECOND: return getTimestampMillisecond(data, index);
        case enum_js_1.TimeUnit.MICROSECOND: return getTimestampMicrosecond(data, index);
        case enum_js_1.TimeUnit.NANOSECOND: return getTimestampNanosecond(data, index);
    }
};
/** @ignore */
const getTimeSecond = ({ values }, index) => values[index];
/** @ignore */
const getTimeMillisecond = ({ values }, index) => values[index];
/** @ignore */
const getTimeMicrosecond = ({ values }, index) => values[index];
/** @ignore */
const getTimeNanosecond = ({ values }, index) => values[index];
/* istanbul ignore next */
/** @ignore */
const getTime = (data, index) => {
    switch (data.type.unit) {
        case enum_js_1.TimeUnit.SECOND: return getTimeSecond(data, index);
        case enum_js_1.TimeUnit.MILLISECOND: return getTimeMillisecond(data, index);
        case enum_js_1.TimeUnit.MICROSECOND: return getTimeMicrosecond(data, index);
        case enum_js_1.TimeUnit.NANOSECOND: return getTimeNanosecond(data, index);
    }
};
/** @ignore */
const getDecimal = ({ values, stride }, index) => bn_js_1.BN.decimal(values.subarray(stride * index, stride * (index + 1)));
/** @ignore */
const getList = (data, index) => {
    const { valueOffsets, stride, children } = data;
    const { [index * stride]: begin, [index * stride + 1]: end } = valueOffsets;
    const child = children[0];
    const slice = child.slice(begin, end - begin);
    return new vector_js_1.Vector([slice]);
};
/** @ignore */
const getMap = (data, index) => {
    const { valueOffsets, children } = data;
    const { [index]: begin, [index + 1]: end } = valueOffsets;
    const child = children[0];
    return new map_js_1.MapRow(child.slice(begin, end - begin));
};
/** @ignore */
const getStruct = (data, index) => {
    return new struct_js_1.StructRow(data, index);
};
/* istanbul ignore next */
/** @ignore */
const getUnion = (data, index) => {
    return data.type.mode === enum_js_1.UnionMode.Dense ?
        getDenseUnion(data, index) :
        getSparseUnion(data, index);
};
/** @ignore */
const getDenseUnion = (data, index) => {
    const childIndex = data.type.typeIdToChildIndex[data.typeIds[index]];
    const child = data.children[childIndex];
    return exports.instance.visit(child, data.valueOffsets[index]);
};
/** @ignore */
const getSparseUnion = (data, index) => {
    const childIndex = data.type.typeIdToChildIndex[data.typeIds[index]];
    const child = data.children[childIndex];
    return exports.instance.visit(child, index);
};
/** @ignore */
const getDictionary = (data, index) => {
    var _a;
    return (_a = data.dictionary) === null || _a === void 0 ? void 0 : _a.get(data.values[index]);
};
/* istanbul ignore next */
/** @ignore */
const getInterval = (data, index) => (data.type.unit === enum_js_1.IntervalUnit.DAY_TIME)
    ? getIntervalDayTime(data, index)
    : getIntervalYearMonth(data, index);
/** @ignore */
const getIntervalDayTime = ({ values }, index) => values.subarray(2 * index, 2 * (index + 1));
/** @ignore */
const getIntervalYearMonth = ({ values }, index) => {
    const interval = values[index];
    const int32s = new Int32Array(2);
    int32s[0] = Math.trunc(interval / 12); /* years */
    int32s[1] = Math.trunc(interval % 12); /* months */
    return int32s;
};
/** @ignore */
const getDurationSecond = ({ values }, index) => values[index];
/** @ignore */
const getDurationMillisecond = ({ values }, index) => values[index];
/** @ignore */
const getDurationMicrosecond = ({ values }, index) => values[index];
/** @ignore */
const getDurationNanosecond = ({ values }, index) => values[index];
/* istanbul ignore next */
/** @ignore */
const getDuration = (data, index) => {
    switch (data.type.unit) {
        case enum_js_1.TimeUnit.SECOND: return getDurationSecond(data, index);
        case enum_js_1.TimeUnit.MILLISECOND: return getDurationMillisecond(data, index);
        case enum_js_1.TimeUnit.MICROSECOND: return getDurationMicrosecond(data, index);
        case enum_js_1.TimeUnit.NANOSECOND: return getDurationNanosecond(data, index);
    }
};
/** @ignore */
const getFixedSizeList = (data, index) => {
    const { stride, children } = data;
    const child = children[0];
    const slice = child.slice(index * stride, stride);
    return new vector_js_1.Vector([slice]);
};
GetVisitor.prototype.visitNull = wrapGet(getNull);
GetVisitor.prototype.visitBool = wrapGet(getBool);
GetVisitor.prototype.visitInt = wrapGet(getInt);
GetVisitor.prototype.visitInt8 = wrapGet(getNumeric);
GetVisitor.prototype.visitInt16 = wrapGet(getNumeric);
GetVisitor.prototype.visitInt32 = wrapGet(getNumeric);
GetVisitor.prototype.visitInt64 = wrapGet(getBigInts);
GetVisitor.prototype.visitUint8 = wrapGet(getNumeric);
GetVisitor.prototype.visitUint16 = wrapGet(getNumeric);
GetVisitor.prototype.visitUint32 = wrapGet(getNumeric);
GetVisitor.prototype.visitUint64 = wrapGet(getBigInts);
GetVisitor.prototype.visitFloat = wrapGet(getFloat);
GetVisitor.prototype.visitFloat16 = wrapGet(getFloat16);
GetVisitor.prototype.visitFloat32 = wrapGet(getNumeric);
GetVisitor.prototype.visitFloat64 = wrapGet(getNumeric);
GetVisitor.prototype.visitUtf8 = wrapGet(getUtf8);
GetVisitor.prototype.visitLargeUtf8 = wrapGet(getUtf8);
GetVisitor.prototype.visitBinary = wrapGet(getBinary);
GetVisitor.prototype.visitLargeBinary = wrapGet(getBinary);
GetVisitor.prototype.visitFixedSizeBinary = wrapGet(getFixedSizeBinary);
GetVisitor.prototype.visitDate = wrapGet(getDate);
GetVisitor.prototype.visitDateDay = wrapGet(getDateDay);
GetVisitor.prototype.visitDateMillisecond = wrapGet(getDateMillisecond);
GetVisitor.prototype.visitTimestamp = wrapGet(getTimestamp);
GetVisitor.prototype.visitTimestampSecond = wrapGet(getTimestampSecond);
GetVisitor.prototype.visitTimestampMillisecond = wrapGet(getTimestampMillisecond);
GetVisitor.prototype.visitTimestampMicrosecond = wrapGet(getTimestampMicrosecond);
GetVisitor.prototype.visitTimestampNanosecond = wrapGet(getTimestampNanosecond);
GetVisitor.prototype.visitTime = wrapGet(getTime);
GetVisitor.prototype.visitTimeSecond = wrapGet(getTimeSecond);
GetVisitor.prototype.visitTimeMillisecond = wrapGet(getTimeMillisecond);
GetVisitor.prototype.visitTimeMicrosecond = wrapGet(getTimeMicrosecond);
GetVisitor.prototype.visitTimeNanosecond = wrapGet(getTimeNanosecond);
GetVisitor.prototype.visitDecimal = wrapGet(getDecimal);
GetVisitor.prototype.visitList = wrapGet(getList);
GetVisitor.prototype.visitStruct = wrapGet(getStruct);
GetVisitor.prototype.visitUnion = wrapGet(getUnion);
GetVisitor.prototype.visitDenseUnion = wrapGet(getDenseUnion);
GetVisitor.prototype.visitSparseUnion = wrapGet(getSparseUnion);
GetVisitor.prototype.visitDictionary = wrapGet(getDictionary);
GetVisitor.prototype.visitInterval = wrapGet(getInterval);
GetVisitor.prototype.visitIntervalDayTime = wrapGet(getIntervalDayTime);
GetVisitor.prototype.visitIntervalYearMonth = wrapGet(getIntervalYearMonth);
GetVisitor.prototype.visitDuration = wrapGet(getDuration);
GetVisitor.prototype.visitDurationSecond = wrapGet(getDurationSecond);
GetVisitor.prototype.visitDurationMillisecond = wrapGet(getDurationMillisecond);
GetVisitor.prototype.visitDurationMicrosecond = wrapGet(getDurationMicrosecond);
GetVisitor.prototype.visitDurationNanosecond = wrapGet(getDurationNanosecond);
GetVisitor.prototype.visitFixedSizeList = wrapGet(getFixedSizeList);
GetVisitor.prototype.visitMap = wrapGet(getMap);
/** @ignore */
exports.instance = new GetVisitor();

//# sourceMappingURL=get.js.map


/***/ }),
/* 110 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BN = exports.bigNumToBigInt = exports.bigNumToString = exports.bigNumToNumber = exports.isArrowBigNumSymbol = void 0;
const buffer_js_1 = __webpack_require__(43);
const bigint_js_1 = __webpack_require__(111);
/** @ignore */
exports.isArrowBigNumSymbol = Symbol.for('isArrowBigNum');
/** @ignore */
function BigNum(x, ...xs) {
    if (xs.length === 0) {
        return Object.setPrototypeOf((0, buffer_js_1.toArrayBufferView)(this['TypedArray'], x), this.constructor.prototype);
    }
    return Object.setPrototypeOf(new this['TypedArray'](x, ...xs), this.constructor.prototype);
}
BigNum.prototype[exports.isArrowBigNumSymbol] = true;
BigNum.prototype.toJSON = function () { return `"${bigNumToString(this)}"`; };
BigNum.prototype.valueOf = function (scale) { return bigNumToNumber(this, scale); };
BigNum.prototype.toString = function () { return bigNumToString(this); };
BigNum.prototype[Symbol.toPrimitive] = function (hint = 'default') {
    switch (hint) {
        case 'number': return bigNumToNumber(this);
        case 'string': return bigNumToString(this);
        case 'default': return bigNumToBigInt(this);
    }
    // @ts-ignore
    return bigNumToString(this);
};
/** @ignore */
function SignedBigNum(...args) { return BigNum.apply(this, args); }
/** @ignore */
function UnsignedBigNum(...args) { return BigNum.apply(this, args); }
/** @ignore */
function DecimalBigNum(...args) { return BigNum.apply(this, args); }
Object.setPrototypeOf(SignedBigNum.prototype, Object.create(Int32Array.prototype));
Object.setPrototypeOf(UnsignedBigNum.prototype, Object.create(Uint32Array.prototype));
Object.setPrototypeOf(DecimalBigNum.prototype, Object.create(Uint32Array.prototype));
Object.assign(SignedBigNum.prototype, BigNum.prototype, { 'constructor': SignedBigNum, 'signed': true, 'TypedArray': Int32Array, 'BigIntArray': BigInt64Array });
Object.assign(UnsignedBigNum.prototype, BigNum.prototype, { 'constructor': UnsignedBigNum, 'signed': false, 'TypedArray': Uint32Array, 'BigIntArray': BigUint64Array });
Object.assign(DecimalBigNum.prototype, BigNum.prototype, { 'constructor': DecimalBigNum, 'signed': true, 'TypedArray': Uint32Array, 'BigIntArray': BigUint64Array });
//FOR ES2020 COMPATIBILITY
const TWO_TO_THE_64 = BigInt(4294967296) * BigInt(4294967296); // 2^64 = 0x10000000000000000n
const TWO_TO_THE_64_MINUS_1 = TWO_TO_THE_64 - BigInt(1); // (2^32 * 2^32) - 1 = 0xFFFFFFFFFFFFFFFFn
/** @ignore */
function bigNumToNumber(bn, scale) {
    const { buffer, byteOffset, byteLength, 'signed': signed } = bn;
    const words = new BigUint64Array(buffer, byteOffset, byteLength / 8);
    const negative = signed && words.at(-1) & (BigInt(1) << BigInt(63));
    let number = BigInt(0);
    let i = 0;
    if (negative) {
        for (const word of words) {
            number |= (word ^ TWO_TO_THE_64_MINUS_1) * (BigInt(1) << BigInt(64 * i++));
        }
        number *= BigInt(-1);
        number -= BigInt(1);
    }
    else {
        for (const word of words) {
            number |= word * (BigInt(1) << BigInt(64 * i++));
        }
    }
    if (typeof scale === 'number') {
        const denominator = BigInt(Math.pow(10, scale));
        const quotient = number / denominator;
        const remainder = number % denominator;
        return (0, bigint_js_1.bigIntToNumber)(quotient) + ((0, bigint_js_1.bigIntToNumber)(remainder) / (0, bigint_js_1.bigIntToNumber)(denominator));
    }
    return (0, bigint_js_1.bigIntToNumber)(number);
}
exports.bigNumToNumber = bigNumToNumber;
/** @ignore */
function bigNumToString(a) {
    // use BigInt native implementation
    if (a.byteLength === 8) {
        const bigIntArray = new a['BigIntArray'](a.buffer, a.byteOffset, 1);
        return `${bigIntArray[0]}`;
    }
    // unsigned numbers
    if (!a['signed']) {
        return unsignedBigNumToString(a);
    }
    let array = new Uint16Array(a.buffer, a.byteOffset, a.byteLength / 2);
    // detect positive numbers
    const highOrderWord = new Int16Array([array.at(-1)])[0];
    if (highOrderWord >= 0) {
        return unsignedBigNumToString(a);
    }
    // flip the negative value
    array = array.slice();
    let carry = 1;
    for (let i = 0; i < array.length; i++) {
        const elem = array[i];
        const updated = ~elem + carry;
        array[i] = updated;
        carry &= elem === 0 ? 1 : 0;
    }
    const negated = unsignedBigNumToString(array);
    return `-${negated}`;
}
exports.bigNumToString = bigNumToString;
/** @ignore */
function bigNumToBigInt(a) {
    if (a.byteLength === 8) {
        const bigIntArray = new a['BigIntArray'](a.buffer, a.byteOffset, 1);
        return bigIntArray[0];
    }
    else {
        return bigNumToString(a);
    }
}
exports.bigNumToBigInt = bigNumToBigInt;
/** @ignore */
function unsignedBigNumToString(a) {
    let digits = '';
    const base64 = new Uint32Array(2);
    let base32 = new Uint16Array(a.buffer, a.byteOffset, a.byteLength / 2);
    const checks = new Uint32Array((base32 = new Uint16Array(base32).reverse()).buffer);
    let i = -1;
    const n = base32.length - 1;
    do {
        for (base64[0] = base32[i = 0]; i < n;) {
            base32[i++] = base64[1] = base64[0] / 10;
            base64[0] = ((base64[0] - base64[1] * 10) << 16) + base32[i];
        }
        base32[i] = base64[1] = base64[0] / 10;
        base64[0] = base64[0] - base64[1] * 10;
        digits = `${base64[0]}${digits}`;
    } while (checks[0] || checks[1] || checks[2] || checks[3]);
    return digits !== null && digits !== void 0 ? digits : `0`;
}
/** @ignore */
class BN {
    /** @nocollapse */
    static new(num, isSigned) {
        switch (isSigned) {
            case true: return new SignedBigNum(num);
            case false: return new UnsignedBigNum(num);
        }
        switch (num.constructor) {
            case Int8Array:
            case Int16Array:
            case Int32Array:
            case BigInt64Array:
                return new SignedBigNum(num);
        }
        if (num.byteLength === 16) {
            return new DecimalBigNum(num);
        }
        return new UnsignedBigNum(num);
    }
    /** @nocollapse */
    static signed(num) {
        return new SignedBigNum(num);
    }
    /** @nocollapse */
    static unsigned(num) {
        return new UnsignedBigNum(num);
    }
    /** @nocollapse */
    static decimal(num) {
        return new DecimalBigNum(num);
    }
    constructor(num, isSigned) {
        return BN.new(num, isSigned);
    }
}
exports.BN = BN;

//# sourceMappingURL=bn.js.map


/***/ }),
/* 111 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.divideBigInts = exports.bigIntToNumber = void 0;
/**
 * Converts an integer as a number or bigint to a number, throwing an error if the input cannot safely be represented as a number.
 */
function bigIntToNumber(number) {
    if (typeof number === 'bigint' && (number < Number.MIN_SAFE_INTEGER || number > Number.MAX_SAFE_INTEGER)) {
        throw new TypeError(`${number} is not safe to convert to a number.`);
    }
    return Number(number);
}
exports.bigIntToNumber = bigIntToNumber;
/**
 * Duivides the bigint number by the divisor and returns the result as a number.
 * Dividing bigints always results in bigints so we don't get the remainder.
 * This function gives us the remainder but assumes that the result fits into a number.
 *
 * @param number The number to divide.
 * @param divisor The divisor.
 * @returns The result of the division as a number.
 */
function divideBigInts(number, divisor) {
    return bigIntToNumber(number / divisor) + bigIntToNumber(number % divisor) / bigIntToNumber(divisor);
}
exports.divideBigInts = divideBigInts;

//# sourceMappingURL=bigint.js.map


/***/ }),
/* 112 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Visitor = void 0;
const enum_js_1 = __webpack_require__(48);
const type_js_1 = __webpack_require__(113);
class Visitor {
    visitMany(nodes, ...args) {
        return nodes.map((node, i) => this.visit(node, ...args.map((x) => x[i])));
    }
    visit(...args) {
        return this.getVisitFn(args[0], false).apply(this, args);
    }
    getVisitFn(node, throwIfNotFound = true) {
        return getVisitFn(this, node, throwIfNotFound);
    }
    getVisitFnByTypeId(typeId, throwIfNotFound = true) {
        return getVisitFnByTypeId(this, typeId, throwIfNotFound);
    }
    visitNull(_node, ..._args) { return null; }
    visitBool(_node, ..._args) { return null; }
    visitInt(_node, ..._args) { return null; }
    visitFloat(_node, ..._args) { return null; }
    visitUtf8(_node, ..._args) { return null; }
    visitLargeUtf8(_node, ..._args) { return null; }
    visitBinary(_node, ..._args) { return null; }
    visitLargeBinary(_node, ..._args) { return null; }
    visitFixedSizeBinary(_node, ..._args) { return null; }
    visitDate(_node, ..._args) { return null; }
    visitTimestamp(_node, ..._args) { return null; }
    visitTime(_node, ..._args) { return null; }
    visitDecimal(_node, ..._args) { return null; }
    visitList(_node, ..._args) { return null; }
    visitStruct(_node, ..._args) { return null; }
    visitUnion(_node, ..._args) { return null; }
    visitDictionary(_node, ..._args) { return null; }
    visitInterval(_node, ..._args) { return null; }
    visitDuration(_node, ..._args) { return null; }
    visitFixedSizeList(_node, ..._args) { return null; }
    visitMap(_node, ..._args) { return null; }
}
exports.Visitor = Visitor;
/** @ignore */
function getVisitFn(visitor, node, throwIfNotFound = true) {
    if (typeof node === 'number') {
        return getVisitFnByTypeId(visitor, node, throwIfNotFound);
    }
    if (typeof node === 'string' && (node in enum_js_1.Type)) {
        return getVisitFnByTypeId(visitor, enum_js_1.Type[node], throwIfNotFound);
    }
    if (node && (node instanceof type_js_1.DataType)) {
        return getVisitFnByTypeId(visitor, inferDType(node), throwIfNotFound);
    }
    if ((node === null || node === void 0 ? void 0 : node.type) && (node.type instanceof type_js_1.DataType)) {
        return getVisitFnByTypeId(visitor, inferDType(node.type), throwIfNotFound);
    }
    return getVisitFnByTypeId(visitor, enum_js_1.Type.NONE, throwIfNotFound);
}
/** @ignore */
function getVisitFnByTypeId(visitor, dtype, throwIfNotFound = true) {
    let fn = null;
    switch (dtype) {
        case enum_js_1.Type.Null:
            fn = visitor.visitNull;
            break;
        case enum_js_1.Type.Bool:
            fn = visitor.visitBool;
            break;
        case enum_js_1.Type.Int:
            fn = visitor.visitInt;
            break;
        case enum_js_1.Type.Int8:
            fn = visitor.visitInt8 || visitor.visitInt;
            break;
        case enum_js_1.Type.Int16:
            fn = visitor.visitInt16 || visitor.visitInt;
            break;
        case enum_js_1.Type.Int32:
            fn = visitor.visitInt32 || visitor.visitInt;
            break;
        case enum_js_1.Type.Int64:
            fn = visitor.visitInt64 || visitor.visitInt;
            break;
        case enum_js_1.Type.Uint8:
            fn = visitor.visitUint8 || visitor.visitInt;
            break;
        case enum_js_1.Type.Uint16:
            fn = visitor.visitUint16 || visitor.visitInt;
            break;
        case enum_js_1.Type.Uint32:
            fn = visitor.visitUint32 || visitor.visitInt;
            break;
        case enum_js_1.Type.Uint64:
            fn = visitor.visitUint64 || visitor.visitInt;
            break;
        case enum_js_1.Type.Float:
            fn = visitor.visitFloat;
            break;
        case enum_js_1.Type.Float16:
            fn = visitor.visitFloat16 || visitor.visitFloat;
            break;
        case enum_js_1.Type.Float32:
            fn = visitor.visitFloat32 || visitor.visitFloat;
            break;
        case enum_js_1.Type.Float64:
            fn = visitor.visitFloat64 || visitor.visitFloat;
            break;
        case enum_js_1.Type.Utf8:
            fn = visitor.visitUtf8;
            break;
        case enum_js_1.Type.LargeUtf8:
            fn = visitor.visitLargeUtf8;
            break;
        case enum_js_1.Type.Binary:
            fn = visitor.visitBinary;
            break;
        case enum_js_1.Type.LargeBinary:
            fn = visitor.visitLargeBinary;
            break;
        case enum_js_1.Type.FixedSizeBinary:
            fn = visitor.visitFixedSizeBinary;
            break;
        case enum_js_1.Type.Date:
            fn = visitor.visitDate;
            break;
        case enum_js_1.Type.DateDay:
            fn = visitor.visitDateDay || visitor.visitDate;
            break;
        case enum_js_1.Type.DateMillisecond:
            fn = visitor.visitDateMillisecond || visitor.visitDate;
            break;
        case enum_js_1.Type.Timestamp:
            fn = visitor.visitTimestamp;
            break;
        case enum_js_1.Type.TimestampSecond:
            fn = visitor.visitTimestampSecond || visitor.visitTimestamp;
            break;
        case enum_js_1.Type.TimestampMillisecond:
            fn = visitor.visitTimestampMillisecond || visitor.visitTimestamp;
            break;
        case enum_js_1.Type.TimestampMicrosecond:
            fn = visitor.visitTimestampMicrosecond || visitor.visitTimestamp;
            break;
        case enum_js_1.Type.TimestampNanosecond:
            fn = visitor.visitTimestampNanosecond || visitor.visitTimestamp;
            break;
        case enum_js_1.Type.Time:
            fn = visitor.visitTime;
            break;
        case enum_js_1.Type.TimeSecond:
            fn = visitor.visitTimeSecond || visitor.visitTime;
            break;
        case enum_js_1.Type.TimeMillisecond:
            fn = visitor.visitTimeMillisecond || visitor.visitTime;
            break;
        case enum_js_1.Type.TimeMicrosecond:
            fn = visitor.visitTimeMicrosecond || visitor.visitTime;
            break;
        case enum_js_1.Type.TimeNanosecond:
            fn = visitor.visitTimeNanosecond || visitor.visitTime;
            break;
        case enum_js_1.Type.Decimal:
            fn = visitor.visitDecimal;
            break;
        case enum_js_1.Type.List:
            fn = visitor.visitList;
            break;
        case enum_js_1.Type.Struct:
            fn = visitor.visitStruct;
            break;
        case enum_js_1.Type.Union:
            fn = visitor.visitUnion;
            break;
        case enum_js_1.Type.DenseUnion:
            fn = visitor.visitDenseUnion || visitor.visitUnion;
            break;
        case enum_js_1.Type.SparseUnion:
            fn = visitor.visitSparseUnion || visitor.visitUnion;
            break;
        case enum_js_1.Type.Dictionary:
            fn = visitor.visitDictionary;
            break;
        case enum_js_1.Type.Interval:
            fn = visitor.visitInterval;
            break;
        case enum_js_1.Type.IntervalDayTime:
            fn = visitor.visitIntervalDayTime || visitor.visitInterval;
            break;
        case enum_js_1.Type.IntervalYearMonth:
            fn = visitor.visitIntervalYearMonth || visitor.visitInterval;
            break;
        case enum_js_1.Type.Duration:
            fn = visitor.visitDuration;
            break;
        case enum_js_1.Type.DurationSecond:
            fn = visitor.visitDurationSecond || visitor.visitDuration;
            break;
        case enum_js_1.Type.DurationMillisecond:
            fn = visitor.visitDurationMillisecond || visitor.visitDuration;
            break;
        case enum_js_1.Type.DurationMicrosecond:
            fn = visitor.visitDurationMicrosecond || visitor.visitDuration;
            break;
        case enum_js_1.Type.DurationNanosecond:
            fn = visitor.visitDurationNanosecond || visitor.visitDuration;
            break;
        case enum_js_1.Type.FixedSizeList:
            fn = visitor.visitFixedSizeList;
            break;
        case enum_js_1.Type.Map:
            fn = visitor.visitMap;
            break;
    }
    if (typeof fn === 'function')
        return fn;
    if (!throwIfNotFound)
        return () => null;
    throw new Error(`Unrecognized type '${enum_js_1.Type[dtype]}'`);
}
/** @ignore */
function inferDType(type) {
    switch (type.typeId) {
        case enum_js_1.Type.Null: return enum_js_1.Type.Null;
        case enum_js_1.Type.Int: {
            const { bitWidth, isSigned } = type;
            switch (bitWidth) {
                case 8: return isSigned ? enum_js_1.Type.Int8 : enum_js_1.Type.Uint8;
                case 16: return isSigned ? enum_js_1.Type.Int16 : enum_js_1.Type.Uint16;
                case 32: return isSigned ? enum_js_1.Type.Int32 : enum_js_1.Type.Uint32;
                case 64: return isSigned ? enum_js_1.Type.Int64 : enum_js_1.Type.Uint64;
            }
            // @ts-ignore
            return enum_js_1.Type.Int;
        }
        case enum_js_1.Type.Float:
            switch (type.precision) {
                case enum_js_1.Precision.HALF: return enum_js_1.Type.Float16;
                case enum_js_1.Precision.SINGLE: return enum_js_1.Type.Float32;
                case enum_js_1.Precision.DOUBLE: return enum_js_1.Type.Float64;
            }
            // @ts-ignore
            return enum_js_1.Type.Float;
        case enum_js_1.Type.Binary: return enum_js_1.Type.Binary;
        case enum_js_1.Type.LargeBinary: return enum_js_1.Type.LargeBinary;
        case enum_js_1.Type.Utf8: return enum_js_1.Type.Utf8;
        case enum_js_1.Type.LargeUtf8: return enum_js_1.Type.LargeUtf8;
        case enum_js_1.Type.Bool: return enum_js_1.Type.Bool;
        case enum_js_1.Type.Decimal: return enum_js_1.Type.Decimal;
        case enum_js_1.Type.Time:
            switch (type.unit) {
                case enum_js_1.TimeUnit.SECOND: return enum_js_1.Type.TimeSecond;
                case enum_js_1.TimeUnit.MILLISECOND: return enum_js_1.Type.TimeMillisecond;
                case enum_js_1.TimeUnit.MICROSECOND: return enum_js_1.Type.TimeMicrosecond;
                case enum_js_1.TimeUnit.NANOSECOND: return enum_js_1.Type.TimeNanosecond;
            }
            // @ts-ignore
            return enum_js_1.Type.Time;
        case enum_js_1.Type.Timestamp:
            switch (type.unit) {
                case enum_js_1.TimeUnit.SECOND: return enum_js_1.Type.TimestampSecond;
                case enum_js_1.TimeUnit.MILLISECOND: return enum_js_1.Type.TimestampMillisecond;
                case enum_js_1.TimeUnit.MICROSECOND: return enum_js_1.Type.TimestampMicrosecond;
                case enum_js_1.TimeUnit.NANOSECOND: return enum_js_1.Type.TimestampNanosecond;
            }
            // @ts-ignore
            return enum_js_1.Type.Timestamp;
        case enum_js_1.Type.Date:
            switch (type.unit) {
                case enum_js_1.DateUnit.DAY: return enum_js_1.Type.DateDay;
                case enum_js_1.DateUnit.MILLISECOND: return enum_js_1.Type.DateMillisecond;
            }
            // @ts-ignore
            return enum_js_1.Type.Date;
        case enum_js_1.Type.Interval:
            switch (type.unit) {
                case enum_js_1.IntervalUnit.DAY_TIME: return enum_js_1.Type.IntervalDayTime;
                case enum_js_1.IntervalUnit.YEAR_MONTH: return enum_js_1.Type.IntervalYearMonth;
            }
            // @ts-ignore
            return enum_js_1.Type.Interval;
        case enum_js_1.Type.Duration:
            switch (type.unit) {
                case enum_js_1.TimeUnit.SECOND: return enum_js_1.Type.DurationSecond;
                case enum_js_1.TimeUnit.MILLISECOND: return enum_js_1.Type.DurationMillisecond;
                case enum_js_1.TimeUnit.MICROSECOND: return enum_js_1.Type.DurationMicrosecond;
                case enum_js_1.TimeUnit.NANOSECOND: return enum_js_1.Type.DurationNanosecond;
            }
            // @ts-ignore
            return enum_js_1.Type.Duration;
        case enum_js_1.Type.Map: return enum_js_1.Type.Map;
        case enum_js_1.Type.List: return enum_js_1.Type.List;
        case enum_js_1.Type.Struct: return enum_js_1.Type.Struct;
        case enum_js_1.Type.Union:
            switch (type.mode) {
                case enum_js_1.UnionMode.Dense: return enum_js_1.Type.DenseUnion;
                case enum_js_1.UnionMode.Sparse: return enum_js_1.Type.SparseUnion;
            }
            // @ts-ignore
            return enum_js_1.Type.Union;
        case enum_js_1.Type.FixedSizeBinary: return enum_js_1.Type.FixedSizeBinary;
        case enum_js_1.Type.FixedSizeList: return enum_js_1.Type.FixedSizeList;
        case enum_js_1.Type.Dictionary: return enum_js_1.Type.Dictionary;
    }
    throw new Error(`Unrecognized type '${enum_js_1.Type[type.typeId]}'`);
}
// Add these here so they're picked up by the externs creator
// in the build, and closure-compiler doesn't minify them away
Visitor.prototype.visitInt8 = null;
Visitor.prototype.visitInt16 = null;
Visitor.prototype.visitInt32 = null;
Visitor.prototype.visitInt64 = null;
Visitor.prototype.visitUint8 = null;
Visitor.prototype.visitUint16 = null;
Visitor.prototype.visitUint32 = null;
Visitor.prototype.visitUint64 = null;
Visitor.prototype.visitFloat16 = null;
Visitor.prototype.visitFloat32 = null;
Visitor.prototype.visitFloat64 = null;
Visitor.prototype.visitDateDay = null;
Visitor.prototype.visitDateMillisecond = null;
Visitor.prototype.visitTimestampSecond = null;
Visitor.prototype.visitTimestampMillisecond = null;
Visitor.prototype.visitTimestampMicrosecond = null;
Visitor.prototype.visitTimestampNanosecond = null;
Visitor.prototype.visitTimeSecond = null;
Visitor.prototype.visitTimeMillisecond = null;
Visitor.prototype.visitTimeMicrosecond = null;
Visitor.prototype.visitTimeNanosecond = null;
Visitor.prototype.visitDenseUnion = null;
Visitor.prototype.visitSparseUnion = null;
Visitor.prototype.visitIntervalDayTime = null;
Visitor.prototype.visitIntervalYearMonth = null;
Visitor.prototype.visitDuration = null;
Visitor.prototype.visitDurationSecond = null;
Visitor.prototype.visitDurationMillisecond = null;
Visitor.prototype.visitDurationMicrosecond = null;
Visitor.prototype.visitDurationNanosecond = null;

//# sourceMappingURL=visitor.js.map


/***/ }),
/* 113 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Map_ = exports.FixedSizeList = exports.FixedSizeBinary = exports.SparseUnion = exports.DenseUnion = exports.Union = exports.Struct = exports.List = exports.DurationNanosecond = exports.DurationMicrosecond = exports.DurationMillisecond = exports.DurationSecond = exports.Duration = exports.IntervalYearMonth = exports.IntervalDayTime = exports.Interval = exports.TimestampNanosecond = exports.TimestampMicrosecond = exports.TimestampMillisecond = exports.TimestampSecond = exports.Timestamp = exports.TimeNanosecond = exports.TimeMicrosecond = exports.TimeMillisecond = exports.TimeSecond = exports.Time = exports.DateMillisecond = exports.DateDay = exports.Date_ = exports.Decimal = exports.Bool = exports.LargeUtf8 = exports.Utf8 = exports.LargeBinary = exports.Binary = exports.Float64 = exports.Float32 = exports.Float16 = exports.Float = exports.Uint64 = exports.Uint32 = exports.Uint16 = exports.Uint8 = exports.Int64 = exports.Int32 = exports.Int16 = exports.Int8 = exports.Int = exports.Null = exports.DataType = void 0;
exports.strideForType = exports.Dictionary = void 0;
const bigint_js_1 = __webpack_require__(111);
const enum_js_1 = __webpack_require__(48);
/**
 * An abstract base class for classes that encapsulate metadata about each of
 * the logical types that Arrow can represent.
 */
class DataType {
    /** @nocollapse */ static isNull(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Null; }
    /** @nocollapse */ static isInt(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Int; }
    /** @nocollapse */ static isFloat(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Float; }
    /** @nocollapse */ static isBinary(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Binary; }
    /** @nocollapse */ static isLargeBinary(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.LargeBinary; }
    /** @nocollapse */ static isUtf8(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Utf8; }
    /** @nocollapse */ static isLargeUtf8(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.LargeUtf8; }
    /** @nocollapse */ static isBool(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Bool; }
    /** @nocollapse */ static isDecimal(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Decimal; }
    /** @nocollapse */ static isDate(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Date; }
    /** @nocollapse */ static isTime(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Time; }
    /** @nocollapse */ static isTimestamp(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Timestamp; }
    /** @nocollapse */ static isInterval(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Interval; }
    /** @nocollapse */ static isDuration(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Duration; }
    /** @nocollapse */ static isList(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.List; }
    /** @nocollapse */ static isStruct(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Struct; }
    /** @nocollapse */ static isUnion(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Union; }
    /** @nocollapse */ static isFixedSizeBinary(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.FixedSizeBinary; }
    /** @nocollapse */ static isFixedSizeList(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.FixedSizeList; }
    /** @nocollapse */ static isMap(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Map; }
    /** @nocollapse */ static isDictionary(x) { return (x === null || x === void 0 ? void 0 : x.typeId) === enum_js_1.Type.Dictionary; }
    /** @nocollapse */ static isDenseUnion(x) { return DataType.isUnion(x) && x.mode === enum_js_1.UnionMode.Dense; }
    /** @nocollapse */ static isSparseUnion(x) { return DataType.isUnion(x) && x.mode === enum_js_1.UnionMode.Sparse; }
    constructor(typeId) {
        this.typeId = typeId;
    }
}
exports.DataType = DataType;
_a = Symbol.toStringTag;
DataType[_a] = ((proto) => {
    proto.children = null;
    proto.ArrayType = Array;
    proto.OffsetArrayType = Int32Array;
    return proto[Symbol.toStringTag] = 'DataType';
})(DataType.prototype);
/** @ignore */
class Null extends DataType {
    constructor() {
        super(enum_js_1.Type.Null);
    }
    toString() { return `Null`; }
}
exports.Null = Null;
_b = Symbol.toStringTag;
Null[_b] = ((proto) => proto[Symbol.toStringTag] = 'Null')(Null.prototype);
/** @ignore */
class Int_ extends DataType {
    constructor(isSigned, bitWidth) {
        super(enum_js_1.Type.Int);
        this.isSigned = isSigned;
        this.bitWidth = bitWidth;
    }
    get ArrayType() {
        switch (this.bitWidth) {
            case 8: return this.isSigned ? Int8Array : Uint8Array;
            case 16: return this.isSigned ? Int16Array : Uint16Array;
            case 32: return this.isSigned ? Int32Array : Uint32Array;
            case 64: return this.isSigned ? BigInt64Array : BigUint64Array;
        }
        throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
    }
    toString() { return `${this.isSigned ? `I` : `Ui`}nt${this.bitWidth}`; }
}
exports.Int = Int_;
_c = Symbol.toStringTag;
Int_[_c] = ((proto) => {
    proto.isSigned = null;
    proto.bitWidth = null;
    return proto[Symbol.toStringTag] = 'Int';
})(Int_.prototype);
/** @ignore */
class Int8 extends Int_ {
    constructor() { super(true, 8); }
    get ArrayType() { return Int8Array; }
}
exports.Int8 = Int8;
/** @ignore */
class Int16 extends Int_ {
    constructor() { super(true, 16); }
    get ArrayType() { return Int16Array; }
}
exports.Int16 = Int16;
/** @ignore */
class Int32 extends Int_ {
    constructor() { super(true, 32); }
    get ArrayType() { return Int32Array; }
}
exports.Int32 = Int32;
/** @ignore */
class Int64 extends Int_ {
    constructor() { super(true, 64); }
    get ArrayType() { return BigInt64Array; }
}
exports.Int64 = Int64;
/** @ignore */
class Uint8 extends Int_ {
    constructor() { super(false, 8); }
    get ArrayType() { return Uint8Array; }
}
exports.Uint8 = Uint8;
/** @ignore */
class Uint16 extends Int_ {
    constructor() { super(false, 16); }
    get ArrayType() { return Uint16Array; }
}
exports.Uint16 = Uint16;
/** @ignore */
class Uint32 extends Int_ {
    constructor() { super(false, 32); }
    get ArrayType() { return Uint32Array; }
}
exports.Uint32 = Uint32;
/** @ignore */
class Uint64 extends Int_ {
    constructor() { super(false, 64); }
    get ArrayType() { return BigUint64Array; }
}
exports.Uint64 = Uint64;
Object.defineProperty(Int8.prototype, 'ArrayType', { value: Int8Array });
Object.defineProperty(Int16.prototype, 'ArrayType', { value: Int16Array });
Object.defineProperty(Int32.prototype, 'ArrayType', { value: Int32Array });
Object.defineProperty(Int64.prototype, 'ArrayType', { value: BigInt64Array });
Object.defineProperty(Uint8.prototype, 'ArrayType', { value: Uint8Array });
Object.defineProperty(Uint16.prototype, 'ArrayType', { value: Uint16Array });
Object.defineProperty(Uint32.prototype, 'ArrayType', { value: Uint32Array });
Object.defineProperty(Uint64.prototype, 'ArrayType', { value: BigUint64Array });
/** @ignore */
class Float extends DataType {
    constructor(precision) {
        super(enum_js_1.Type.Float);
        this.precision = precision;
    }
    get ArrayType() {
        switch (this.precision) {
            case enum_js_1.Precision.HALF: return Uint16Array;
            case enum_js_1.Precision.SINGLE: return Float32Array;
            case enum_js_1.Precision.DOUBLE: return Float64Array;
        }
        // @ts-ignore
        throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
    }
    toString() { return `Float${(this.precision << 5) || 16}`; }
}
exports.Float = Float;
_d = Symbol.toStringTag;
Float[_d] = ((proto) => {
    proto.precision = null;
    return proto[Symbol.toStringTag] = 'Float';
})(Float.prototype);
/** @ignore */
class Float16 extends Float {
    constructor() { super(enum_js_1.Precision.HALF); }
}
exports.Float16 = Float16;
/** @ignore */
class Float32 extends Float {
    constructor() { super(enum_js_1.Precision.SINGLE); }
}
exports.Float32 = Float32;
/** @ignore */
class Float64 extends Float {
    constructor() { super(enum_js_1.Precision.DOUBLE); }
}
exports.Float64 = Float64;
Object.defineProperty(Float16.prototype, 'ArrayType', { value: Uint16Array });
Object.defineProperty(Float32.prototype, 'ArrayType', { value: Float32Array });
Object.defineProperty(Float64.prototype, 'ArrayType', { value: Float64Array });
/** @ignore */
class Binary extends DataType {
    constructor() {
        super(enum_js_1.Type.Binary);
    }
    toString() { return `Binary`; }
}
exports.Binary = Binary;
_e = Symbol.toStringTag;
Binary[_e] = ((proto) => {
    proto.ArrayType = Uint8Array;
    return proto[Symbol.toStringTag] = 'Binary';
})(Binary.prototype);
/** @ignore */
class LargeBinary extends DataType {
    constructor() {
        super(enum_js_1.Type.LargeBinary);
    }
    toString() { return `LargeBinary`; }
}
exports.LargeBinary = LargeBinary;
_f = Symbol.toStringTag;
LargeBinary[_f] = ((proto) => {
    proto.ArrayType = Uint8Array;
    proto.OffsetArrayType = BigInt64Array;
    return proto[Symbol.toStringTag] = 'LargeBinary';
})(LargeBinary.prototype);
/** @ignore */
class Utf8 extends DataType {
    constructor() {
        super(enum_js_1.Type.Utf8);
    }
    toString() { return `Utf8`; }
}
exports.Utf8 = Utf8;
_g = Symbol.toStringTag;
Utf8[_g] = ((proto) => {
    proto.ArrayType = Uint8Array;
    return proto[Symbol.toStringTag] = 'Utf8';
})(Utf8.prototype);
/** @ignore */
class LargeUtf8 extends DataType {
    constructor() {
        super(enum_js_1.Type.LargeUtf8);
    }
    toString() { return `LargeUtf8`; }
}
exports.LargeUtf8 = LargeUtf8;
_h = Symbol.toStringTag;
LargeUtf8[_h] = ((proto) => {
    proto.ArrayType = Uint8Array;
    proto.OffsetArrayType = BigInt64Array;
    return proto[Symbol.toStringTag] = 'LargeUtf8';
})(LargeUtf8.prototype);
/** @ignore */
class Bool extends DataType {
    constructor() {
        super(enum_js_1.Type.Bool);
    }
    toString() { return `Bool`; }
}
exports.Bool = Bool;
_j = Symbol.toStringTag;
Bool[_j] = ((proto) => {
    proto.ArrayType = Uint8Array;
    return proto[Symbol.toStringTag] = 'Bool';
})(Bool.prototype);
/** @ignore */
class Decimal extends DataType {
    constructor(scale, precision, bitWidth = 128) {
        super(enum_js_1.Type.Decimal);
        this.scale = scale;
        this.precision = precision;
        this.bitWidth = bitWidth;
    }
    toString() { return `Decimal[${this.precision}e${this.scale > 0 ? `+` : ``}${this.scale}]`; }
}
exports.Decimal = Decimal;
_k = Symbol.toStringTag;
Decimal[_k] = ((proto) => {
    proto.scale = null;
    proto.precision = null;
    proto.ArrayType = Uint32Array;
    return proto[Symbol.toStringTag] = 'Decimal';
})(Decimal.prototype);
/** @ignore */
class Date_ extends DataType {
    constructor(unit) {
        super(enum_js_1.Type.Date);
        this.unit = unit;
    }
    toString() { return `Date${(this.unit + 1) * 32}<${enum_js_1.DateUnit[this.unit]}>`; }
    get ArrayType() {
        return this.unit === enum_js_1.DateUnit.DAY ? Int32Array : BigInt64Array;
    }
}
exports.Date_ = Date_;
_l = Symbol.toStringTag;
Date_[_l] = ((proto) => {
    proto.unit = null;
    return proto[Symbol.toStringTag] = 'Date';
})(Date_.prototype);
/** @ignore */
class DateDay extends Date_ {
    constructor() { super(enum_js_1.DateUnit.DAY); }
}
exports.DateDay = DateDay;
/**
 * A signed 64-bit date representing the elapsed time since UNIX epoch (1970-01-01) in milliseconds.
 * According to the specification, this should be treated as the number of days, in milliseconds,  since the UNIX epoch.
 * Therefore, values must be evenly divisible by `86_400_000` (the number of milliseconds in a standard day).
 *
 * Practically, validation that values of this type are evenly divisible by `86_400_000` is not enforced by this library
 * for performance and usability reasons.
 *
 * Users should prefer to use {@link DateDay} to cleanly represent the number of days. For JS dates,
 * {@link TimestampMillisecond} is the preferred type.
 *
 * @ignore
 */
class DateMillisecond extends Date_ {
    constructor() { super(enum_js_1.DateUnit.MILLISECOND); }
}
exports.DateMillisecond = DateMillisecond;
/** @ignore */
class Time_ extends DataType {
    constructor(unit, bitWidth) {
        super(enum_js_1.Type.Time);
        this.unit = unit;
        this.bitWidth = bitWidth;
    }
    toString() { return `Time${this.bitWidth}<${enum_js_1.TimeUnit[this.unit]}>`; }
    get ArrayType() {
        switch (this.bitWidth) {
            case 32: return Int32Array;
            case 64: return BigInt64Array;
        }
        // @ts-ignore
        throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
    }
}
exports.Time = Time_;
_m = Symbol.toStringTag;
Time_[_m] = ((proto) => {
    proto.unit = null;
    proto.bitWidth = null;
    return proto[Symbol.toStringTag] = 'Time';
})(Time_.prototype);
/** @ignore */
class TimeSecond extends Time_ {
    constructor() { super(enum_js_1.TimeUnit.SECOND, 32); }
}
exports.TimeSecond = TimeSecond;
/** @ignore */
class TimeMillisecond extends Time_ {
    constructor() { super(enum_js_1.TimeUnit.MILLISECOND, 32); }
}
exports.TimeMillisecond = TimeMillisecond;
/** @ignore */
class TimeMicrosecond extends Time_ {
    constructor() { super(enum_js_1.TimeUnit.MICROSECOND, 64); }
}
exports.TimeMicrosecond = TimeMicrosecond;
/** @ignore */
class TimeNanosecond extends Time_ {
    constructor() { super(enum_js_1.TimeUnit.NANOSECOND, 64); }
}
exports.TimeNanosecond = TimeNanosecond;
/** @ignore */
class Timestamp_ extends DataType {
    constructor(unit, timezone) {
        super(enum_js_1.Type.Timestamp);
        this.unit = unit;
        this.timezone = timezone;
    }
    toString() { return `Timestamp<${enum_js_1.TimeUnit[this.unit]}${this.timezone ? `, ${this.timezone}` : ``}>`; }
}
exports.Timestamp = Timestamp_;
_o = Symbol.toStringTag;
Timestamp_[_o] = ((proto) => {
    proto.unit = null;
    proto.timezone = null;
    proto.ArrayType = BigInt64Array;
    return proto[Symbol.toStringTag] = 'Timestamp';
})(Timestamp_.prototype);
/** @ignore */
class TimestampSecond extends Timestamp_ {
    constructor(timezone) { super(enum_js_1.TimeUnit.SECOND, timezone); }
}
exports.TimestampSecond = TimestampSecond;
/** @ignore */
class TimestampMillisecond extends Timestamp_ {
    constructor(timezone) { super(enum_js_1.TimeUnit.MILLISECOND, timezone); }
}
exports.TimestampMillisecond = TimestampMillisecond;
/** @ignore */
class TimestampMicrosecond extends Timestamp_ {
    constructor(timezone) { super(enum_js_1.TimeUnit.MICROSECOND, timezone); }
}
exports.TimestampMicrosecond = TimestampMicrosecond;
/** @ignore */
class TimestampNanosecond extends Timestamp_ {
    constructor(timezone) { super(enum_js_1.TimeUnit.NANOSECOND, timezone); }
}
exports.TimestampNanosecond = TimestampNanosecond;
/** @ignore */
class Interval_ extends DataType {
    constructor(unit) {
        super(enum_js_1.Type.Interval);
        this.unit = unit;
    }
    toString() { return `Interval<${enum_js_1.IntervalUnit[this.unit]}>`; }
}
exports.Interval = Interval_;
_p = Symbol.toStringTag;
Interval_[_p] = ((proto) => {
    proto.unit = null;
    proto.ArrayType = Int32Array;
    return proto[Symbol.toStringTag] = 'Interval';
})(Interval_.prototype);
/** @ignore */
class IntervalDayTime extends Interval_ {
    constructor() { super(enum_js_1.IntervalUnit.DAY_TIME); }
}
exports.IntervalDayTime = IntervalDayTime;
/** @ignore */
class IntervalYearMonth extends Interval_ {
    constructor() { super(enum_js_1.IntervalUnit.YEAR_MONTH); }
}
exports.IntervalYearMonth = IntervalYearMonth;
/** @ignore */
class Duration extends DataType {
    constructor(unit) {
        super(enum_js_1.Type.Duration);
        this.unit = unit;
    }
    toString() { return `Duration<${enum_js_1.TimeUnit[this.unit]}>`; }
}
exports.Duration = Duration;
_q = Symbol.toStringTag;
Duration[_q] = ((proto) => {
    proto.unit = null;
    proto.ArrayType = BigInt64Array;
    return proto[Symbol.toStringTag] = 'Duration';
})(Duration.prototype);
/** @ignore */
class DurationSecond extends Duration {
    constructor() { super(enum_js_1.TimeUnit.SECOND); }
}
exports.DurationSecond = DurationSecond;
/** @ignore */
class DurationMillisecond extends Duration {
    constructor() { super(enum_js_1.TimeUnit.MILLISECOND); }
}
exports.DurationMillisecond = DurationMillisecond;
/** @ignore */
class DurationMicrosecond extends Duration {
    constructor() { super(enum_js_1.TimeUnit.MICROSECOND); }
}
exports.DurationMicrosecond = DurationMicrosecond;
/** @ignore */
class DurationNanosecond extends Duration {
    constructor() { super(enum_js_1.TimeUnit.NANOSECOND); }
}
exports.DurationNanosecond = DurationNanosecond;
/** @ignore */
class List extends DataType {
    constructor(child) {
        super(enum_js_1.Type.List);
        this.children = [child];
    }
    toString() { return `List<${this.valueType}>`; }
    get valueType() { return this.children[0].type; }
    get valueField() { return this.children[0]; }
    get ArrayType() { return this.valueType.ArrayType; }
}
exports.List = List;
_r = Symbol.toStringTag;
List[_r] = ((proto) => {
    proto.children = null;
    return proto[Symbol.toStringTag] = 'List';
})(List.prototype);
/** @ignore */
class Struct extends DataType {
    constructor(children) {
        super(enum_js_1.Type.Struct);
        this.children = children;
    }
    toString() { return `Struct<{${this.children.map((f) => `${f.name}:${f.type}`).join(`, `)}}>`; }
}
exports.Struct = Struct;
_s = Symbol.toStringTag;
Struct[_s] = ((proto) => {
    proto.children = null;
    return proto[Symbol.toStringTag] = 'Struct';
})(Struct.prototype);
/** @ignore */
class Union_ extends DataType {
    constructor(mode, typeIds, children) {
        super(enum_js_1.Type.Union);
        this.mode = mode;
        this.children = children;
        this.typeIds = typeIds = Int32Array.from(typeIds);
        this.typeIdToChildIndex = typeIds.reduce((typeIdToChildIndex, typeId, idx) => (typeIdToChildIndex[typeId] = idx) && typeIdToChildIndex || typeIdToChildIndex, Object.create(null));
    }
    toString() {
        return `${this[Symbol.toStringTag]}<${this.children.map((x) => `${x.type}`).join(` | `)}>`;
    }
}
exports.Union = Union_;
_t = Symbol.toStringTag;
Union_[_t] = ((proto) => {
    proto.mode = null;
    proto.typeIds = null;
    proto.children = null;
    proto.typeIdToChildIndex = null;
    proto.ArrayType = Int8Array;
    return proto[Symbol.toStringTag] = 'Union';
})(Union_.prototype);
/** @ignore */
class DenseUnion extends Union_ {
    constructor(typeIds, children) {
        super(enum_js_1.UnionMode.Dense, typeIds, children);
    }
}
exports.DenseUnion = DenseUnion;
/** @ignore */
class SparseUnion extends Union_ {
    constructor(typeIds, children) {
        super(enum_js_1.UnionMode.Sparse, typeIds, children);
    }
}
exports.SparseUnion = SparseUnion;
/** @ignore */
class FixedSizeBinary extends DataType {
    constructor(byteWidth) {
        super(enum_js_1.Type.FixedSizeBinary);
        this.byteWidth = byteWidth;
    }
    toString() { return `FixedSizeBinary[${this.byteWidth}]`; }
}
exports.FixedSizeBinary = FixedSizeBinary;
_u = Symbol.toStringTag;
FixedSizeBinary[_u] = ((proto) => {
    proto.byteWidth = null;
    proto.ArrayType = Uint8Array;
    return proto[Symbol.toStringTag] = 'FixedSizeBinary';
})(FixedSizeBinary.prototype);
/** @ignore */
class FixedSizeList extends DataType {
    constructor(listSize, child) {
        super(enum_js_1.Type.FixedSizeList);
        this.listSize = listSize;
        this.children = [child];
    }
    get valueType() { return this.children[0].type; }
    get valueField() { return this.children[0]; }
    get ArrayType() { return this.valueType.ArrayType; }
    toString() { return `FixedSizeList[${this.listSize}]<${this.valueType}>`; }
}
exports.FixedSizeList = FixedSizeList;
_v = Symbol.toStringTag;
FixedSizeList[_v] = ((proto) => {
    proto.children = null;
    proto.listSize = null;
    return proto[Symbol.toStringTag] = 'FixedSizeList';
})(FixedSizeList.prototype);
/** @ignore */
class Map_ extends DataType {
    constructor(entries, keysSorted = false) {
        var _y, _z, _0;
        super(enum_js_1.Type.Map);
        this.children = [entries];
        this.keysSorted = keysSorted;
        // ARROW-8716
        // https://github.com/apache/arrow/issues/17168
        if (entries) {
            entries['name'] = 'entries';
            if ((_y = entries === null || entries === void 0 ? void 0 : entries.type) === null || _y === void 0 ? void 0 : _y.children) {
                const key = (_z = entries === null || entries === void 0 ? void 0 : entries.type) === null || _z === void 0 ? void 0 : _z.children[0];
                if (key) {
                    key['name'] = 'key';
                }
                const val = (_0 = entries === null || entries === void 0 ? void 0 : entries.type) === null || _0 === void 0 ? void 0 : _0.children[1];
                if (val) {
                    val['name'] = 'value';
                }
            }
        }
    }
    get keyType() { return this.children[0].type.children[0].type; }
    get valueType() { return this.children[0].type.children[1].type; }
    get childType() { return this.children[0].type; }
    toString() { return `Map<{${this.children[0].type.children.map((f) => `${f.name}:${f.type}`).join(`, `)}}>`; }
}
exports.Map_ = Map_;
_w = Symbol.toStringTag;
Map_[_w] = ((proto) => {
    proto.children = null;
    proto.keysSorted = null;
    return proto[Symbol.toStringTag] = 'Map_';
})(Map_.prototype);
/** @ignore */
const getId = ((atomicDictionaryId) => () => ++atomicDictionaryId)(-1);
/** @ignore */
class Dictionary extends DataType {
    constructor(dictionary, indices, id, isOrdered) {
        super(enum_js_1.Type.Dictionary);
        this.indices = indices;
        this.dictionary = dictionary;
        this.isOrdered = isOrdered || false;
        this.id = id == null ? getId() : (0, bigint_js_1.bigIntToNumber)(id);
    }
    get children() { return this.dictionary.children; }
    get valueType() { return this.dictionary; }
    get ArrayType() { return this.dictionary.ArrayType; }
    toString() { return `Dictionary<${this.indices}, ${this.dictionary}>`; }
}
exports.Dictionary = Dictionary;
_x = Symbol.toStringTag;
Dictionary[_x] = ((proto) => {
    proto.id = null;
    proto.indices = null;
    proto.isOrdered = null;
    proto.dictionary = null;
    return proto[Symbol.toStringTag] = 'Dictionary';
})(Dictionary.prototype);
/** @ignore */
function strideForType(type) {
    const t = type;
    switch (type.typeId) {
        case enum_js_1.Type.Decimal: return type.bitWidth / 32;
        case enum_js_1.Type.Interval: return 1 + t.unit;
        // case Type.Int: return 1 + +((t as Int_).bitWidth > 32);
        // case Type.Time: return 1 + +((t as Time_).bitWidth > 32);
        case enum_js_1.Type.FixedSizeList: return t.listSize;
        case enum_js_1.Type.FixedSizeBinary: return t.byteWidth;
        default: return 1;
    }
}
exports.strideForType = strideForType;

//# sourceMappingURL=type.js.map


/***/ }),
/* 114 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StructRow = void 0;
const pretty_js_1 = __webpack_require__(108);
const get_js_1 = __webpack_require__(109);
const set_js_1 = __webpack_require__(115);
/** @ignore */ const kParent = Symbol.for('parent');
/** @ignore */ const kRowIndex = Symbol.for('rowIndex');
class StructRow {
    constructor(parent, rowIndex) {
        this[kParent] = parent;
        this[kRowIndex] = rowIndex;
        return new Proxy(this, structRowProxyHandler);
    }
    toArray() { return Object.values(this.toJSON()); }
    toJSON() {
        const i = this[kRowIndex];
        const parent = this[kParent];
        const keys = parent.type.children;
        const json = {};
        for (let j = -1, n = keys.length; ++j < n;) {
            json[keys[j].name] = get_js_1.instance.visit(parent.children[j], i);
        }
        return json;
    }
    toString() {
        return `{${[...this].map(([key, val]) => `${(0, pretty_js_1.valueToString)(key)}: ${(0, pretty_js_1.valueToString)(val)}`).join(', ')}}`;
    }
    [Symbol.for('nodejs.util.inspect.custom')]() {
        return this.toString();
    }
    [Symbol.iterator]() {
        return new StructRowIterator(this[kParent], this[kRowIndex]);
    }
}
exports.StructRow = StructRow;
class StructRowIterator {
    constructor(data, rowIndex) {
        this.childIndex = 0;
        this.children = data.children;
        this.rowIndex = rowIndex;
        this.childFields = data.type.children;
        this.numChildren = this.childFields.length;
    }
    [Symbol.iterator]() { return this; }
    next() {
        const i = this.childIndex;
        if (i < this.numChildren) {
            this.childIndex = i + 1;
            return {
                done: false,
                value: [
                    this.childFields[i].name,
                    get_js_1.instance.visit(this.children[i], this.rowIndex)
                ]
            };
        }
        return { done: true, value: null };
    }
}
Object.defineProperties(StructRow.prototype, {
    [Symbol.toStringTag]: { enumerable: false, configurable: false, value: 'Row' },
    [kParent]: { writable: true, enumerable: false, configurable: false, value: null },
    [kRowIndex]: { writable: true, enumerable: false, configurable: false, value: -1 },
});
class StructRowProxyHandler {
    isExtensible() { return false; }
    deleteProperty() { return false; }
    preventExtensions() { return true; }
    ownKeys(row) {
        return row[kParent].type.children.map((f) => f.name);
    }
    has(row, key) {
        return row[kParent].type.children.some((f) => f.name === key);
    }
    getOwnPropertyDescriptor(row, key) {
        if (row[kParent].type.children.some((f) => f.name === key)) {
            return { writable: true, enumerable: true, configurable: true };
        }
        return;
    }
    get(row, key) {
        // Look up key in row first
        if (Reflect.has(row, key)) {
            return row[key];
        }
        const idx = row[kParent].type.children.findIndex((f) => f.name === key);
        if (idx !== -1) {
            const val = get_js_1.instance.visit(row[kParent].children[idx], row[kRowIndex]);
            // Cache key/val lookups
            Reflect.set(row, key, val);
            return val;
        }
    }
    set(row, key, val) {
        const idx = row[kParent].type.children.findIndex((f) => f.name === key);
        if (idx !== -1) {
            set_js_1.instance.visit(row[kParent].children[idx], row[kRowIndex], val);
            // Cache key/val lookups
            return Reflect.set(row, key, val);
        }
        else if (Reflect.has(row, key) || typeof key === 'symbol') {
            return Reflect.set(row, key, val);
        }
        return false;
    }
}
const structRowProxyHandler = new StructRowProxyHandler();

//# sourceMappingURL=struct.js.map


/***/ }),
/* 115 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.instance = exports.setDuration = exports.setDurationNanosecond = exports.setDurationMicrosecond = exports.setDurationMillisecond = exports.setDurationSecond = exports.setIntervalYearMonth = exports.setIntervalDayTime = exports.setIntervalValue = exports.setDecimal = exports.setTime = exports.setTimeNanosecond = exports.setTimeMicrosecond = exports.setTimeMillisecond = exports.setTimeSecond = exports.setTimestamp = exports.setTimestampNanosecond = exports.setTimestampMicrosecond = exports.setTimestampMillisecond = exports.setTimestampSecond = exports.setDate = exports.setFixedSizeBinary = exports.setDateMillisecond = exports.setDateDay = exports.setAnyFloat = exports.setFloat16 = exports.setFloat = exports.setInt = exports.setVariableWidthBytes = exports.setEpochMsToDays = exports.SetVisitor = void 0;
const vector_js_1 = __webpack_require__(47);
const visitor_js_1 = __webpack_require__(112);
const bigint_js_1 = __webpack_require__(111);
const utf8_js_1 = __webpack_require__(44);
const math_js_1 = __webpack_require__(116);
const enum_js_1 = __webpack_require__(48);
/** @ignore */
class SetVisitor extends visitor_js_1.Visitor {
}
exports.SetVisitor = SetVisitor;
/** @ignore */
function wrapSet(fn) {
    return (data, _1, _2) => {
        if (data.setValid(_1, _2 != null)) {
            return fn(data, _1, _2);
        }
    };
}
/** @ignore */
const setEpochMsToDays = (data, index, epochMs) => { data[index] = Math.floor(epochMs / 86400000); };
exports.setEpochMsToDays = setEpochMsToDays;
/** @ignore */
const setVariableWidthBytes = (values, valueOffsets, index, value) => {
    if (index + 1 < valueOffsets.length) {
        const x = (0, bigint_js_1.bigIntToNumber)(valueOffsets[index]);
        const y = (0, bigint_js_1.bigIntToNumber)(valueOffsets[index + 1]);
        values.set(value.subarray(0, y - x), x);
    }
};
exports.setVariableWidthBytes = setVariableWidthBytes;
/** @ignore */
const setBool = ({ offset, values }, index, val) => {
    const idx = offset + index;
    val ? (values[idx >> 3] |= (1 << (idx % 8))) // true
        : (values[idx >> 3] &= ~(1 << (idx % 8))); // false
};
/** @ignore */
const setInt = ({ values }, index, value) => { values[index] = value; };
exports.setInt = setInt;
/** @ignore */
const setFloat = ({ values }, index, value) => { values[index] = value; };
exports.setFloat = setFloat;
/** @ignore */
const setFloat16 = ({ values }, index, value) => { values[index] = (0, math_js_1.float64ToUint16)(value); };
exports.setFloat16 = setFloat16;
/* istanbul ignore next */
/** @ignore */
const setAnyFloat = (data, index, value) => {
    switch (data.type.precision) {
        case enum_js_1.Precision.HALF:
            return (0, exports.setFloat16)(data, index, value);
        case enum_js_1.Precision.SINGLE:
        case enum_js_1.Precision.DOUBLE:
            return (0, exports.setFloat)(data, index, value);
    }
};
exports.setAnyFloat = setAnyFloat;
/** @ignore */
const setDateDay = ({ values }, index, value) => { (0, exports.setEpochMsToDays)(values, index, value.valueOf()); };
exports.setDateDay = setDateDay;
/** @ignore */
const setDateMillisecond = ({ values }, index, value) => { values[index] = BigInt(value); };
exports.setDateMillisecond = setDateMillisecond;
/** @ignore */
const setFixedSizeBinary = ({ stride, values }, index, value) => { values.set(value.subarray(0, stride), stride * index); };
exports.setFixedSizeBinary = setFixedSizeBinary;
/** @ignore */
const setBinary = ({ values, valueOffsets }, index, value) => (0, exports.setVariableWidthBytes)(values, valueOffsets, index, value);
/** @ignore */
const setUtf8 = ({ values, valueOffsets }, index, value) => (0, exports.setVariableWidthBytes)(values, valueOffsets, index, (0, utf8_js_1.encodeUtf8)(value));
/* istanbul ignore next */
const setDate = (data, index, value) => {
    data.type.unit === enum_js_1.DateUnit.DAY
        ? (0, exports.setDateDay)(data, index, value)
        : (0, exports.setDateMillisecond)(data, index, value);
};
exports.setDate = setDate;
/** @ignore */
const setTimestampSecond = ({ values }, index, value) => { values[index] = BigInt(value / 1000); };
exports.setTimestampSecond = setTimestampSecond;
/** @ignore */
const setTimestampMillisecond = ({ values }, index, value) => { values[index] = BigInt(value); };
exports.setTimestampMillisecond = setTimestampMillisecond;
/** @ignore */
const setTimestampMicrosecond = ({ values }, index, value) => { values[index] = BigInt(value * 1000); };
exports.setTimestampMicrosecond = setTimestampMicrosecond;
/** @ignore */
const setTimestampNanosecond = ({ values }, index, value) => { values[index] = BigInt(value * 1000000); };
exports.setTimestampNanosecond = setTimestampNanosecond;
/* istanbul ignore next */
/** @ignore */
const setTimestamp = (data, index, value) => {
    switch (data.type.unit) {
        case enum_js_1.TimeUnit.SECOND: return (0, exports.setTimestampSecond)(data, index, value);
        case enum_js_1.TimeUnit.MILLISECOND: return (0, exports.setTimestampMillisecond)(data, index, value);
        case enum_js_1.TimeUnit.MICROSECOND: return (0, exports.setTimestampMicrosecond)(data, index, value);
        case enum_js_1.TimeUnit.NANOSECOND: return (0, exports.setTimestampNanosecond)(data, index, value);
    }
};
exports.setTimestamp = setTimestamp;
/** @ignore */
const setTimeSecond = ({ values }, index, value) => { values[index] = value; };
exports.setTimeSecond = setTimeSecond;
/** @ignore */
const setTimeMillisecond = ({ values }, index, value) => { values[index] = value; };
exports.setTimeMillisecond = setTimeMillisecond;
/** @ignore */
const setTimeMicrosecond = ({ values }, index, value) => { values[index] = value; };
exports.setTimeMicrosecond = setTimeMicrosecond;
/** @ignore */
const setTimeNanosecond = ({ values }, index, value) => { values[index] = value; };
exports.setTimeNanosecond = setTimeNanosecond;
/* istanbul ignore next */
/** @ignore */
const setTime = (data, index, value) => {
    switch (data.type.unit) {
        case enum_js_1.TimeUnit.SECOND: return (0, exports.setTimeSecond)(data, index, value);
        case enum_js_1.TimeUnit.MILLISECOND: return (0, exports.setTimeMillisecond)(data, index, value);
        case enum_js_1.TimeUnit.MICROSECOND: return (0, exports.setTimeMicrosecond)(data, index, value);
        case enum_js_1.TimeUnit.NANOSECOND: return (0, exports.setTimeNanosecond)(data, index, value);
    }
};
exports.setTime = setTime;
/** @ignore */
const setDecimal = ({ values, stride }, index, value) => { values.set(value.subarray(0, stride), stride * index); };
exports.setDecimal = setDecimal;
/** @ignore */
const setList = (data, index, value) => {
    const values = data.children[0];
    const valueOffsets = data.valueOffsets;
    const set = exports.instance.getVisitFn(values);
    if (Array.isArray(value)) {
        for (let idx = -1, itr = valueOffsets[index], end = valueOffsets[index + 1]; itr < end;) {
            set(values, itr++, value[++idx]);
        }
    }
    else {
        for (let idx = -1, itr = valueOffsets[index], end = valueOffsets[index + 1]; itr < end;) {
            set(values, itr++, value.get(++idx));
        }
    }
};
/** @ignore */
const setMap = (data, index, value) => {
    const values = data.children[0];
    const { valueOffsets } = data;
    const set = exports.instance.getVisitFn(values);
    let { [index]: idx, [index + 1]: end } = valueOffsets;
    const entries = value instanceof Map ? value.entries() : Object.entries(value);
    for (const val of entries) {
        set(values, idx, val);
        if (++idx >= end)
            break;
    }
};
/** @ignore */ const _setStructArrayValue = (o, v) => (set, c, _, i) => c && set(c, o, v[i]);
/** @ignore */ const _setStructVectorValue = (o, v) => (set, c, _, i) => c && set(c, o, v.get(i));
/** @ignore */ const _setStructMapValue = (o, v) => (set, c, f, _) => c && set(c, o, v.get(f.name));
/** @ignore */ const _setStructObjectValue = (o, v) => (set, c, f, _) => c && set(c, o, v[f.name]);
/** @ignore */
const setStruct = (data, index, value) => {
    const childSetters = data.type.children.map((f) => exports.instance.getVisitFn(f.type));
    const set = value instanceof Map ? _setStructMapValue(index, value) :
        value instanceof vector_js_1.Vector ? _setStructVectorValue(index, value) :
            Array.isArray(value) ? _setStructArrayValue(index, value) :
                _setStructObjectValue(index, value);
    // eslint-disable-next-line unicorn/no-array-for-each
    data.type.children.forEach((f, i) => set(childSetters[i], data.children[i], f, i));
};
/* istanbul ignore next */
/** @ignore */
const setUnion = (data, index, value) => {
    data.type.mode === enum_js_1.UnionMode.Dense ?
        setDenseUnion(data, index, value) :
        setSparseUnion(data, index, value);
};
/** @ignore */
const setDenseUnion = (data, index, value) => {
    const childIndex = data.type.typeIdToChildIndex[data.typeIds[index]];
    const child = data.children[childIndex];
    exports.instance.visit(child, data.valueOffsets[index], value);
};
/** @ignore */
const setSparseUnion = (data, index, value) => {
    const childIndex = data.type.typeIdToChildIndex[data.typeIds[index]];
    const child = data.children[childIndex];
    exports.instance.visit(child, index, value);
};
/** @ignore */
const setDictionary = (data, index, value) => {
    var _a;
    (_a = data.dictionary) === null || _a === void 0 ? void 0 : _a.set(data.values[index], value);
};
/* istanbul ignore next */
/** @ignore */
const setIntervalValue = (data, index, value) => {
    (data.type.unit === enum_js_1.IntervalUnit.DAY_TIME)
        ? (0, exports.setIntervalDayTime)(data, index, value)
        : (0, exports.setIntervalYearMonth)(data, index, value);
};
exports.setIntervalValue = setIntervalValue;
/** @ignore */
const setIntervalDayTime = ({ values }, index, value) => { values.set(value.subarray(0, 2), 2 * index); };
exports.setIntervalDayTime = setIntervalDayTime;
/** @ignore */
const setIntervalYearMonth = ({ values }, index, value) => { values[index] = (value[0] * 12) + (value[1] % 12); };
exports.setIntervalYearMonth = setIntervalYearMonth;
/** @ignore */
const setDurationSecond = ({ values }, index, value) => { values[index] = value; };
exports.setDurationSecond = setDurationSecond;
/** @ignore */
const setDurationMillisecond = ({ values }, index, value) => { values[index] = value; };
exports.setDurationMillisecond = setDurationMillisecond;
/** @ignore */
const setDurationMicrosecond = ({ values }, index, value) => { values[index] = value; };
exports.setDurationMicrosecond = setDurationMicrosecond;
/** @ignore */
const setDurationNanosecond = ({ values }, index, value) => { values[index] = value; };
exports.setDurationNanosecond = setDurationNanosecond;
/* istanbul ignore next */
/** @ignore */
const setDuration = (data, index, value) => {
    switch (data.type.unit) {
        case enum_js_1.TimeUnit.SECOND: return (0, exports.setDurationSecond)(data, index, value);
        case enum_js_1.TimeUnit.MILLISECOND: return (0, exports.setDurationMillisecond)(data, index, value);
        case enum_js_1.TimeUnit.MICROSECOND: return (0, exports.setDurationMicrosecond)(data, index, value);
        case enum_js_1.TimeUnit.NANOSECOND: return (0, exports.setDurationNanosecond)(data, index, value);
    }
};
exports.setDuration = setDuration;
/** @ignore */
const setFixedSizeList = (data, index, value) => {
    const { stride } = data;
    const child = data.children[0];
    const set = exports.instance.getVisitFn(child);
    if (Array.isArray(value)) {
        for (let idx = -1, offset = index * stride; ++idx < stride;) {
            set(child, offset + idx, value[idx]);
        }
    }
    else {
        for (let idx = -1, offset = index * stride; ++idx < stride;) {
            set(child, offset + idx, value.get(idx));
        }
    }
};
SetVisitor.prototype.visitBool = wrapSet(setBool);
SetVisitor.prototype.visitInt = wrapSet(exports.setInt);
SetVisitor.prototype.visitInt8 = wrapSet(exports.setInt);
SetVisitor.prototype.visitInt16 = wrapSet(exports.setInt);
SetVisitor.prototype.visitInt32 = wrapSet(exports.setInt);
SetVisitor.prototype.visitInt64 = wrapSet(exports.setInt);
SetVisitor.prototype.visitUint8 = wrapSet(exports.setInt);
SetVisitor.prototype.visitUint16 = wrapSet(exports.setInt);
SetVisitor.prototype.visitUint32 = wrapSet(exports.setInt);
SetVisitor.prototype.visitUint64 = wrapSet(exports.setInt);
SetVisitor.prototype.visitFloat = wrapSet(exports.setAnyFloat);
SetVisitor.prototype.visitFloat16 = wrapSet(exports.setFloat16);
SetVisitor.prototype.visitFloat32 = wrapSet(exports.setFloat);
SetVisitor.prototype.visitFloat64 = wrapSet(exports.setFloat);
SetVisitor.prototype.visitUtf8 = wrapSet(setUtf8);
SetVisitor.prototype.visitLargeUtf8 = wrapSet(setUtf8);
SetVisitor.prototype.visitBinary = wrapSet(setBinary);
SetVisitor.prototype.visitLargeBinary = wrapSet(setBinary);
SetVisitor.prototype.visitFixedSizeBinary = wrapSet(exports.setFixedSizeBinary);
SetVisitor.prototype.visitDate = wrapSet(exports.setDate);
SetVisitor.prototype.visitDateDay = wrapSet(exports.setDateDay);
SetVisitor.prototype.visitDateMillisecond = wrapSet(exports.setDateMillisecond);
SetVisitor.prototype.visitTimestamp = wrapSet(exports.setTimestamp);
SetVisitor.prototype.visitTimestampSecond = wrapSet(exports.setTimestampSecond);
SetVisitor.prototype.visitTimestampMillisecond = wrapSet(exports.setTimestampMillisecond);
SetVisitor.prototype.visitTimestampMicrosecond = wrapSet(exports.setTimestampMicrosecond);
SetVisitor.prototype.visitTimestampNanosecond = wrapSet(exports.setTimestampNanosecond);
SetVisitor.prototype.visitTime = wrapSet(exports.setTime);
SetVisitor.prototype.visitTimeSecond = wrapSet(exports.setTimeSecond);
SetVisitor.prototype.visitTimeMillisecond = wrapSet(exports.setTimeMillisecond);
SetVisitor.prototype.visitTimeMicrosecond = wrapSet(exports.setTimeMicrosecond);
SetVisitor.prototype.visitTimeNanosecond = wrapSet(exports.setTimeNanosecond);
SetVisitor.prototype.visitDecimal = wrapSet(exports.setDecimal);
SetVisitor.prototype.visitList = wrapSet(setList);
SetVisitor.prototype.visitStruct = wrapSet(setStruct);
SetVisitor.prototype.visitUnion = wrapSet(setUnion);
SetVisitor.prototype.visitDenseUnion = wrapSet(setDenseUnion);
SetVisitor.prototype.visitSparseUnion = wrapSet(setSparseUnion);
SetVisitor.prototype.visitDictionary = wrapSet(setDictionary);
SetVisitor.prototype.visitInterval = wrapSet(exports.setIntervalValue);
SetVisitor.prototype.visitIntervalDayTime = wrapSet(exports.setIntervalDayTime);
SetVisitor.prototype.visitIntervalYearMonth = wrapSet(exports.setIntervalYearMonth);
SetVisitor.prototype.visitDuration = wrapSet(exports.setDuration);
SetVisitor.prototype.visitDurationSecond = wrapSet(exports.setDurationSecond);
SetVisitor.prototype.visitDurationMillisecond = wrapSet(exports.setDurationMillisecond);
SetVisitor.prototype.visitDurationMicrosecond = wrapSet(exports.setDurationMicrosecond);
SetVisitor.prototype.visitDurationNanosecond = wrapSet(exports.setDurationNanosecond);
SetVisitor.prototype.visitFixedSizeList = wrapSet(setFixedSizeList);
SetVisitor.prototype.visitMap = wrapSet(setMap);
/** @ignore */
exports.instance = new SetVisitor();

//# sourceMappingURL=set.js.map


/***/ }),
/* 116 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.float64ToUint16 = exports.uint16ToFloat64 = void 0;
const f64 = new Float64Array(1);
const u32 = new Uint32Array(f64.buffer);
/**
 * Convert uint16 (logically a float16) to a JS float64. Inspired by numpy's `npy_half_to_double`:
 * https://github.com/numpy/numpy/blob/5a5987291dc95376bb098be8d8e5391e89e77a2c/numpy/core/src/npymath/halffloat.c#L29
 * @param h {number} the uint16 to convert
 * @private
 * @ignore
 */
function uint16ToFloat64(h) {
    const expo = (h & 0x7C00) >> 10;
    const sigf = (h & 0x03FF) / 1024;
    const sign = Math.pow((-1), ((h & 0x8000) >> 15));
    switch (expo) {
        case 0x1F: return sign * (sigf ? Number.NaN : 1 / 0);
        case 0x00: return sign * (sigf ? 6.103515625e-5 * sigf : 0);
    }
    return sign * (Math.pow(2, (expo - 15))) * (1 + sigf);
}
exports.uint16ToFloat64 = uint16ToFloat64;
/**
 * Convert a float64 to uint16 (assuming the float64 is logically a float16). Inspired by numpy's `npy_double_to_half`:
 * https://github.com/numpy/numpy/blob/5a5987291dc95376bb098be8d8e5391e89e77a2c/numpy/core/src/npymath/halffloat.c#L43
 * @param d {number} The float64 to convert
 * @private
 * @ignore
 */
function float64ToUint16(d) {
    if (d !== d) {
        return 0x7E00;
    } // NaN
    f64[0] = d;
    // Magic numbers:
    // 0x80000000 = 10000000 00000000 00000000 00000000 -- masks the 32nd bit
    // 0x7ff00000 = 01111111 11110000 00000000 00000000 -- masks the 21st-31st bits
    // 0x000fffff = 00000000 00001111 11111111 11111111 -- masks the 1st-20th bit
    const sign = (u32[1] & 0x80000000) >> 16 & 0xFFFF;
    let expo = (u32[1] & 0x7FF00000), sigf = 0x0000;
    if (expo >= 0x40F00000) {
        //
        // If exponent overflowed, the float16 is either NaN or Infinity.
        // Rules to propagate the sign bit: mantissa > 0 ? NaN : +/-Infinity
        //
        // Magic numbers:
        // 0x40F00000 = 01000000 11110000 00000000 00000000 -- 6-bit exponent overflow
        // 0x7C000000 = 01111100 00000000 00000000 00000000 -- masks the 27th-31st bits
        //
        // returns:
        // qNaN, aka 32256 decimal, 0x7E00 hex, or 01111110 00000000 binary
        // sNaN, aka 32000 decimal, 0x7D00 hex, or 01111101 00000000 binary
        // +inf, aka 31744 decimal, 0x7C00 hex, or 01111100 00000000 binary
        // -inf, aka 64512 decimal, 0xFC00 hex, or 11111100 00000000 binary
        //
        // If mantissa is greater than 23 bits, set to +Infinity like numpy
        if (u32[0] > 0) {
            expo = 0x7C00;
        }
        else {
            expo = (expo & 0x7C000000) >> 16;
            sigf = (u32[1] & 0x000FFFFF) >> 10;
        }
    }
    else if (expo <= 0x3F000000) {
        //
        // If exponent underflowed, the float is either signed zero or subnormal.
        //
        // Magic numbers:
        // 0x3F000000 = 00111111 00000000 00000000 00000000 -- 6-bit exponent underflow
        //
        sigf = 0x100000 + (u32[1] & 0x000FFFFF);
        sigf = 0x100000 + (sigf << ((expo >> 20) - 998)) >> 21;
        expo = 0;
    }
    else {
        //
        // No overflow or underflow, rebase the exponent and round the mantissa
        // Magic numbers:
        // 0x200 = 00000010 00000000 -- masks off the 10th bit
        //
        // Ensure the first mantissa bit (the 10th one) is 1 and round
        expo = (expo - 0x3F000000) >> 10;
        sigf = ((u32[1] & 0x000FFFFF) + 0x200) >> 10;
    }
    return sign | expo | sigf & 0xFFFF;
}
exports.float64ToUint16 = float64ToUint16;

//# sourceMappingURL=math.js.map


/***/ }),
/* 117 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.makeData = exports.Data = exports.kUnknownNullCount = void 0;
const vector_js_1 = __webpack_require__(47);
const enum_js_1 = __webpack_require__(48);
const type_js_1 = __webpack_require__(113);
const bit_js_1 = __webpack_require__(118);
/** @ignore */ exports.kUnknownNullCount = -1;
/**
 * Data structure underlying {@link Vector}s. Use the convenience method {@link makeData}.
 */
class Data {
    get typeId() { return this.type.typeId; }
    get ArrayType() { return this.type.ArrayType; }
    get buffers() {
        return [this.valueOffsets, this.values, this.nullBitmap, this.typeIds];
    }
    get nullable() {
        if (this._nullCount !== 0) {
            const { type } = this;
            if (type_js_1.DataType.isSparseUnion(type)) {
                return this.children.some((child) => child.nullable);
            }
            else if (type_js_1.DataType.isDenseUnion(type)) {
                return this.children.some((child) => child.nullable);
            }
            return this.nullBitmap && this.nullBitmap.byteLength > 0;
        }
        return true;
    }
    get byteLength() {
        let byteLength = 0;
        const { valueOffsets, values, nullBitmap, typeIds } = this;
        valueOffsets && (byteLength += valueOffsets.byteLength);
        values && (byteLength += values.byteLength);
        nullBitmap && (byteLength += nullBitmap.byteLength);
        typeIds && (byteLength += typeIds.byteLength);
        return this.children.reduce((byteLength, child) => byteLength + child.byteLength, byteLength);
    }
    get nullCount() {
        if (type_js_1.DataType.isUnion(this.type)) {
            return this.children.reduce((nullCount, child) => nullCount + child.nullCount, 0);
        }
        let nullCount = this._nullCount;
        let nullBitmap;
        if (nullCount <= exports.kUnknownNullCount && (nullBitmap = this.nullBitmap)) {
            this._nullCount = nullCount = nullBitmap.length === 0 ?
                // no null bitmap, so all values are valid
                0 :
                this.length - (0, bit_js_1.popcnt_bit_range)(nullBitmap, this.offset, this.offset + this.length);
        }
        return nullCount;
    }
    constructor(type, offset, length, nullCount, buffers, children = [], dictionary) {
        this.type = type;
        this.children = children;
        this.dictionary = dictionary;
        this.offset = Math.floor(Math.max(offset || 0, 0));
        this.length = Math.floor(Math.max(length || 0, 0));
        this._nullCount = Math.floor(Math.max(nullCount || 0, -1));
        let buffer;
        if (buffers instanceof Data) {
            this.stride = buffers.stride;
            this.values = buffers.values;
            this.typeIds = buffers.typeIds;
            this.nullBitmap = buffers.nullBitmap;
            this.valueOffsets = buffers.valueOffsets;
        }
        else {
            this.stride = (0, type_js_1.strideForType)(type);
            if (buffers) {
                (buffer = buffers[0]) && (this.valueOffsets = buffer);
                (buffer = buffers[1]) && (this.values = buffer);
                (buffer = buffers[2]) && (this.nullBitmap = buffer);
                (buffer = buffers[3]) && (this.typeIds = buffer);
            }
        }
    }
    getValid(index) {
        const { type } = this;
        if (type_js_1.DataType.isUnion(type)) {
            const union = type;
            const child = this.children[union.typeIdToChildIndex[this.typeIds[index]]];
            const indexInChild = union.mode === enum_js_1.UnionMode.Dense ? this.valueOffsets[index] : index;
            return child.getValid(indexInChild);
        }
        if (this.nullable && this.nullCount > 0) {
            const pos = this.offset + index;
            const val = this.nullBitmap[pos >> 3];
            return (val & (1 << (pos % 8))) !== 0;
        }
        return true;
    }
    setValid(index, value) {
        let prev;
        const { type } = this;
        if (type_js_1.DataType.isUnion(type)) {
            const union = type;
            const child = this.children[union.typeIdToChildIndex[this.typeIds[index]]];
            const indexInChild = union.mode === enum_js_1.UnionMode.Dense ? this.valueOffsets[index] : index;
            prev = child.getValid(indexInChild);
            child.setValid(indexInChild, value);
        }
        else {
            let { nullBitmap } = this;
            const { offset, length } = this;
            const idx = offset + index;
            const mask = 1 << (idx % 8);
            const byteOffset = idx >> 3;
            // If no null bitmap, initialize one on the fly
            if (!nullBitmap || nullBitmap.byteLength <= byteOffset) {
                nullBitmap = new Uint8Array((((offset + length) + 63) & ~63) >> 3).fill(255);
                // if we have a nullBitmap, truncate + slice and set it over the pre-filled 1s
                if (this.nullCount > 0) {
                    nullBitmap.set((0, bit_js_1.truncateBitmap)(offset, length, this.nullBitmap), 0);
                    Object.assign(this, { nullBitmap });
                }
                else {
                    Object.assign(this, { nullBitmap, _nullCount: 0 });
                }
            }
            const byte = nullBitmap[byteOffset];
            prev = (byte & mask) !== 0;
            nullBitmap[byteOffset] = value ? (byte | mask) : (byte & ~mask);
        }
        if (prev !== !!value) {
            // Update `_nullCount` if the new value is different from the old value.
            this._nullCount = this.nullCount + (value ? -1 : 1);
        }
        return value;
    }
    clone(type = this.type, offset = this.offset, length = this.length, nullCount = this._nullCount, buffers = this, children = this.children) {
        return new Data(type, offset, length, nullCount, buffers, children, this.dictionary);
    }
    slice(offset, length) {
        const { stride, typeId, children } = this;
        // +true === 1, +false === 0, so this means
        // we keep nullCount at 0 if it's already 0,
        // otherwise set to the invalidated flag -1
        const nullCount = +(this._nullCount === 0) - 1;
        const childStride = typeId === 16 /* FixedSizeList */ ? stride : 1;
        const buffers = this._sliceBuffers(offset, length, stride, typeId);
        return this.clone(this.type, this.offset + offset, length, nullCount, buffers, 
        // Don't slice children if we have value offsets (the variable-width types)
        (children.length === 0 || this.valueOffsets) ? children : this._sliceChildren(children, childStride * offset, childStride * length));
    }
    _changeLengthAndBackfillNullBitmap(newLength) {
        if (this.typeId === enum_js_1.Type.Null) {
            return this.clone(this.type, 0, newLength, 0);
        }
        const { length, nullCount } = this;
        // start initialized with 0s (nulls), then fill from 0 to length with 1s (not null)
        const bitmap = new Uint8Array(((newLength + 63) & ~63) >> 3).fill(255, 0, length >> 3);
        // set all the bits in the last byte (up to bit `length - length % 8`) to 1 (not null)
        bitmap[length >> 3] = (1 << (length - (length & ~7))) - 1;
        // if we have a nullBitmap, truncate + slice and set it over the pre-filled 1s
        if (nullCount > 0) {
            bitmap.set((0, bit_js_1.truncateBitmap)(this.offset, length, this.nullBitmap), 0);
        }
        const buffers = this.buffers;
        buffers[enum_js_1.BufferType.VALIDITY] = bitmap;
        return this.clone(this.type, 0, newLength, nullCount + (newLength - length), buffers);
    }
    _sliceBuffers(offset, length, stride, typeId) {
        let arr;
        const { buffers } = this;
        // If typeIds exist, slice the typeIds buffer
        (arr = buffers[enum_js_1.BufferType.TYPE]) && (buffers[enum_js_1.BufferType.TYPE] = arr.subarray(offset, offset + length));
        // If offsets exist, only slice the offsets buffer
        (arr = buffers[enum_js_1.BufferType.OFFSET]) && (buffers[enum_js_1.BufferType.OFFSET] = arr.subarray(offset, offset + length + 1)) ||
            // Otherwise if no offsets, slice the data buffer. Don't slice the data vector for Booleans, since the offset goes by bits not bytes
            (arr = buffers[enum_js_1.BufferType.DATA]) && (buffers[enum_js_1.BufferType.DATA] = typeId === 6 ? arr : arr.subarray(stride * offset, stride * (offset + length)));
        return buffers;
    }
    _sliceChildren(children, offset, length) {
        return children.map((child) => child.slice(offset, length));
    }
}
exports.Data = Data;
Data.prototype.children = Object.freeze([]);
const visitor_js_1 = __webpack_require__(112);
const buffer_js_1 = __webpack_require__(43);
class MakeDataVisitor extends visitor_js_1.Visitor {
    visit(props) {
        return this.getVisitFn(props['type']).call(this, props);
    }
    visitNull(props) {
        const { ['type']: type, ['offset']: offset = 0, ['length']: length = 0, } = props;
        return new Data(type, offset, length, length);
    }
    visitBool(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props['data']);
        const { ['length']: length = data.length >> 3, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0, } = props;
        return new Data(type, offset, length, nullCount, [undefined, data, nullBitmap]);
    }
    visitInt(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props['data']);
        const { ['length']: length = data.length, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0, } = props;
        return new Data(type, offset, length, nullCount, [undefined, data, nullBitmap]);
    }
    visitFloat(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props['data']);
        const { ['length']: length = data.length, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0, } = props;
        return new Data(type, offset, length, nullCount, [undefined, data, nullBitmap]);
    }
    visitUtf8(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const data = (0, buffer_js_1.toUint8Array)(props['data']);
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const valueOffsets = (0, buffer_js_1.toInt32Array)(props['valueOffsets']);
        const { ['length']: length = valueOffsets.length - 1, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [valueOffsets, data, nullBitmap]);
    }
    visitLargeUtf8(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const data = (0, buffer_js_1.toUint8Array)(props['data']);
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const valueOffsets = (0, buffer_js_1.toBigInt64Array)(props['valueOffsets']);
        const { ['length']: length = valueOffsets.length - 1, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [valueOffsets, data, nullBitmap]);
    }
    visitBinary(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const data = (0, buffer_js_1.toUint8Array)(props['data']);
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const valueOffsets = (0, buffer_js_1.toInt32Array)(props['valueOffsets']);
        const { ['length']: length = valueOffsets.length - 1, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [valueOffsets, data, nullBitmap]);
    }
    visitLargeBinary(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const data = (0, buffer_js_1.toUint8Array)(props['data']);
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const valueOffsets = (0, buffer_js_1.toBigInt64Array)(props['valueOffsets']);
        const { ['length']: length = valueOffsets.length - 1, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [valueOffsets, data, nullBitmap]);
    }
    visitFixedSizeBinary(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props['data']);
        const { ['length']: length = data.length / (0, type_js_1.strideForType)(type), ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0, } = props;
        return new Data(type, offset, length, nullCount, [undefined, data, nullBitmap]);
    }
    visitDate(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props['data']);
        const { ['length']: length = data.length / (0, type_js_1.strideForType)(type), ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0, } = props;
        return new Data(type, offset, length, nullCount, [undefined, data, nullBitmap]);
    }
    visitTimestamp(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props['data']);
        const { ['length']: length = data.length / (0, type_js_1.strideForType)(type), ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0, } = props;
        return new Data(type, offset, length, nullCount, [undefined, data, nullBitmap]);
    }
    visitTime(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props['data']);
        const { ['length']: length = data.length / (0, type_js_1.strideForType)(type), ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0, } = props;
        return new Data(type, offset, length, nullCount, [undefined, data, nullBitmap]);
    }
    visitDecimal(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props['data']);
        const { ['length']: length = data.length / (0, type_js_1.strideForType)(type), ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0, } = props;
        return new Data(type, offset, length, nullCount, [undefined, data, nullBitmap]);
    }
    visitList(props) {
        const { ['type']: type, ['offset']: offset = 0, ['child']: child } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const valueOffsets = (0, buffer_js_1.toInt32Array)(props['valueOffsets']);
        const { ['length']: length = valueOffsets.length - 1, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [valueOffsets, undefined, nullBitmap], [child]);
    }
    visitStruct(props) {
        const { ['type']: type, ['offset']: offset = 0, ['children']: children = [] } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const { length = children.reduce((len, { length }) => Math.max(len, length), 0), nullCount = props['nullBitmap'] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [undefined, undefined, nullBitmap], children);
    }
    visitUnion(props) {
        const { ['type']: type, ['offset']: offset = 0, ['children']: children = [] } = props;
        const typeIds = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props['typeIds']);
        const { ['length']: length = typeIds.length, ['nullCount']: nullCount = -1, } = props;
        if (type_js_1.DataType.isSparseUnion(type)) {
            return new Data(type, offset, length, nullCount, [undefined, undefined, undefined, typeIds], children);
        }
        const valueOffsets = (0, buffer_js_1.toInt32Array)(props['valueOffsets']);
        return new Data(type, offset, length, nullCount, [valueOffsets, undefined, undefined, typeIds], children);
    }
    visitDictionary(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const data = (0, buffer_js_1.toArrayBufferView)(type.indices.ArrayType, props['data']);
        const { ['dictionary']: dictionary = new vector_js_1.Vector([new MakeDataVisitor().visit({ type: type.dictionary })]) } = props;
        const { ['length']: length = data.length, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [undefined, data, nullBitmap], [], dictionary);
    }
    visitInterval(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props['data']);
        const { ['length']: length = data.length / (0, type_js_1.strideForType)(type), ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0, } = props;
        return new Data(type, offset, length, nullCount, [undefined, data, nullBitmap]);
    }
    visitDuration(props) {
        const { ['type']: type, ['offset']: offset = 0 } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const data = (0, buffer_js_1.toArrayBufferView)(type.ArrayType, props['data']);
        const { ['length']: length = data.length, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0, } = props;
        return new Data(type, offset, length, nullCount, [undefined, data, nullBitmap]);
    }
    visitFixedSizeList(props) {
        const { ['type']: type, ['offset']: offset = 0, ['child']: child = new MakeDataVisitor().visit({ type: type.valueType }) } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const { ['length']: length = child.length / (0, type_js_1.strideForType)(type), ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0 } = props;
        return new Data(type, offset, length, nullCount, [undefined, undefined, nullBitmap], [child]);
    }
    visitMap(props) {
        const { ['type']: type, ['offset']: offset = 0, ['child']: child = new MakeDataVisitor().visit({ type: type.childType }) } = props;
        const nullBitmap = (0, buffer_js_1.toUint8Array)(props['nullBitmap']);
        const valueOffsets = (0, buffer_js_1.toInt32Array)(props['valueOffsets']);
        const { ['length']: length = valueOffsets.length - 1, ['nullCount']: nullCount = props['nullBitmap'] ? -1 : 0, } = props;
        return new Data(type, offset, length, nullCount, [valueOffsets, undefined, nullBitmap], [child]);
    }
}
const makeDataVisitor = new MakeDataVisitor();
function makeData(props) {
    return makeDataVisitor.visit(props);
}
exports.makeData = makeData;

//# sourceMappingURL=data.js.map


/***/ }),
/* 118 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.popcnt_uint32 = exports.popcnt_array = exports.popcnt_bit_range = exports.BitIterator = exports.packBools = exports.truncateBitmap = exports.setBool = exports.getBit = exports.getBool = void 0;
/** @ignore */
function getBool(_data, _index, byte, bit) {
    return (byte & 1 << bit) !== 0;
}
exports.getBool = getBool;
/** @ignore */
function getBit(_data, _index, byte, bit) {
    return (byte & 1 << bit) >> bit;
}
exports.getBit = getBit;
/** @ignore */
function setBool(bytes, index, value) {
    return value ?
        !!(bytes[index >> 3] |= (1 << (index % 8))) || true :
        !(bytes[index >> 3] &= ~(1 << (index % 8))) && false;
}
exports.setBool = setBool;
/** @ignore */
function truncateBitmap(offset, length, bitmap) {
    const alignedSize = (bitmap.byteLength + 7) & ~7;
    if (offset > 0 || bitmap.byteLength < alignedSize) {
        const bytes = new Uint8Array(alignedSize);
        // If the offset is a multiple of 8 bits, it's safe to slice the bitmap
        bytes.set(offset % 8 === 0 ? bitmap.subarray(offset >> 3) :
            // Otherwise iterate each bit from the offset and return a new one
            packBools(new BitIterator(bitmap, offset, length, null, getBool)).subarray(0, alignedSize));
        return bytes;
    }
    return bitmap;
}
exports.truncateBitmap = truncateBitmap;
/** @ignore */
function packBools(values) {
    const xs = [];
    let i = 0, bit = 0, byte = 0;
    for (const value of values) {
        value && (byte |= 1 << bit);
        if (++bit === 8) {
            xs[i++] = byte;
            byte = bit = 0;
        }
    }
    if (i === 0 || bit > 0) {
        xs[i++] = byte;
    }
    const b = new Uint8Array((xs.length + 7) & ~7);
    b.set(xs);
    return b;
}
exports.packBools = packBools;
/** @ignore */
class BitIterator {
    constructor(bytes, begin, length, context, get) {
        this.bytes = bytes;
        this.length = length;
        this.context = context;
        this.get = get;
        this.bit = begin % 8;
        this.byteIndex = begin >> 3;
        this.byte = bytes[this.byteIndex++];
        this.index = 0;
    }
    next() {
        if (this.index < this.length) {
            if (this.bit === 8) {
                this.bit = 0;
                this.byte = this.bytes[this.byteIndex++];
            }
            return {
                value: this.get(this.context, this.index++, this.byte, this.bit++)
            };
        }
        return { done: true, value: null };
    }
    [Symbol.iterator]() {
        return this;
    }
}
exports.BitIterator = BitIterator;
/**
 * Compute the population count (the number of bits set to 1) for a range of bits in a Uint8Array.
 * @param vector The Uint8Array of bits for which to compute the population count.
 * @param lhs The range's left-hand side (or start) bit
 * @param rhs The range's right-hand side (or end) bit
 */
/** @ignore */
function popcnt_bit_range(data, lhs, rhs) {
    if (rhs - lhs <= 0) {
        return 0;
    }
    // If the bit range is less than one byte, sum the 1 bits in the bit range
    if (rhs - lhs < 8) {
        let sum = 0;
        for (const bit of new BitIterator(data, lhs, rhs - lhs, data, getBit)) {
            sum += bit;
        }
        return sum;
    }
    // Get the next lowest multiple of 8 from the right hand side
    const rhsInside = rhs >> 3 << 3;
    // Get the next highest multiple of 8 from the left hand side
    const lhsInside = lhs + (lhs % 8 === 0 ? 0 : 8 - lhs % 8);
    return (
    // Get the popcnt of bits between the left hand side, and the next highest multiple of 8
    popcnt_bit_range(data, lhs, lhsInside) +
        // Get the popcnt of bits between the right hand side, and the next lowest multiple of 8
        popcnt_bit_range(data, rhsInside, rhs) +
        // Get the popcnt of all bits between the left and right hand sides' multiples of 8
        popcnt_array(data, lhsInside >> 3, (rhsInside - lhsInside) >> 3));
}
exports.popcnt_bit_range = popcnt_bit_range;
/** @ignore */
function popcnt_array(arr, byteOffset, byteLength) {
    let cnt = 0, pos = Math.trunc(byteOffset);
    const view = new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    const len = byteLength === void 0 ? arr.byteLength : pos + byteLength;
    while (len - pos >= 4) {
        cnt += popcnt_uint32(view.getUint32(pos));
        pos += 4;
    }
    while (len - pos >= 2) {
        cnt += popcnt_uint32(view.getUint16(pos));
        pos += 2;
    }
    while (len - pos >= 1) {
        cnt += popcnt_uint32(view.getUint8(pos));
        pos += 1;
    }
    return cnt;
}
exports.popcnt_array = popcnt_array;
/** @ignore */
function popcnt_uint32(uint32) {
    let i = Math.trunc(uint32);
    i = i - ((i >>> 1) & 0x55555555);
    i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);
    return (((i + (i >>> 4)) & 0x0F0F0F0F) * 0x01010101) >>> 24;
}
exports.popcnt_uint32 = popcnt_uint32;

//# sourceMappingURL=bit.js.map


/***/ }),
/* 119 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.wrapChunkedIndexOf = exports.wrapChunkedCall2 = exports.wrapChunkedCall1 = exports.isChunkedValid = exports.binarySearch = exports.sliceChunks = exports.computeChunkOffsets = exports.computeChunkNullCounts = exports.computeChunkNullable = exports.ChunkedIterator = void 0;
/** @ignore */
class ChunkedIterator {
    constructor(numChunks = 0, getChunkIterator) {
        this.numChunks = numChunks;
        this.getChunkIterator = getChunkIterator;
        this.chunkIndex = 0;
        this.chunkIterator = this.getChunkIterator(0);
    }
    next() {
        while (this.chunkIndex < this.numChunks) {
            const next = this.chunkIterator.next();
            if (!next.done) {
                return next;
            }
            if (++this.chunkIndex < this.numChunks) {
                this.chunkIterator = this.getChunkIterator(this.chunkIndex);
            }
        }
        return { done: true, value: null };
    }
    [Symbol.iterator]() {
        return this;
    }
}
exports.ChunkedIterator = ChunkedIterator;
/** @ignore */
function computeChunkNullable(chunks) {
    return chunks.some(chunk => chunk.nullable);
}
exports.computeChunkNullable = computeChunkNullable;
/** @ignore */
function computeChunkNullCounts(chunks) {
    return chunks.reduce((nullCount, chunk) => nullCount + chunk.nullCount, 0);
}
exports.computeChunkNullCounts = computeChunkNullCounts;
/** @ignore */
function computeChunkOffsets(chunks) {
    return chunks.reduce((offsets, chunk, index) => {
        offsets[index + 1] = offsets[index] + chunk.length;
        return offsets;
    }, new Uint32Array(chunks.length + 1));
}
exports.computeChunkOffsets = computeChunkOffsets;
/** @ignore */
function sliceChunks(chunks, offsets, begin, end) {
    const slices = [];
    for (let i = -1, n = chunks.length; ++i < n;) {
        const chunk = chunks[i];
        const offset = offsets[i];
        const { length } = chunk;
        // Stop if the child is to the right of the slice boundary
        if (offset >= end) {
            break;
        }
        // Exclude children to the left of of the slice boundary
        if (begin >= offset + length) {
            continue;
        }
        // Include entire child if between both left and right boundaries
        if (offset >= begin && (offset + length) <= end) {
            slices.push(chunk);
            continue;
        }
        // Include the child slice that overlaps one of the slice boundaries
        const from = Math.max(0, begin - offset);
        const to = Math.min(end - offset, length);
        slices.push(chunk.slice(from, to - from));
    }
    if (slices.length === 0) {
        slices.push(chunks[0].slice(0, 0));
    }
    return slices;
}
exports.sliceChunks = sliceChunks;
/** @ignore */
function binarySearch(chunks, offsets, idx, fn) {
    let lhs = 0, mid = 0, rhs = offsets.length - 1;
    do {
        if (lhs >= rhs - 1) {
            return (idx < offsets[rhs]) ? fn(chunks, lhs, idx - offsets[lhs]) : null;
        }
        mid = lhs + (Math.trunc((rhs - lhs) * .5));
        idx < offsets[mid] ? (rhs = mid) : (lhs = mid);
    } while (lhs < rhs);
}
exports.binarySearch = binarySearch;
/** @ignore */
function isChunkedValid(data, index) {
    return data.getValid(index);
}
exports.isChunkedValid = isChunkedValid;
/** @ignore */
function wrapChunkedCall1(fn) {
    function chunkedFn(chunks, i, j) { return fn(chunks[i], j); }
    return function (index) {
        const data = this.data;
        return binarySearch(data, this._offsets, index, chunkedFn);
    };
}
exports.wrapChunkedCall1 = wrapChunkedCall1;
/** @ignore */
function wrapChunkedCall2(fn) {
    let _2;
    function chunkedFn(chunks, i, j) { return fn(chunks[i], j, _2); }
    return function (index, value) {
        const data = this.data;
        _2 = value;
        const result = binarySearch(data, this._offsets, index, chunkedFn);
        _2 = undefined;
        return result;
    };
}
exports.wrapChunkedCall2 = wrapChunkedCall2;
/** @ignore */
function wrapChunkedIndexOf(indexOf) {
    let _1;
    function chunkedIndexOf(data, chunkIndex, fromIndex) {
        let begin = fromIndex, index = 0, total = 0;
        for (let i = chunkIndex - 1, n = data.length; ++i < n;) {
            const chunk = data[i];
            if (~(index = indexOf(chunk, _1, begin))) {
                return total + index;
            }
            begin = 0;
            total += chunk.length;
        }
        return -1;
    }
    return function (element, offset) {
        _1 = element;
        const data = this.data;
        const result = typeof offset !== 'number'
            ? chunkedIndexOf(data, 0, 0)
            : binarySearch(data, this._offsets, offset, chunkedIndexOf);
        _1 = undefined;
        return result;
    };
}
exports.wrapChunkedIndexOf = wrapChunkedIndexOf;

//# sourceMappingURL=chunk.js.map


/***/ }),
/* 120 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.instance = exports.IndexOfVisitor = void 0;
const enum_js_1 = __webpack_require__(48);
const visitor_js_1 = __webpack_require__(112);
const get_js_1 = __webpack_require__(109);
const bit_js_1 = __webpack_require__(118);
const vector_js_1 = __webpack_require__(106);
/** @ignore */
class IndexOfVisitor extends visitor_js_1.Visitor {
}
exports.IndexOfVisitor = IndexOfVisitor;
/** @ignore */
function nullIndexOf(data, searchElement) {
    // if you're looking for nulls and the vector isn't empty, we've got 'em!
    return searchElement === null && data.length > 0 ? 0 : -1;
}
/** @ignore */
function indexOfNull(data, fromIndex) {
    const { nullBitmap } = data;
    if (!nullBitmap || data.nullCount <= 0) {
        return -1;
    }
    let i = 0;
    for (const isValid of new bit_js_1.BitIterator(nullBitmap, data.offset + (fromIndex || 0), data.length, nullBitmap, bit_js_1.getBool)) {
        if (!isValid) {
            return i;
        }
        ++i;
    }
    return -1;
}
/** @ignore */
function indexOfValue(data, searchElement, fromIndex) {
    if (searchElement === undefined) {
        return -1;
    }
    if (searchElement === null) {
        switch (data.typeId) {
            // Unions don't have a nullBitmap of its own, so compare the `searchElement` to `get()`.
            case enum_js_1.Type.Union:
                break;
            // Dictionaries do have a nullBitmap, but their dictionary could also have null elements.
            case enum_js_1.Type.Dictionary:
                break;
            // All other types can iterate the null bitmap
            default:
                return indexOfNull(data, fromIndex);
        }
    }
    const get = get_js_1.instance.getVisitFn(data);
    const compare = (0, vector_js_1.createElementComparator)(searchElement);
    for (let i = (fromIndex || 0) - 1, n = data.length; ++i < n;) {
        if (compare(get(data, i))) {
            return i;
        }
    }
    return -1;
}
/** @ignore */
function indexOfUnion(data, searchElement, fromIndex) {
    // Unions are special -- they do have a nullBitmap, but so can their children.
    // If the searchElement is null, we don't know whether it came from the Union's
    // bitmap or one of its children's. So we don't interrogate the Union's bitmap,
    // since that will report the wrong index if a child has a null before the Union.
    const get = get_js_1.instance.getVisitFn(data);
    const compare = (0, vector_js_1.createElementComparator)(searchElement);
    for (let i = (fromIndex || 0) - 1, n = data.length; ++i < n;) {
        if (compare(get(data, i))) {
            return i;
        }
    }
    return -1;
}
IndexOfVisitor.prototype.visitNull = nullIndexOf;
IndexOfVisitor.prototype.visitBool = indexOfValue;
IndexOfVisitor.prototype.visitInt = indexOfValue;
IndexOfVisitor.prototype.visitInt8 = indexOfValue;
IndexOfVisitor.prototype.visitInt16 = indexOfValue;
IndexOfVisitor.prototype.visitInt32 = indexOfValue;
IndexOfVisitor.prototype.visitInt64 = indexOfValue;
IndexOfVisitor.prototype.visitUint8 = indexOfValue;
IndexOfVisitor.prototype.visitUint16 = indexOfValue;
IndexOfVisitor.prototype.visitUint32 = indexOfValue;
IndexOfVisitor.prototype.visitUint64 = indexOfValue;
IndexOfVisitor.prototype.visitFloat = indexOfValue;
IndexOfVisitor.prototype.visitFloat16 = indexOfValue;
IndexOfVisitor.prototype.visitFloat32 = indexOfValue;
IndexOfVisitor.prototype.visitFloat64 = indexOfValue;
IndexOfVisitor.prototype.visitUtf8 = indexOfValue;
IndexOfVisitor.prototype.visitLargeUtf8 = indexOfValue;
IndexOfVisitor.prototype.visitBinary = indexOfValue;
IndexOfVisitor.prototype.visitLargeBinary = indexOfValue;
IndexOfVisitor.prototype.visitFixedSizeBinary = indexOfValue;
IndexOfVisitor.prototype.visitDate = indexOfValue;
IndexOfVisitor.prototype.visitDateDay = indexOfValue;
IndexOfVisitor.prototype.visitDateMillisecond = indexOfValue;
IndexOfVisitor.prototype.visitTimestamp = indexOfValue;
IndexOfVisitor.prototype.visitTimestampSecond = indexOfValue;
IndexOfVisitor.prototype.visitTimestampMillisecond = indexOfValue;
IndexOfVisitor.prototype.visitTimestampMicrosecond = indexOfValue;
IndexOfVisitor.prototype.visitTimestampNanosecond = indexOfValue;
IndexOfVisitor.prototype.visitTime = indexOfValue;
IndexOfVisitor.prototype.visitTimeSecond = indexOfValue;
IndexOfVisitor.prototype.visitTimeMillisecond = indexOfValue;
IndexOfVisitor.prototype.visitTimeMicrosecond = indexOfValue;
IndexOfVisitor.prototype.visitTimeNanosecond = indexOfValue;
IndexOfVisitor.prototype.visitDecimal = indexOfValue;
IndexOfVisitor.prototype.visitList = indexOfValue;
IndexOfVisitor.prototype.visitStruct = indexOfValue;
IndexOfVisitor.prototype.visitUnion = indexOfValue;
IndexOfVisitor.prototype.visitDenseUnion = indexOfUnion;
IndexOfVisitor.prototype.visitSparseUnion = indexOfUnion;
IndexOfVisitor.prototype.visitDictionary = indexOfValue;
IndexOfVisitor.prototype.visitInterval = indexOfValue;
IndexOfVisitor.prototype.visitIntervalDayTime = indexOfValue;
IndexOfVisitor.prototype.visitIntervalYearMonth = indexOfValue;
IndexOfVisitor.prototype.visitDuration = indexOfValue;
IndexOfVisitor.prototype.visitDurationSecond = indexOfValue;
IndexOfVisitor.prototype.visitDurationMillisecond = indexOfValue;
IndexOfVisitor.prototype.visitDurationMicrosecond = indexOfValue;
IndexOfVisitor.prototype.visitDurationNanosecond = indexOfValue;
IndexOfVisitor.prototype.visitFixedSizeList = indexOfValue;
IndexOfVisitor.prototype.visitMap = indexOfValue;
/** @ignore */
exports.instance = new IndexOfVisitor();

//# sourceMappingURL=indexof.js.map


/***/ }),
/* 121 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.instance = exports.IteratorVisitor = void 0;
const visitor_js_1 = __webpack_require__(112);
const enum_js_1 = __webpack_require__(48);
const type_js_1 = __webpack_require__(113);
const chunk_js_1 = __webpack_require__(119);
/** @ignore */
class IteratorVisitor extends visitor_js_1.Visitor {
}
exports.IteratorVisitor = IteratorVisitor;
/** @ignore */
function vectorIterator(vector) {
    const { type } = vector;
    // Fast case, defer to native iterators if possible
    if (vector.nullCount === 0 && vector.stride === 1 && (
    // Don't defer to native iterator for timestamps since Numbers are expected
    // (DataType.isTimestamp(type)) && type.unit === TimeUnit.MILLISECOND ||
    (type_js_1.DataType.isInt(type) && type.bitWidth !== 64) ||
        (type_js_1.DataType.isTime(type) && type.bitWidth !== 64) ||
        (type_js_1.DataType.isFloat(type) && type.precision !== enum_js_1.Precision.HALF))) {
        return new chunk_js_1.ChunkedIterator(vector.data.length, (chunkIndex) => {
            const data = vector.data[chunkIndex];
            return data.values.subarray(0, data.length)[Symbol.iterator]();
        });
    }
    // Otherwise, iterate manually
    let offset = 0;
    return new chunk_js_1.ChunkedIterator(vector.data.length, (chunkIndex) => {
        const data = vector.data[chunkIndex];
        const length = data.length;
        const inner = vector.slice(offset, offset + length);
        offset += length;
        return new VectorIterator(inner);
    });
}
/** @ignore */
class VectorIterator {
    constructor(vector) {
        this.vector = vector;
        this.index = 0;
    }
    next() {
        if (this.index < this.vector.length) {
            return {
                value: this.vector.get(this.index++)
            };
        }
        return { done: true, value: null };
    }
    [Symbol.iterator]() {
        return this;
    }
}
IteratorVisitor.prototype.visitNull = vectorIterator;
IteratorVisitor.prototype.visitBool = vectorIterator;
IteratorVisitor.prototype.visitInt = vectorIterator;
IteratorVisitor.prototype.visitInt8 = vectorIterator;
IteratorVisitor.prototype.visitInt16 = vectorIterator;
IteratorVisitor.prototype.visitInt32 = vectorIterator;
IteratorVisitor.prototype.visitInt64 = vectorIterator;
IteratorVisitor.prototype.visitUint8 = vectorIterator;
IteratorVisitor.prototype.visitUint16 = vectorIterator;
IteratorVisitor.prototype.visitUint32 = vectorIterator;
IteratorVisitor.prototype.visitUint64 = vectorIterator;
IteratorVisitor.prototype.visitFloat = vectorIterator;
IteratorVisitor.prototype.visitFloat16 = vectorIterator;
IteratorVisitor.prototype.visitFloat32 = vectorIterator;
IteratorVisitor.prototype.visitFloat64 = vectorIterator;
IteratorVisitor.prototype.visitUtf8 = vectorIterator;
IteratorVisitor.prototype.visitLargeUtf8 = vectorIterator;
IteratorVisitor.prototype.visitBinary = vectorIterator;
IteratorVisitor.prototype.visitLargeBinary = vectorIterator;
IteratorVisitor.prototype.visitFixedSizeBinary = vectorIterator;
IteratorVisitor.prototype.visitDate = vectorIterator;
IteratorVisitor.prototype.visitDateDay = vectorIterator;
IteratorVisitor.prototype.visitDateMillisecond = vectorIterator;
IteratorVisitor.prototype.visitTimestamp = vectorIterator;
IteratorVisitor.prototype.visitTimestampSecond = vectorIterator;
IteratorVisitor.prototype.visitTimestampMillisecond = vectorIterator;
IteratorVisitor.prototype.visitTimestampMicrosecond = vectorIterator;
IteratorVisitor.prototype.visitTimestampNanosecond = vectorIterator;
IteratorVisitor.prototype.visitTime = vectorIterator;
IteratorVisitor.prototype.visitTimeSecond = vectorIterator;
IteratorVisitor.prototype.visitTimeMillisecond = vectorIterator;
IteratorVisitor.prototype.visitTimeMicrosecond = vectorIterator;
IteratorVisitor.prototype.visitTimeNanosecond = vectorIterator;
IteratorVisitor.prototype.visitDecimal = vectorIterator;
IteratorVisitor.prototype.visitList = vectorIterator;
IteratorVisitor.prototype.visitStruct = vectorIterator;
IteratorVisitor.prototype.visitUnion = vectorIterator;
IteratorVisitor.prototype.visitDenseUnion = vectorIterator;
IteratorVisitor.prototype.visitSparseUnion = vectorIterator;
IteratorVisitor.prototype.visitDictionary = vectorIterator;
IteratorVisitor.prototype.visitInterval = vectorIterator;
IteratorVisitor.prototype.visitIntervalDayTime = vectorIterator;
IteratorVisitor.prototype.visitIntervalYearMonth = vectorIterator;
IteratorVisitor.prototype.visitDuration = vectorIterator;
IteratorVisitor.prototype.visitDurationSecond = vectorIterator;
IteratorVisitor.prototype.visitDurationMillisecond = vectorIterator;
IteratorVisitor.prototype.visitDurationMicrosecond = vectorIterator;
IteratorVisitor.prototype.visitDurationNanosecond = vectorIterator;
IteratorVisitor.prototype.visitFixedSizeList = vectorIterator;
IteratorVisitor.prototype.visitMap = vectorIterator;
/** @ignore */
exports.instance = new IteratorVisitor();

//# sourceMappingURL=iterator.js.map


/***/ }),
/* 122 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createIsValidFunction = void 0;
const pretty_js_1 = __webpack_require__(108);
/**
 * Dynamically compile the null values into an `isValid()` function whose
 * implementation is a switch statement. Microbenchmarks in v8 indicate
 * this approach is 25% faster than using an ES6 Map.
 *
 * @example
 * console.log(createIsValidFunction([null, 'N/A', NaN]));
 * `function (x) {
 *     if (x !== x) return false;
 *     switch (x) {
 *         case null:
 *         case "N/A":
 *             return false;
 *     }
 *     return true;
 * }`
 *
 * @ignore
 * @param nullValues
 */
function createIsValidFunction(nullValues) {
    if (!nullValues || nullValues.length <= 0) {
        // @ts-ignore
        return function isValid(value) { return true; };
    }
    let fnBody = '';
    const noNaNs = nullValues.filter((x) => x === x);
    if (noNaNs.length > 0) {
        fnBody = `
    switch (x) {${noNaNs.map((x) => `
        case ${valueToCase(x)}:`).join('')}
            return false;
    }`;
    }
    // NaN doesn't equal anything including itself, so it doesn't work as a
    // switch case. Instead we must explicitly check for NaN before the switch.
    if (nullValues.length !== noNaNs.length) {
        fnBody = `if (x !== x) return false;\n${fnBody}`;
    }
    return new Function(`x`, `${fnBody}\nreturn true;`);
}
exports.createIsValidFunction = createIsValidFunction;
/** @ignore */
function valueToCase(x) {
    if (typeof x !== 'bigint') {
        return (0, pretty_js_1.valueToString)(x);
    }
    return `${(0, pretty_js_1.valueToString)(x)}n`;
}

//# sourceMappingURL=valid.js.map


/***/ }),
/* 123 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OffsetsBufferBuilder = exports.BitmapBufferBuilder = exports.DataBufferBuilder = exports.BufferBuilder = void 0;
const buffer_js_1 = __webpack_require__(43);
/** @ignore */
function roundLengthUpToNearest64Bytes(len, BPE) {
    const bytesMinus1 = Math.ceil(len) * BPE - 1;
    return ((bytesMinus1 - bytesMinus1 % 64 + 64) || 64) / BPE;
}
/** @ignore */
function resizeArray(arr, len = 0) {
    return arr.length >= len ?
        arr.subarray(0, len) :
        (0, buffer_js_1.memcpy)(new arr.constructor(len), arr, 0);
}
/** @ignore */
class BufferBuilder {
    constructor(bufferType, initialSize = 0, stride = 1) {
        this.length = Math.ceil(initialSize / stride);
        this.buffer = new bufferType(this.length);
        this.stride = stride;
        this.BYTES_PER_ELEMENT = bufferType.BYTES_PER_ELEMENT;
        this.ArrayType = bufferType;
    }
    get byteLength() {
        return Math.ceil(this.length * this.stride) * this.BYTES_PER_ELEMENT;
    }
    get reservedLength() { return this.buffer.length / this.stride; }
    get reservedByteLength() { return this.buffer.byteLength; }
    // @ts-ignore
    set(index, value) { return this; }
    append(value) { return this.set(this.length, value); }
    reserve(extra) {
        if (extra > 0) {
            this.length += extra;
            const stride = this.stride;
            const length = this.length * stride;
            const reserved = this.buffer.length;
            if (length >= reserved) {
                this._resize(reserved === 0
                    ? roundLengthUpToNearest64Bytes(length * 1, this.BYTES_PER_ELEMENT)
                    : roundLengthUpToNearest64Bytes(length * 2, this.BYTES_PER_ELEMENT));
            }
        }
        return this;
    }
    flush(length = this.length) {
        length = roundLengthUpToNearest64Bytes(length * this.stride, this.BYTES_PER_ELEMENT);
        const array = resizeArray(this.buffer, length);
        this.clear();
        return array;
    }
    clear() {
        this.length = 0;
        this.buffer = new this.ArrayType();
        return this;
    }
    _resize(newLength) {
        return this.buffer = resizeArray(this.buffer, newLength);
    }
}
exports.BufferBuilder = BufferBuilder;
/** @ignore */
class DataBufferBuilder extends BufferBuilder {
    last() { return this.get(this.length - 1); }
    get(index) { return this.buffer[index]; }
    set(index, value) {
        this.reserve(index - this.length + 1);
        this.buffer[index * this.stride] = value;
        return this;
    }
}
exports.DataBufferBuilder = DataBufferBuilder;
/** @ignore */
class BitmapBufferBuilder extends DataBufferBuilder {
    constructor() {
        super(Uint8Array, 0, 1 / 8);
        this.numValid = 0;
    }
    get numInvalid() { return this.length - this.numValid; }
    get(idx) { return this.buffer[idx >> 3] >> idx % 8 & 1; }
    set(idx, val) {
        const { buffer } = this.reserve(idx - this.length + 1);
        const byte = idx >> 3, bit = idx % 8, cur = buffer[byte] >> bit & 1;
        // If `val` is truthy and the current bit is 0, flip it to 1 and increment `numValid`.
        // If `val` is falsey and the current bit is 1, flip it to 0 and decrement `numValid`.
        val ? cur === 0 && ((buffer[byte] |= (1 << bit)), ++this.numValid)
            : cur === 1 && ((buffer[byte] &= ~(1 << bit)), --this.numValid);
        return this;
    }
    clear() {
        this.numValid = 0;
        return super.clear();
    }
}
exports.BitmapBufferBuilder = BitmapBufferBuilder;
/** @ignore */
class OffsetsBufferBuilder extends DataBufferBuilder {
    constructor(type) {
        super(type.OffsetArrayType, 1, 1);
    }
    append(value) {
        return this.set(this.length - 1, value);
    }
    set(index, value) {
        const offset = this.length - 1;
        const buffer = this.reserve(index - offset + 1).buffer;
        if (offset < index++ && offset >= 0) {
            buffer.fill(buffer[offset], offset, index);
        }
        buffer[index] = buffer[index - 1] + value;
        return this;
    }
    flush(length = this.length - 1) {
        if (length > this.length) {
            this.set(length - 1, this.BYTES_PER_ELEMENT > 4 ? BigInt(0) : 0);
        }
        return super.flush(length + 1);
    }
}
exports.OffsetsBufferBuilder = OffsetsBufferBuilder;

//# sourceMappingURL=buffer.js.map


/***/ }),
/* 124 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AsyncRecordBatchFileReader = exports.RecordBatchFileReader = exports.AsyncRecordBatchStreamReader = exports.RecordBatchStreamReader = exports.RecordBatchReader = void 0;
const tslib_1 = __webpack_require__(41);
const data_js_1 = __webpack_require__(117);
const vector_js_1 = __webpack_require__(47);
const type_js_1 = __webpack_require__(113);
const enum_js_1 = __webpack_require__(48);
const file_js_1 = __webpack_require__(125);
const adapters_js_1 = __webpack_require__(42);
const stream_js_1 = __webpack_require__(129);
const file_js_2 = __webpack_require__(131);
const vectorloader_js_1 = __webpack_require__(132);
const recordbatch_js_1 = __webpack_require__(134);
const interfaces_js_1 = __webpack_require__(130);
const message_js_1 = __webpack_require__(161);
const compat_js_1 = __webpack_require__(45);
class RecordBatchReader extends interfaces_js_1.ReadableInterop {
    constructor(impl) {
        super();
        this._impl = impl;
    }
    get closed() { return this._impl.closed; }
    get schema() { return this._impl.schema; }
    get autoDestroy() { return this._impl.autoDestroy; }
    get dictionaries() { return this._impl.dictionaries; }
    get numDictionaries() { return this._impl.numDictionaries; }
    get numRecordBatches() { return this._impl.numRecordBatches; }
    get footer() { return this._impl.isFile() ? this._impl.footer : null; }
    isSync() { return this._impl.isSync(); }
    isAsync() { return this._impl.isAsync(); }
    isFile() { return this._impl.isFile(); }
    isStream() { return this._impl.isStream(); }
    next() {
        return this._impl.next();
    }
    throw(value) {
        return this._impl.throw(value);
    }
    return(value) {
        return this._impl.return(value);
    }
    cancel() {
        return this._impl.cancel();
    }
    reset(schema) {
        this._impl.reset(schema);
        this._DOMStream = undefined;
        this._nodeStream = undefined;
        return this;
    }
    open(options) {
        const opening = this._impl.open(options);
        return (0, compat_js_1.isPromise)(opening) ? opening.then(() => this) : this;
    }
    readRecordBatch(index) {
        return this._impl.isFile() ? this._impl.readRecordBatch(index) : null;
    }
    [Symbol.iterator]() {
        return this._impl[Symbol.iterator]();
    }
    [Symbol.asyncIterator]() {
        return this._impl[Symbol.asyncIterator]();
    }
    toDOMStream() {
        return adapters_js_1.default.toDOMStream((this.isSync()
            ? { [Symbol.iterator]: () => this }
            : { [Symbol.asyncIterator]: () => this }));
    }
    toNodeStream() {
        return adapters_js_1.default.toNodeStream((this.isSync()
            ? { [Symbol.iterator]: () => this }
            : { [Symbol.asyncIterator]: () => this }), { objectMode: true });
    }
    /** @nocollapse */
    // @ts-ignore
    static throughNode(options) {
        throw new Error(`"throughNode" not available in this environment`);
    }
    /** @nocollapse */
    static throughDOM(
    // @ts-ignore
    writableStrategy, 
    // @ts-ignore
    readableStrategy) {
        throw new Error(`"throughDOM" not available in this environment`);
    }
    /** @nocollapse */
    static from(source) {
        if (source instanceof RecordBatchReader) {
            return source;
        }
        else if ((0, compat_js_1.isArrowJSON)(source)) {
            return fromArrowJSON(source);
        }
        else if ((0, compat_js_1.isFileHandle)(source)) {
            return fromFileHandle(source);
        }
        else if ((0, compat_js_1.isPromise)(source)) {
            return (() => tslib_1.__awaiter(this, void 0, void 0, function* () { return yield RecordBatchReader.from(yield source); }))();
        }
        else if ((0, compat_js_1.isFetchResponse)(source) || (0, compat_js_1.isReadableDOMStream)(source) || (0, compat_js_1.isReadableNodeStream)(source) || (0, compat_js_1.isAsyncIterable)(source)) {
            return fromAsyncByteStream(new stream_js_1.AsyncByteStream(source));
        }
        return fromByteStream(new stream_js_1.ByteStream(source));
    }
    /** @nocollapse */
    static readAll(source) {
        if (source instanceof RecordBatchReader) {
            return source.isSync() ? readAllSync(source) : readAllAsync(source);
        }
        else if ((0, compat_js_1.isArrowJSON)(source) || ArrayBuffer.isView(source) || (0, compat_js_1.isIterable)(source) || (0, compat_js_1.isIteratorResult)(source)) {
            return readAllSync(source);
        }
        return readAllAsync(source);
    }
}
exports.RecordBatchReader = RecordBatchReader;
//
// Since TS is a structural type system, we define the following subclass stubs
// so that concrete types exist to associate with the interfaces below.
//
// The implementation for each RecordBatchReader is hidden away in the set of
// `RecordBatchReaderImpl` classes in the second half of this file. This allows
// us to export a single RecordBatchReader class, and swap out the impl based
// on the io primitives or underlying arrow (JSON, file, or stream) at runtime.
//
// Async/await makes our job a bit harder, since it forces everything to be
// either fully sync or fully async. This is why the logic for the reader impls
// has been duplicated into both sync and async variants. Since the RBR
// delegates to its impl, an RBR with an AsyncRecordBatchFileReaderImpl for
// example will return async/await-friendly Promises, but one with a (sync)
// RecordBatchStreamReaderImpl will always return values. Nothing should be
// different about their logic, aside from the async handling. This is also why
// this code looks highly structured, as it should be nearly identical and easy
// to follow.
//
/** @ignore */
class RecordBatchStreamReader extends RecordBatchReader {
    constructor(_impl) {
        super(_impl);
        this._impl = _impl;
    }
    readAll() { return [...this]; }
    [Symbol.iterator]() { return this._impl[Symbol.iterator](); }
    [Symbol.asyncIterator]() { return tslib_1.__asyncGenerator(this, arguments, function* _a() { yield tslib_1.__await(yield* tslib_1.__asyncDelegator(tslib_1.__asyncValues(this[Symbol.iterator]()))); }); }
}
exports.RecordBatchStreamReader = RecordBatchStreamReader;
/** @ignore */
class AsyncRecordBatchStreamReader extends RecordBatchReader {
    constructor(_impl) {
        super(_impl);
        this._impl = _impl;
    }
    readAll() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            var _a, e_1, _b, _c;
            const batches = new Array();
            try {
                for (var _d = true, _e = tslib_1.__asyncValues(this), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const batch = _c;
                    batches.push(batch);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return batches;
        });
    }
    [Symbol.iterator]() { throw new Error(`AsyncRecordBatchStreamReader is not Iterable`); }
    [Symbol.asyncIterator]() { return this._impl[Symbol.asyncIterator](); }
}
exports.AsyncRecordBatchStreamReader = AsyncRecordBatchStreamReader;
/** @ignore */
class RecordBatchFileReader extends RecordBatchStreamReader {
    constructor(_impl) {
        super(_impl);
        this._impl = _impl;
    }
}
exports.RecordBatchFileReader = RecordBatchFileReader;
/** @ignore */
class AsyncRecordBatchFileReader extends AsyncRecordBatchStreamReader {
    constructor(_impl) {
        super(_impl);
        this._impl = _impl;
    }
}
exports.AsyncRecordBatchFileReader = AsyncRecordBatchFileReader;
/** @ignore */
class RecordBatchReaderImpl {
    get numDictionaries() { return this._dictionaryIndex; }
    get numRecordBatches() { return this._recordBatchIndex; }
    constructor(dictionaries = new Map()) {
        this.closed = false;
        this.autoDestroy = true;
        this._dictionaryIndex = 0;
        this._recordBatchIndex = 0;
        this.dictionaries = dictionaries;
    }
    isSync() { return false; }
    isAsync() { return false; }
    isFile() { return false; }
    isStream() { return false; }
    reset(schema) {
        this._dictionaryIndex = 0;
        this._recordBatchIndex = 0;
        this.schema = schema;
        this.dictionaries = new Map();
        return this;
    }
    _loadRecordBatch(header, body) {
        const children = this._loadVectors(header, body, this.schema.fields);
        const data = (0, data_js_1.makeData)({ type: new type_js_1.Struct(this.schema.fields), length: header.length, children });
        return new recordbatch_js_1.RecordBatch(this.schema, data);
    }
    _loadDictionaryBatch(header, body) {
        const { id, isDelta } = header;
        const { dictionaries, schema } = this;
        const dictionary = dictionaries.get(id);
        const type = schema.dictionaries.get(id);
        const data = this._loadVectors(header.data, body, [type]);
        return (dictionary && isDelta ? dictionary.concat(new vector_js_1.Vector(data)) :
            new vector_js_1.Vector(data)).memoize();
    }
    _loadVectors(header, body, types) {
        return new vectorloader_js_1.VectorLoader(body, header.nodes, header.buffers, this.dictionaries, this.schema.metadataVersion).visitMany(types);
    }
}
/** @ignore */
class RecordBatchStreamReaderImpl extends RecordBatchReaderImpl {
    constructor(source, dictionaries) {
        super(dictionaries);
        this._reader = !(0, compat_js_1.isArrowJSON)(source)
            ? new message_js_1.MessageReader(this._handle = source)
            : new message_js_1.JSONMessageReader(this._handle = source);
    }
    isSync() { return true; }
    isStream() { return true; }
    [Symbol.iterator]() {
        return this;
    }
    cancel() {
        if (!this.closed && (this.closed = true)) {
            this.reset()._reader.return();
            this._reader = null;
            this.dictionaries = null;
        }
    }
    open(options) {
        if (!this.closed) {
            this.autoDestroy = shouldAutoDestroy(this, options);
            if (!(this.schema || (this.schema = this._reader.readSchema()))) {
                this.cancel();
            }
        }
        return this;
    }
    throw(value) {
        if (!this.closed && this.autoDestroy && (this.closed = true)) {
            return this.reset()._reader.throw(value);
        }
        return interfaces_js_1.ITERATOR_DONE;
    }
    return(value) {
        if (!this.closed && this.autoDestroy && (this.closed = true)) {
            return this.reset()._reader.return(value);
        }
        return interfaces_js_1.ITERATOR_DONE;
    }
    next() {
        if (this.closed) {
            return interfaces_js_1.ITERATOR_DONE;
        }
        let message;
        const { _reader: reader } = this;
        while (message = this._readNextMessageAndValidate()) {
            if (message.isSchema()) {
                this.reset(message.header());
            }
            else if (message.isRecordBatch()) {
                this._recordBatchIndex++;
                const header = message.header();
                const buffer = reader.readMessageBody(message.bodyLength);
                const recordBatch = this._loadRecordBatch(header, buffer);
                return { done: false, value: recordBatch };
            }
            else if (message.isDictionaryBatch()) {
                this._dictionaryIndex++;
                const header = message.header();
                const buffer = reader.readMessageBody(message.bodyLength);
                const vector = this._loadDictionaryBatch(header, buffer);
                this.dictionaries.set(header.id, vector);
            }
        }
        if (this.schema && this._recordBatchIndex === 0) {
            this._recordBatchIndex++;
            return { done: false, value: new recordbatch_js_1._InternalEmptyPlaceholderRecordBatch(this.schema) };
        }
        return this.return();
    }
    _readNextMessageAndValidate(type) {
        return this._reader.readMessage(type);
    }
}
/** @ignore */
class AsyncRecordBatchStreamReaderImpl extends RecordBatchReaderImpl {
    constructor(source, dictionaries) {
        super(dictionaries);
        this._reader = new message_js_1.AsyncMessageReader(this._handle = source);
    }
    isAsync() { return true; }
    isStream() { return true; }
    [Symbol.asyncIterator]() {
        return this;
    }
    cancel() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.closed && (this.closed = true)) {
                yield this.reset()._reader.return();
                this._reader = null;
                this.dictionaries = null;
            }
        });
    }
    open(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.closed) {
                this.autoDestroy = shouldAutoDestroy(this, options);
                if (!(this.schema || (this.schema = (yield this._reader.readSchema())))) {
                    yield this.cancel();
                }
            }
            return this;
        });
    }
    throw(value) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.closed && this.autoDestroy && (this.closed = true)) {
                return yield this.reset()._reader.throw(value);
            }
            return interfaces_js_1.ITERATOR_DONE;
        });
    }
    return(value) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.closed && this.autoDestroy && (this.closed = true)) {
                return yield this.reset()._reader.return(value);
            }
            return interfaces_js_1.ITERATOR_DONE;
        });
    }
    next() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.closed) {
                return interfaces_js_1.ITERATOR_DONE;
            }
            let message;
            const { _reader: reader } = this;
            while (message = yield this._readNextMessageAndValidate()) {
                if (message.isSchema()) {
                    yield this.reset(message.header());
                }
                else if (message.isRecordBatch()) {
                    this._recordBatchIndex++;
                    const header = message.header();
                    const buffer = yield reader.readMessageBody(message.bodyLength);
                    const recordBatch = this._loadRecordBatch(header, buffer);
                    return { done: false, value: recordBatch };
                }
                else if (message.isDictionaryBatch()) {
                    this._dictionaryIndex++;
                    const header = message.header();
                    const buffer = yield reader.readMessageBody(message.bodyLength);
                    const vector = this._loadDictionaryBatch(header, buffer);
                    this.dictionaries.set(header.id, vector);
                }
            }
            if (this.schema && this._recordBatchIndex === 0) {
                this._recordBatchIndex++;
                return { done: false, value: new recordbatch_js_1._InternalEmptyPlaceholderRecordBatch(this.schema) };
            }
            return yield this.return();
        });
    }
    _readNextMessageAndValidate(type) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield this._reader.readMessage(type);
        });
    }
}
/** @ignore */
class RecordBatchFileReaderImpl extends RecordBatchStreamReaderImpl {
    get footer() { return this._footer; }
    get numDictionaries() { return this._footer ? this._footer.numDictionaries : 0; }
    get numRecordBatches() { return this._footer ? this._footer.numRecordBatches : 0; }
    constructor(source, dictionaries) {
        super(source instanceof file_js_2.RandomAccessFile ? source : new file_js_2.RandomAccessFile(source), dictionaries);
    }
    isSync() { return true; }
    isFile() { return true; }
    open(options) {
        if (!this.closed && !this._footer) {
            this.schema = (this._footer = this._readFooter()).schema;
            for (const block of this._footer.dictionaryBatches()) {
                block && this._readDictionaryBatch(this._dictionaryIndex++);
            }
        }
        return super.open(options);
    }
    readRecordBatch(index) {
        var _a;
        if (this.closed) {
            return null;
        }
        if (!this._footer) {
            this.open();
        }
        const block = (_a = this._footer) === null || _a === void 0 ? void 0 : _a.getRecordBatch(index);
        if (block && this._handle.seek(block.offset)) {
            const message = this._reader.readMessage(enum_js_1.MessageHeader.RecordBatch);
            if (message === null || message === void 0 ? void 0 : message.isRecordBatch()) {
                const header = message.header();
                const buffer = this._reader.readMessageBody(message.bodyLength);
                const recordBatch = this._loadRecordBatch(header, buffer);
                return recordBatch;
            }
        }
        return null;
    }
    _readDictionaryBatch(index) {
        var _a;
        const block = (_a = this._footer) === null || _a === void 0 ? void 0 : _a.getDictionaryBatch(index);
        if (block && this._handle.seek(block.offset)) {
            const message = this._reader.readMessage(enum_js_1.MessageHeader.DictionaryBatch);
            if (message === null || message === void 0 ? void 0 : message.isDictionaryBatch()) {
                const header = message.header();
                const buffer = this._reader.readMessageBody(message.bodyLength);
                const vector = this._loadDictionaryBatch(header, buffer);
                this.dictionaries.set(header.id, vector);
            }
        }
    }
    _readFooter() {
        const { _handle } = this;
        const offset = _handle.size - message_js_1.magicAndPadding;
        const length = _handle.readInt32(offset);
        const buffer = _handle.readAt(offset - length, length);
        return file_js_1.Footer.decode(buffer);
    }
    _readNextMessageAndValidate(type) {
        var _a;
        if (!this._footer) {
            this.open();
        }
        if (this._footer && this._recordBatchIndex < this.numRecordBatches) {
            const block = (_a = this._footer) === null || _a === void 0 ? void 0 : _a.getRecordBatch(this._recordBatchIndex);
            if (block && this._handle.seek(block.offset)) {
                return this._reader.readMessage(type);
            }
        }
        return null;
    }
}
/** @ignore */
class AsyncRecordBatchFileReaderImpl extends AsyncRecordBatchStreamReaderImpl {
    get footer() { return this._footer; }
    get numDictionaries() { return this._footer ? this._footer.numDictionaries : 0; }
    get numRecordBatches() { return this._footer ? this._footer.numRecordBatches : 0; }
    constructor(source, ...rest) {
        const byteLength = typeof rest[0] !== 'number' ? rest.shift() : undefined;
        const dictionaries = rest[0] instanceof Map ? rest.shift() : undefined;
        super(source instanceof file_js_2.AsyncRandomAccessFile ? source : new file_js_2.AsyncRandomAccessFile(source, byteLength), dictionaries);
    }
    isFile() { return true; }
    isAsync() { return true; }
    open(options) {
        const _super = Object.create(null, {
            open: { get: () => super.open }
        });
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.closed && !this._footer) {
                this.schema = (this._footer = yield this._readFooter()).schema;
                for (const block of this._footer.dictionaryBatches()) {
                    block && (yield this._readDictionaryBatch(this._dictionaryIndex++));
                }
            }
            return yield _super.open.call(this, options);
        });
    }
    readRecordBatch(index) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            var _a;
            if (this.closed) {
                return null;
            }
            if (!this._footer) {
                yield this.open();
            }
            const block = (_a = this._footer) === null || _a === void 0 ? void 0 : _a.getRecordBatch(index);
            if (block && (yield this._handle.seek(block.offset))) {
                const message = yield this._reader.readMessage(enum_js_1.MessageHeader.RecordBatch);
                if (message === null || message === void 0 ? void 0 : message.isRecordBatch()) {
                    const header = message.header();
                    const buffer = yield this._reader.readMessageBody(message.bodyLength);
                    const recordBatch = this._loadRecordBatch(header, buffer);
                    return recordBatch;
                }
            }
            return null;
        });
    }
    _readDictionaryBatch(index) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            var _a;
            const block = (_a = this._footer) === null || _a === void 0 ? void 0 : _a.getDictionaryBatch(index);
            if (block && (yield this._handle.seek(block.offset))) {
                const message = yield this._reader.readMessage(enum_js_1.MessageHeader.DictionaryBatch);
                if (message === null || message === void 0 ? void 0 : message.isDictionaryBatch()) {
                    const header = message.header();
                    const buffer = yield this._reader.readMessageBody(message.bodyLength);
                    const vector = this._loadDictionaryBatch(header, buffer);
                    this.dictionaries.set(header.id, vector);
                }
            }
        });
    }
    _readFooter() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { _handle } = this;
            _handle._pending && (yield _handle._pending);
            const offset = _handle.size - message_js_1.magicAndPadding;
            const length = yield _handle.readInt32(offset);
            const buffer = yield _handle.readAt(offset - length, length);
            return file_js_1.Footer.decode(buffer);
        });
    }
    _readNextMessageAndValidate(type) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this._footer) {
                yield this.open();
            }
            if (this._footer && this._recordBatchIndex < this.numRecordBatches) {
                const block = this._footer.getRecordBatch(this._recordBatchIndex);
                if (block && (yield this._handle.seek(block.offset))) {
                    return yield this._reader.readMessage(type);
                }
            }
            return null;
        });
    }
}
/** @ignore */
class RecordBatchJSONReaderImpl extends RecordBatchStreamReaderImpl {
    constructor(source, dictionaries) {
        super(source, dictionaries);
    }
    _loadVectors(header, body, types) {
        return new vectorloader_js_1.JSONVectorLoader(body, header.nodes, header.buffers, this.dictionaries, this.schema.metadataVersion).visitMany(types);
    }
}
//
// Define some helper functions and static implementations down here. There's
// a bit of branching in the static methods that can lead to the same routines
// being executed, so we've broken those out here for readability.
//
/** @ignore */
function shouldAutoDestroy(self, options) {
    return options && (typeof options['autoDestroy'] === 'boolean') ? options['autoDestroy'] : self['autoDestroy'];
}
/** @ignore */
function* readAllSync(source) {
    const reader = RecordBatchReader.from(source);
    try {
        if (!reader.open({ autoDestroy: false }).closed) {
            do {
                yield reader;
            } while (!(reader.reset().open()).closed);
        }
    }
    finally {
        reader.cancel();
    }
}
/** @ignore */
function readAllAsync(source) {
    return tslib_1.__asyncGenerator(this, arguments, function* readAllAsync_1() {
        const reader = yield tslib_1.__await(RecordBatchReader.from(source));
        try {
            if (!(yield tslib_1.__await(reader.open({ autoDestroy: false }))).closed) {
                do {
                    yield yield tslib_1.__await(reader);
                } while (!(yield tslib_1.__await(reader.reset().open())).closed);
            }
        }
        finally {
            yield tslib_1.__await(reader.cancel());
        }
    });
}
/** @ignore */
function fromArrowJSON(source) {
    return new RecordBatchStreamReader(new RecordBatchJSONReaderImpl(source));
}
/** @ignore */
function fromByteStream(source) {
    const bytes = source.peek((message_js_1.magicLength + 7) & ~7);
    return bytes && bytes.byteLength >= 4 ? !(0, message_js_1.checkForMagicArrowString)(bytes)
        ? new RecordBatchStreamReader(new RecordBatchStreamReaderImpl(source))
        : new RecordBatchFileReader(new RecordBatchFileReaderImpl(source.read()))
        : new RecordBatchStreamReader(new RecordBatchStreamReaderImpl(function* () { }()));
}
/** @ignore */
function fromAsyncByteStream(source) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const bytes = yield source.peek((message_js_1.magicLength + 7) & ~7);
        return bytes && bytes.byteLength >= 4 ? !(0, message_js_1.checkForMagicArrowString)(bytes)
            ? new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(source))
            : new RecordBatchFileReader(new RecordBatchFileReaderImpl(yield source.read()))
            : new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(function () { return tslib_1.__asyncGenerator(this, arguments, function* () { }); }()));
    });
}
/** @ignore */
function fromFileHandle(source) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { size } = yield source.stat();
        const file = new file_js_2.AsyncRandomAccessFile(source, size);
        if (size >= message_js_1.magicX2AndPadding && (0, message_js_1.checkForMagicArrowString)(yield file.readAt(0, (message_js_1.magicLength + 7) & ~7))) {
            return new AsyncRecordBatchFileReader(new AsyncRecordBatchFileReaderImpl(file));
        }
        return new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(file));
    });
}

//# sourceMappingURL=reader.js.map


/***/ }),
/* 125 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileBlock = exports.Footer = void 0;
/* eslint-disable @typescript-eslint/naming-convention */
const block_js_1 = __webpack_require__(126);
const footer_js_1 = __webpack_require__(127);
const flatbuffers = __webpack_require__(57);
var Builder = flatbuffers.Builder;
var ByteBuffer = flatbuffers.ByteBuffer;
const schema_js_1 = __webpack_require__(128);
const enum_js_1 = __webpack_require__(48);
const buffer_js_1 = __webpack_require__(43);
const bigint_js_1 = __webpack_require__(111);
/** @ignore */
class Footer_ {
    /** @nocollapse */
    static decode(buf) {
        buf = new ByteBuffer((0, buffer_js_1.toUint8Array)(buf));
        const footer = footer_js_1.Footer.getRootAsFooter(buf);
        const schema = schema_js_1.Schema.decode(footer.schema(), new Map(), footer.version());
        return new OffHeapFooter(schema, footer);
    }
    /** @nocollapse */
    static encode(footer) {
        const b = new Builder();
        const schemaOffset = schema_js_1.Schema.encode(b, footer.schema);
        footer_js_1.Footer.startRecordBatchesVector(b, footer.numRecordBatches);
        for (const rb of [...footer.recordBatches()].slice().reverse()) {
            FileBlock.encode(b, rb);
        }
        const recordBatchesOffset = b.endVector();
        footer_js_1.Footer.startDictionariesVector(b, footer.numDictionaries);
        for (const db of [...footer.dictionaryBatches()].slice().reverse()) {
            FileBlock.encode(b, db);
        }
        const dictionaryBatchesOffset = b.endVector();
        footer_js_1.Footer.startFooter(b);
        footer_js_1.Footer.addSchema(b, schemaOffset);
        footer_js_1.Footer.addVersion(b, enum_js_1.MetadataVersion.V5);
        footer_js_1.Footer.addRecordBatches(b, recordBatchesOffset);
        footer_js_1.Footer.addDictionaries(b, dictionaryBatchesOffset);
        footer_js_1.Footer.finishFooterBuffer(b, footer_js_1.Footer.endFooter(b));
        return b.asUint8Array();
    }
    get numRecordBatches() { return this._recordBatches.length; }
    get numDictionaries() { return this._dictionaryBatches.length; }
    constructor(schema, version = enum_js_1.MetadataVersion.V5, recordBatches, dictionaryBatches) {
        this.schema = schema;
        this.version = version;
        recordBatches && (this._recordBatches = recordBatches);
        dictionaryBatches && (this._dictionaryBatches = dictionaryBatches);
    }
    *recordBatches() {
        for (let block, i = -1, n = this.numRecordBatches; ++i < n;) {
            if (block = this.getRecordBatch(i)) {
                yield block;
            }
        }
    }
    *dictionaryBatches() {
        for (let block, i = -1, n = this.numDictionaries; ++i < n;) {
            if (block = this.getDictionaryBatch(i)) {
                yield block;
            }
        }
    }
    getRecordBatch(index) {
        return index >= 0
            && index < this.numRecordBatches
            && this._recordBatches[index] || null;
    }
    getDictionaryBatch(index) {
        return index >= 0
            && index < this.numDictionaries
            && this._dictionaryBatches[index] || null;
    }
}
exports.Footer = Footer_;
/** @ignore */
class OffHeapFooter extends Footer_ {
    get numRecordBatches() { return this._footer.recordBatchesLength(); }
    get numDictionaries() { return this._footer.dictionariesLength(); }
    constructor(schema, _footer) {
        super(schema, _footer.version());
        this._footer = _footer;
    }
    getRecordBatch(index) {
        if (index >= 0 && index < this.numRecordBatches) {
            const fileBlock = this._footer.recordBatches(index);
            if (fileBlock) {
                return FileBlock.decode(fileBlock);
            }
        }
        return null;
    }
    getDictionaryBatch(index) {
        if (index >= 0 && index < this.numDictionaries) {
            const fileBlock = this._footer.dictionaries(index);
            if (fileBlock) {
                return FileBlock.decode(fileBlock);
            }
        }
        return null;
    }
}
/** @ignore */
class FileBlock {
    /** @nocollapse */
    static decode(block) {
        return new FileBlock(block.metaDataLength(), block.bodyLength(), block.offset());
    }
    /** @nocollapse */
    static encode(b, fileBlock) {
        const { metaDataLength } = fileBlock;
        const offset = BigInt(fileBlock.offset);
        const bodyLength = BigInt(fileBlock.bodyLength);
        return block_js_1.Block.createBlock(b, offset, metaDataLength, bodyLength);
    }
    constructor(metaDataLength, bodyLength, offset) {
        this.metaDataLength = metaDataLength;
        this.offset = (0, bigint_js_1.bigIntToNumber)(offset);
        this.bodyLength = (0, bigint_js_1.bigIntToNumber)(bodyLength);
    }
}
exports.FileBlock = FileBlock;

//# sourceMappingURL=file.js.map


/***/ }),
/* 126 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Block = void 0;
class Block {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    /**
     * Index to the start of the RecordBlock (note this is past the Message header)
     */
    offset() {
        return this.bb.readInt64(this.bb_pos);
    }
    /**
     * Length of the metadata
     */
    metaDataLength() {
        return this.bb.readInt32(this.bb_pos + 8);
    }
    /**
     * Length of the data (this is aligned so there can be a gap between this and
     * the metadata).
     */
    bodyLength() {
        return this.bb.readInt64(this.bb_pos + 16);
    }
    static sizeOf() {
        return 24;
    }
    static createBlock(builder, offset, metaDataLength, bodyLength) {
        builder.prep(8, 24);
        builder.writeInt64(BigInt(bodyLength !== null && bodyLength !== void 0 ? bodyLength : 0));
        builder.pad(4);
        builder.writeInt32(metaDataLength);
        builder.writeInt64(BigInt(offset !== null && offset !== void 0 ? offset : 0));
        return builder.offset();
    }
}
exports.Block = Block;

//# sourceMappingURL=block.js.map


/***/ }),
/* 127 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Footer = void 0;
const flatbuffers = __webpack_require__(57);
const block_js_1 = __webpack_require__(126);
const key_value_js_1 = __webpack_require__(75);
const metadata_version_js_1 = __webpack_require__(49);
const schema_js_1 = __webpack_require__(69);
/**
 * ----------------------------------------------------------------------
 * Arrow File metadata
 *
 */
class Footer {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsFooter(bb, obj) {
        return (obj || new Footer()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsFooter(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Footer()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    version() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : metadata_version_js_1.MetadataVersion.V1;
    }
    schema(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new schema_js_1.Schema()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    dictionaries(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new block_js_1.Block()).__init(this.bb.__vector(this.bb_pos + offset) + index * 24, this.bb) : null;
    }
    dictionariesLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    recordBatches(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new block_js_1.Block()).__init(this.bb.__vector(this.bb_pos + offset) + index * 24, this.bb) : null;
    }
    recordBatchesLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * User-defined metadata
     */
    customMetadata(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? (obj || new key_value_js_1.KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    customMetadataLength() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startFooter(builder) {
        builder.startObject(5);
    }
    static addVersion(builder, version) {
        builder.addFieldInt16(0, version, metadata_version_js_1.MetadataVersion.V1);
    }
    static addSchema(builder, schemaOffset) {
        builder.addFieldOffset(1, schemaOffset, 0);
    }
    static addDictionaries(builder, dictionariesOffset) {
        builder.addFieldOffset(2, dictionariesOffset, 0);
    }
    static startDictionariesVector(builder, numElems) {
        builder.startVector(24, numElems, 8);
    }
    static addRecordBatches(builder, recordBatchesOffset) {
        builder.addFieldOffset(3, recordBatchesOffset, 0);
    }
    static startRecordBatchesVector(builder, numElems) {
        builder.startVector(24, numElems, 8);
    }
    static addCustomMetadata(builder, customMetadataOffset) {
        builder.addFieldOffset(4, customMetadataOffset, 0);
    }
    static createCustomMetadataVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startCustomMetadataVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endFooter(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static finishFooterBuffer(builder, offset) {
        builder.finish(offset);
    }
    static finishSizePrefixedFooterBuffer(builder, offset) {
        builder.finish(offset, undefined, true);
    }
}
exports.Footer = Footer;

//# sourceMappingURL=footer.js.map


/***/ }),
/* 128 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Field = exports.Schema = void 0;
const enum_js_1 = __webpack_require__(48);
const type_js_1 = __webpack_require__(113);
class Schema {
    constructor(fields = [], metadata, dictionaries, metadataVersion = enum_js_1.MetadataVersion.V5) {
        this.fields = (fields || []);
        this.metadata = metadata || new Map();
        if (!dictionaries) {
            dictionaries = generateDictionaryMap(this.fields);
        }
        this.dictionaries = dictionaries;
        this.metadataVersion = metadataVersion;
    }
    get [Symbol.toStringTag]() { return 'Schema'; }
    get names() { return this.fields.map((f) => f.name); }
    toString() {
        return `Schema<{ ${this.fields.map((f, i) => `${i}: ${f}`).join(', ')} }>`;
    }
    /**
     * Construct a new Schema containing only specified fields.
     *
     * @param fieldNames Names of fields to keep.
     * @returns A new Schema of fields matching the specified names.
     */
    select(fieldNames) {
        const names = new Set(fieldNames);
        const fields = this.fields.filter((f) => names.has(f.name));
        return new Schema(fields, this.metadata);
    }
    /**
     * Construct a new Schema containing only fields at the specified indices.
     *
     * @param fieldIndices Indices of fields to keep.
     * @returns A new Schema of fields at the specified indices.
     */
    selectAt(fieldIndices) {
        const fields = fieldIndices.map((i) => this.fields[i]).filter(Boolean);
        return new Schema(fields, this.metadata);
    }
    assign(...args) {
        const other = (args[0] instanceof Schema
            ? args[0]
            : Array.isArray(args[0])
                ? new Schema(args[0])
                : new Schema(args));
        const curFields = [...this.fields];
        const metadata = mergeMaps(mergeMaps(new Map(), this.metadata), other.metadata);
        const newFields = other.fields.filter((f2) => {
            const i = curFields.findIndex((f) => f.name === f2.name);
            return ~i ? (curFields[i] = f2.clone({
                metadata: mergeMaps(mergeMaps(new Map(), curFields[i].metadata), f2.metadata)
            })) && false : true;
        });
        const newDictionaries = generateDictionaryMap(newFields, new Map());
        return new Schema([...curFields, ...newFields], metadata, new Map([...this.dictionaries, ...newDictionaries]));
    }
}
exports.Schema = Schema;
// Add these here so they're picked up by the externs creator
// in the build, and closure-compiler doesn't minify them away
Schema.prototype.fields = null;
Schema.prototype.metadata = null;
Schema.prototype.dictionaries = null;
class Field {
    /** @nocollapse */
    static new(...args) {
        let [name, type, nullable, metadata] = args;
        if (args[0] && typeof args[0] === 'object') {
            ({ name } = args[0]);
            (type === undefined) && (type = args[0].type);
            (nullable === undefined) && (nullable = args[0].nullable);
            (metadata === undefined) && (metadata = args[0].metadata);
        }
        return new Field(`${name}`, type, nullable, metadata);
    }
    constructor(name, type, nullable = false, metadata) {
        this.name = name;
        this.type = type;
        this.nullable = nullable;
        this.metadata = metadata || new Map();
    }
    get typeId() { return this.type.typeId; }
    get [Symbol.toStringTag]() { return 'Field'; }
    toString() { return `${this.name}: ${this.type}`; }
    clone(...args) {
        let [name, type, nullable, metadata] = args;
        (!args[0] || typeof args[0] !== 'object')
            ? ([name = this.name, type = this.type, nullable = this.nullable, metadata = this.metadata] = args)
            : ({ name = this.name, type = this.type, nullable = this.nullable, metadata = this.metadata } = args[0]);
        return Field.new(name, type, nullable, metadata);
    }
}
exports.Field = Field;
// Add these here so they're picked up by the externs creator
// in the build, and closure-compiler doesn't minify them away
Field.prototype.type = null;
Field.prototype.name = null;
Field.prototype.nullable = null;
Field.prototype.metadata = null;
/** @ignore */
function mergeMaps(m1, m2) {
    return new Map([...(m1 || new Map()), ...(m2 || new Map())]);
}
/** @ignore */
function generateDictionaryMap(fields, dictionaries = new Map()) {
    for (let i = -1, n = fields.length; ++i < n;) {
        const field = fields[i];
        const type = field.type;
        if (type_js_1.DataType.isDictionary(type)) {
            if (!dictionaries.has(type.id)) {
                dictionaries.set(type.id, type.dictionary);
            }
            else if (dictionaries.get(type.id) !== type.dictionary) {
                throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);
            }
        }
        if (type.children && type.children.length > 0) {
            generateDictionaryMap(type.children, dictionaries);
        }
    }
    return dictionaries;
}

//# sourceMappingURL=schema.js.map


/***/ }),
/* 129 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AsyncByteStream = exports.ByteStream = exports.AsyncByteQueue = void 0;
const tslib_1 = __webpack_require__(41);
const adapters_js_1 = __webpack_require__(42);
const utf8_js_1 = __webpack_require__(44);
const interfaces_js_1 = __webpack_require__(130);
const buffer_js_1 = __webpack_require__(43);
const compat_js_1 = __webpack_require__(45);
/** @ignore */
class AsyncByteQueue extends interfaces_js_1.AsyncQueue {
    write(value) {
        if ((value = (0, buffer_js_1.toUint8Array)(value)).byteLength > 0) {
            return super.write(value);
        }
    }
    toString(sync = false) {
        return sync
            ? (0, utf8_js_1.decodeUtf8)(this.toUint8Array(true))
            : this.toUint8Array(false).then(utf8_js_1.decodeUtf8);
    }
    toUint8Array(sync = false) {
        return sync ? (0, buffer_js_1.joinUint8Arrays)(this._values)[0] : (() => tslib_1.__awaiter(this, void 0, void 0, function* () {
            var _a, e_1, _b, _c;
            const buffers = [];
            let byteLength = 0;
            try {
                for (var _d = true, _e = tslib_1.__asyncValues(this), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const chunk = _c;
                    buffers.push(chunk);
                    byteLength += chunk.byteLength;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return (0, buffer_js_1.joinUint8Arrays)(buffers, byteLength)[0];
        }))();
    }
}
exports.AsyncByteQueue = AsyncByteQueue;
/** @ignore */
class ByteStream {
    constructor(source) {
        if (source) {
            this.source = new ByteStreamSource(adapters_js_1.default.fromIterable(source));
        }
    }
    [Symbol.iterator]() { return this; }
    next(value) { return this.source.next(value); }
    throw(value) { return this.source.throw(value); }
    return(value) { return this.source.return(value); }
    peek(size) { return this.source.peek(size); }
    read(size) { return this.source.read(size); }
}
exports.ByteStream = ByteStream;
/** @ignore */
class AsyncByteStream {
    constructor(source) {
        if (source instanceof AsyncByteStream) {
            this.source = source.source;
        }
        else if (source instanceof AsyncByteQueue) {
            this.source = new AsyncByteStreamSource(adapters_js_1.default.fromAsyncIterable(source));
        }
        else if ((0, compat_js_1.isReadableNodeStream)(source)) {
            this.source = new AsyncByteStreamSource(adapters_js_1.default.fromNodeStream(source));
        }
        else if ((0, compat_js_1.isReadableDOMStream)(source)) {
            this.source = new AsyncByteStreamSource(adapters_js_1.default.fromDOMStream(source));
        }
        else if ((0, compat_js_1.isFetchResponse)(source)) {
            this.source = new AsyncByteStreamSource(adapters_js_1.default.fromDOMStream(source.body));
        }
        else if ((0, compat_js_1.isIterable)(source)) {
            this.source = new AsyncByteStreamSource(adapters_js_1.default.fromIterable(source));
        }
        else if ((0, compat_js_1.isPromise)(source)) {
            this.source = new AsyncByteStreamSource(adapters_js_1.default.fromAsyncIterable(source));
        }
        else if ((0, compat_js_1.isAsyncIterable)(source)) {
            this.source = new AsyncByteStreamSource(adapters_js_1.default.fromAsyncIterable(source));
        }
    }
    [Symbol.asyncIterator]() { return this; }
    next(value) { return this.source.next(value); }
    throw(value) { return this.source.throw(value); }
    return(value) { return this.source.return(value); }
    get closed() { return this.source.closed; }
    cancel(reason) { return this.source.cancel(reason); }
    peek(size) { return this.source.peek(size); }
    read(size) { return this.source.read(size); }
}
exports.AsyncByteStream = AsyncByteStream;
/** @ignore */
class ByteStreamSource {
    constructor(source) {
        this.source = source;
    }
    cancel(reason) { this.return(reason); }
    peek(size) { return this.next(size, 'peek').value; }
    read(size) { return this.next(size, 'read').value; }
    next(size, cmd = 'read') { return this.source.next({ cmd, size }); }
    throw(value) { return Object.create((this.source.throw && this.source.throw(value)) || interfaces_js_1.ITERATOR_DONE); }
    return(value) { return Object.create((this.source.return && this.source.return(value)) || interfaces_js_1.ITERATOR_DONE); }
}
/** @ignore */
class AsyncByteStreamSource {
    constructor(source) {
        this.source = source;
        this._closedPromise = new Promise((r) => this._closedPromiseResolve = r);
    }
    cancel(reason) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { yield this.return(reason); });
    }
    get closed() { return this._closedPromise; }
    read(size) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { return (yield this.next(size, 'read')).value; });
    }
    peek(size) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { return (yield this.next(size, 'peek')).value; });
    }
    next(size_1) {
        return tslib_1.__awaiter(this, arguments, void 0, function* (size, cmd = 'read') { return (yield this.source.next({ cmd, size })); });
    }
    throw(value) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const result = (this.source.throw && (yield this.source.throw(value))) || interfaces_js_1.ITERATOR_DONE;
            this._closedPromiseResolve && this._closedPromiseResolve();
            this._closedPromiseResolve = undefined;
            return Object.create(result);
        });
    }
    return(value) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const result = (this.source.return && (yield this.source.return(value))) || interfaces_js_1.ITERATOR_DONE;
            this._closedPromiseResolve && this._closedPromiseResolve();
            this._closedPromiseResolve = undefined;
            return Object.create(result);
        });
    }
}

//# sourceMappingURL=stream.js.map


/***/ }),
/* 130 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AsyncQueue = exports.ReadableInterop = exports.ArrowJSON = exports.ITERATOR_DONE = void 0;
const tslib_1 = __webpack_require__(41);
const adapters_js_1 = __webpack_require__(42);
/** @ignore */
exports.ITERATOR_DONE = Object.freeze({ done: true, value: void (0) });
/** @ignore */
class ArrowJSON {
    constructor(_json) {
        this._json = _json;
    }
    get schema() { return this._json['schema']; }
    get batches() { return (this._json['batches'] || []); }
    get dictionaries() { return (this._json['dictionaries'] || []); }
}
exports.ArrowJSON = ArrowJSON;
/** @ignore */
class ReadableInterop {
    tee() {
        return this._getDOMStream().tee();
    }
    pipe(writable, options) {
        return this._getNodeStream().pipe(writable, options);
    }
    pipeTo(writable, options) { return this._getDOMStream().pipeTo(writable, options); }
    pipeThrough(duplex, options) {
        return this._getDOMStream().pipeThrough(duplex, options);
    }
    _getDOMStream() {
        return this._DOMStream || (this._DOMStream = this.toDOMStream());
    }
    _getNodeStream() {
        return this._nodeStream || (this._nodeStream = this.toNodeStream());
    }
}
exports.ReadableInterop = ReadableInterop;
/** @ignore */
class AsyncQueue extends ReadableInterop {
    constructor() {
        super();
        this._values = [];
        this.resolvers = [];
        this._closedPromise = new Promise((r) => this._closedPromiseResolve = r);
    }
    get closed() { return this._closedPromise; }
    cancel(reason) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { yield this.return(reason); });
    }
    write(value) {
        if (this._ensureOpen()) {
            this.resolvers.length <= 0
                ? (this._values.push(value))
                : (this.resolvers.shift().resolve({ done: false, value }));
        }
    }
    abort(value) {
        if (this._closedPromiseResolve) {
            this.resolvers.length <= 0
                ? (this._error = { error: value })
                : (this.resolvers.shift().reject({ done: true, value }));
        }
    }
    close() {
        if (this._closedPromiseResolve) {
            const { resolvers } = this;
            while (resolvers.length > 0) {
                resolvers.shift().resolve(exports.ITERATOR_DONE);
            }
            this._closedPromiseResolve();
            this._closedPromiseResolve = undefined;
        }
    }
    [Symbol.asyncIterator]() { return this; }
    toDOMStream(options) {
        return adapters_js_1.default.toDOMStream((this._closedPromiseResolve || this._error)
            ? this
            : this._values, options);
    }
    toNodeStream(options) {
        return adapters_js_1.default.toNodeStream((this._closedPromiseResolve || this._error)
            ? this
            : this._values, options);
    }
    throw(_) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { yield this.abort(_); return exports.ITERATOR_DONE; });
    }
    return(_) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { yield this.close(); return exports.ITERATOR_DONE; });
    }
    read(size) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { return (yield this.next(size, 'read')).value; });
    }
    peek(size) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { return (yield this.next(size, 'peek')).value; });
    }
    next(..._args) {
        if (this._values.length > 0) {
            return Promise.resolve({ done: false, value: this._values.shift() });
        }
        else if (this._error) {
            return Promise.reject({ done: true, value: this._error.error });
        }
        else if (!this._closedPromiseResolve) {
            return Promise.resolve(exports.ITERATOR_DONE);
        }
        else {
            return new Promise((resolve, reject) => {
                this.resolvers.push({ resolve, reject });
            });
        }
    }
    _ensureOpen() {
        if (this._closedPromiseResolve) {
            return true;
        }
        throw new Error(`AsyncQueue is closed`);
    }
}
exports.AsyncQueue = AsyncQueue;

//# sourceMappingURL=interfaces.js.map


/***/ }),
/* 131 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AsyncRandomAccessFile = exports.RandomAccessFile = void 0;
const tslib_1 = __webpack_require__(41);
const stream_js_1 = __webpack_require__(129);
const buffer_js_1 = __webpack_require__(43);
/** @ignore */
class RandomAccessFile extends stream_js_1.ByteStream {
    constructor(buffer, byteLength) {
        super();
        this.position = 0;
        this.buffer = (0, buffer_js_1.toUint8Array)(buffer);
        this.size = byteLength === undefined ? this.buffer.byteLength : byteLength;
    }
    readInt32(position) {
        const { buffer, byteOffset } = this.readAt(position, 4);
        return new DataView(buffer, byteOffset).getInt32(0, true);
    }
    seek(position) {
        this.position = Math.min(position, this.size);
        return position < this.size;
    }
    read(nBytes) {
        const { buffer, size, position } = this;
        if (buffer && position < size) {
            if (typeof nBytes !== 'number') {
                nBytes = Number.POSITIVE_INFINITY;
            }
            this.position = Math.min(size, position + Math.min(size - position, nBytes));
            return buffer.subarray(position, this.position);
        }
        return null;
    }
    readAt(position, nBytes) {
        const buf = this.buffer;
        const end = Math.min(this.size, position + nBytes);
        return buf ? buf.subarray(position, end) : new Uint8Array(nBytes);
    }
    close() { this.buffer && (this.buffer = null); }
    throw(value) { this.close(); return { done: true, value }; }
    return(value) { this.close(); return { done: true, value }; }
}
exports.RandomAccessFile = RandomAccessFile;
/** @ignore */
class AsyncRandomAccessFile extends stream_js_1.AsyncByteStream {
    constructor(file, byteLength) {
        super();
        this.position = 0;
        this._handle = file;
        if (typeof byteLength === 'number') {
            this.size = byteLength;
        }
        else {
            this._pending = (() => tslib_1.__awaiter(this, void 0, void 0, function* () {
                this.size = (yield file.stat()).size;
                delete this._pending;
            }))();
        }
    }
    readInt32(position) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { buffer, byteOffset } = yield this.readAt(position, 4);
            return new DataView(buffer, byteOffset).getInt32(0, true);
        });
    }
    seek(position) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this._pending && (yield this._pending);
            this.position = Math.min(position, this.size);
            return position < this.size;
        });
    }
    read(nBytes) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this._pending && (yield this._pending);
            const { _handle: file, size, position } = this;
            if (file && position < size) {
                if (typeof nBytes !== 'number') {
                    nBytes = Number.POSITIVE_INFINITY;
                }
                let pos = position, offset = 0, bytesRead = 0;
                const end = Math.min(size, pos + Math.min(size - pos, nBytes));
                const buffer = new Uint8Array(Math.max(0, (this.position = end) - pos));
                while ((pos += bytesRead) < end && (offset += bytesRead) < buffer.byteLength) {
                    ({ bytesRead } = yield file.read(buffer, offset, buffer.byteLength - offset, pos));
                }
                return buffer;
            }
            return null;
        });
    }
    readAt(position, nBytes) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this._pending && (yield this._pending);
            const { _handle: file, size } = this;
            if (file && (position + nBytes) < size) {
                const end = Math.min(size, position + nBytes);
                const buffer = new Uint8Array(end - position);
                return (yield file.read(buffer, 0, nBytes, position)).buffer;
            }
            return new Uint8Array(nBytes);
        });
    }
    close() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { const f = this._handle; this._handle = null; f && (yield f.close()); });
    }
    throw(value) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { yield this.close(); return { done: true, value }; });
    }
    return(value) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { yield this.close(); return { done: true, value }; });
    }
}
exports.AsyncRandomAccessFile = AsyncRandomAccessFile;

//# sourceMappingURL=file.js.map


/***/ }),
/* 132 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JSONVectorLoader = exports.VectorLoader = void 0;
const data_js_1 = __webpack_require__(117);
const schema_js_1 = __webpack_require__(128);
const type_js_1 = __webpack_require__(113);
const visitor_js_1 = __webpack_require__(112);
const bit_js_1 = __webpack_require__(118);
const utf8_js_1 = __webpack_require__(44);
const int_js_1 = __webpack_require__(133);
const enum_js_1 = __webpack_require__(48);
const buffer_js_1 = __webpack_require__(43);
/** @ignore */
class VectorLoader extends visitor_js_1.Visitor {
    constructor(bytes, nodes, buffers, dictionaries, metadataVersion = enum_js_1.MetadataVersion.V5) {
        super();
        this.nodesIndex = -1;
        this.buffersIndex = -1;
        this.bytes = bytes;
        this.nodes = nodes;
        this.buffers = buffers;
        this.dictionaries = dictionaries;
        this.metadataVersion = metadataVersion;
    }
    visit(node) {
        return super.visit(node instanceof schema_js_1.Field ? node.type : node);
    }
    visitNull(type, { length } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length });
    }
    visitBool(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitInt(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitFloat(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitUtf8(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), data: this.readData(type) });
    }
    visitLargeUtf8(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), data: this.readData(type) });
    }
    visitBinary(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), data: this.readData(type) });
    }
    visitLargeBinary(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), data: this.readData(type) });
    }
    visitFixedSizeBinary(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitDate(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitTimestamp(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitTime(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitDecimal(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitList(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), 'child': this.visit(type.children[0]) });
    }
    visitStruct(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), children: this.visitMany(type.children) });
    }
    visitUnion(type, { length, nullCount } = this.nextFieldNode()) {
        if (this.metadataVersion < enum_js_1.MetadataVersion.V5) {
            this.readNullBitmap(type, nullCount);
        }
        return type.mode === enum_js_1.UnionMode.Sparse
            ? this.visitSparseUnion(type, { length, nullCount })
            : this.visitDenseUnion(type, { length, nullCount });
    }
    visitDenseUnion(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, typeIds: this.readTypeIds(type), valueOffsets: this.readOffsets(type), children: this.visitMany(type.children) });
    }
    visitSparseUnion(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, typeIds: this.readTypeIds(type), children: this.visitMany(type.children) });
    }
    visitDictionary(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type.indices), dictionary: this.readDictionary(type) });
    }
    visitInterval(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitDuration(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitFixedSizeList(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), 'child': this.visit(type.children[0]) });
    }
    visitMap(type, { length, nullCount } = this.nextFieldNode()) {
        return (0, data_js_1.makeData)({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), 'child': this.visit(type.children[0]) });
    }
    nextFieldNode() { return this.nodes[++this.nodesIndex]; }
    nextBufferRange() { return this.buffers[++this.buffersIndex]; }
    readNullBitmap(type, nullCount, buffer = this.nextBufferRange()) {
        return nullCount > 0 && this.readData(type, buffer) || new Uint8Array(0);
    }
    readOffsets(type, buffer) { return this.readData(type, buffer); }
    readTypeIds(type, buffer) { return this.readData(type, buffer); }
    readData(_type, { length, offset } = this.nextBufferRange()) {
        return this.bytes.subarray(offset, offset + length);
    }
    readDictionary(type) {
        return this.dictionaries.get(type.id);
    }
}
exports.VectorLoader = VectorLoader;
/** @ignore */
class JSONVectorLoader extends VectorLoader {
    constructor(sources, nodes, buffers, dictionaries, metadataVersion) {
        super(new Uint8Array(0), nodes, buffers, dictionaries, metadataVersion);
        this.sources = sources;
    }
    readNullBitmap(_type, nullCount, { offset } = this.nextBufferRange()) {
        return nullCount <= 0 ? new Uint8Array(0) : (0, bit_js_1.packBools)(this.sources[offset]);
    }
    readOffsets(_type, { offset } = this.nextBufferRange()) {
        return (0, buffer_js_1.toArrayBufferView)(Uint8Array, (0, buffer_js_1.toArrayBufferView)(_type.OffsetArrayType, this.sources[offset]));
    }
    readTypeIds(type, { offset } = this.nextBufferRange()) {
        return (0, buffer_js_1.toArrayBufferView)(Uint8Array, (0, buffer_js_1.toArrayBufferView)(type.ArrayType, this.sources[offset]));
    }
    readData(type, { offset } = this.nextBufferRange()) {
        const { sources } = this;
        if (type_js_1.DataType.isTimestamp(type)) {
            return (0, buffer_js_1.toArrayBufferView)(Uint8Array, int_js_1.Int64.convertArray(sources[offset]));
        }
        else if ((type_js_1.DataType.isInt(type) || type_js_1.DataType.isTime(type)) && type.bitWidth === 64 || type_js_1.DataType.isDuration(type)) {
            return (0, buffer_js_1.toArrayBufferView)(Uint8Array, int_js_1.Int64.convertArray(sources[offset]));
        }
        else if (type_js_1.DataType.isDate(type) && type.unit === enum_js_1.DateUnit.MILLISECOND) {
            return (0, buffer_js_1.toArrayBufferView)(Uint8Array, int_js_1.Int64.convertArray(sources[offset]));
        }
        else if (type_js_1.DataType.isDecimal(type)) {
            return (0, buffer_js_1.toArrayBufferView)(Uint8Array, int_js_1.Int128.convertArray(sources[offset]));
        }
        else if (type_js_1.DataType.isBinary(type) || type_js_1.DataType.isLargeBinary(type) || type_js_1.DataType.isFixedSizeBinary(type)) {
            return binaryDataFromJSON(sources[offset]);
        }
        else if (type_js_1.DataType.isBool(type)) {
            return (0, bit_js_1.packBools)(sources[offset]);
        }
        else if (type_js_1.DataType.isUtf8(type) || type_js_1.DataType.isLargeUtf8(type)) {
            return (0, utf8_js_1.encodeUtf8)(sources[offset].join(''));
        }
        return (0, buffer_js_1.toArrayBufferView)(Uint8Array, (0, buffer_js_1.toArrayBufferView)(type.ArrayType, sources[offset].map((x) => +x)));
    }
}
exports.JSONVectorLoader = JSONVectorLoader;
/** @ignore */
function binaryDataFromJSON(values) {
    // "DATA": ["49BC7D5B6C47D2","3F5FB6D9322026"]
    // There are definitely more efficient ways to do this... but it gets the
    // job done.
    const joined = values.join('');
    const data = new Uint8Array(joined.length / 2);
    for (let i = 0; i < joined.length; i += 2) {
        data[i >> 1] = Number.parseInt(joined.slice(i, i + 2), 16);
    }
    return data;
}

//# sourceMappingURL=vectorloader.js.map


/***/ }),
/* 133 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Int128 = exports.Int64 = exports.Uint64 = exports.BaseInt64 = void 0;
/** @ignore */
const carryBit16 = 1 << 16;
/** @ignore */
function intAsHex(value) {
    if (value < 0) {
        value = 0xFFFFFFFF + value + 1;
    }
    return `0x${value.toString(16)}`;
}
/** @ignore */
const kInt32DecimalDigits = 8;
/** @ignore */
const kPowersOfTen = [
    1,
    10,
    100,
    1000,
    10000,
    100000,
    1000000,
    10000000,
    100000000
];
/** @ignore */
class BaseInt64 {
    constructor(buffer) {
        this.buffer = buffer;
    }
    high() { return this.buffer[1]; }
    low() { return this.buffer[0]; }
    _times(other) {
        // Break the left and right numbers into 16 bit chunks
        // so that we can multiply them without overflow.
        const L = new Uint32Array([
            this.buffer[1] >>> 16,
            this.buffer[1] & 0xFFFF,
            this.buffer[0] >>> 16,
            this.buffer[0] & 0xFFFF
        ]);
        const R = new Uint32Array([
            other.buffer[1] >>> 16,
            other.buffer[1] & 0xFFFF,
            other.buffer[0] >>> 16,
            other.buffer[0] & 0xFFFF
        ]);
        let product = L[3] * R[3];
        this.buffer[0] = product & 0xFFFF;
        let sum = product >>> 16;
        product = L[2] * R[3];
        sum += product;
        product = (L[3] * R[2]) >>> 0;
        sum += product;
        this.buffer[0] += sum << 16;
        this.buffer[1] = (sum >>> 0 < product ? carryBit16 : 0);
        this.buffer[1] += sum >>> 16;
        this.buffer[1] += L[1] * R[3] + L[2] * R[2] + L[3] * R[1];
        this.buffer[1] += (L[0] * R[3] + L[1] * R[2] + L[2] * R[1] + L[3] * R[0]) << 16;
        return this;
    }
    _plus(other) {
        const sum = (this.buffer[0] + other.buffer[0]) >>> 0;
        this.buffer[1] += other.buffer[1];
        if (sum < (this.buffer[0] >>> 0)) {
            ++this.buffer[1];
        }
        this.buffer[0] = sum;
    }
    lessThan(other) {
        return this.buffer[1] < other.buffer[1] ||
            (this.buffer[1] === other.buffer[1] && this.buffer[0] < other.buffer[0]);
    }
    equals(other) {
        return this.buffer[1] === other.buffer[1] && this.buffer[0] == other.buffer[0];
    }
    greaterThan(other) {
        return other.lessThan(this);
    }
    hex() {
        return `${intAsHex(this.buffer[1])} ${intAsHex(this.buffer[0])}`;
    }
}
exports.BaseInt64 = BaseInt64;
/** @ignore */
class Uint64 extends BaseInt64 {
    times(other) {
        this._times(other);
        return this;
    }
    plus(other) {
        this._plus(other);
        return this;
    }
    /** @nocollapse */
    static from(val, out_buffer = new Uint32Array(2)) {
        return Uint64.fromString(typeof (val) === 'string' ? val : val.toString(), out_buffer);
    }
    /** @nocollapse */
    static fromNumber(num, out_buffer = new Uint32Array(2)) {
        // Always parse numbers as strings - pulling out high and low bits
        // directly seems to lose precision sometimes
        // For example:
        //     > -4613034156400212000 >>> 0
        //     721782784
        // The correct lower 32-bits are 721782752
        return Uint64.fromString(num.toString(), out_buffer);
    }
    /** @nocollapse */
    static fromString(str, out_buffer = new Uint32Array(2)) {
        const length = str.length;
        const out = new Uint64(out_buffer);
        for (let posn = 0; posn < length;) {
            const group = kInt32DecimalDigits < length - posn ?
                kInt32DecimalDigits : length - posn;
            const chunk = new Uint64(new Uint32Array([Number.parseInt(str.slice(posn, posn + group), 10), 0]));
            const multiple = new Uint64(new Uint32Array([kPowersOfTen[group], 0]));
            out.times(multiple);
            out.plus(chunk);
            posn += group;
        }
        return out;
    }
    /** @nocollapse */
    static convertArray(values) {
        const data = new Uint32Array(values.length * 2);
        for (let i = -1, n = values.length; ++i < n;) {
            Uint64.from(values[i], new Uint32Array(data.buffer, data.byteOffset + 2 * i * 4, 2));
        }
        return data;
    }
    /** @nocollapse */
    static multiply(left, right) {
        const rtrn = new Uint64(new Uint32Array(left.buffer));
        return rtrn.times(right);
    }
    /** @nocollapse */
    static add(left, right) {
        const rtrn = new Uint64(new Uint32Array(left.buffer));
        return rtrn.plus(right);
    }
}
exports.Uint64 = Uint64;
/** @ignore */
class Int64 extends BaseInt64 {
    negate() {
        this.buffer[0] = ~this.buffer[0] + 1;
        this.buffer[1] = ~this.buffer[1];
        if (this.buffer[0] == 0) {
            ++this.buffer[1];
        }
        return this;
    }
    times(other) {
        this._times(other);
        return this;
    }
    plus(other) {
        this._plus(other);
        return this;
    }
    lessThan(other) {
        // force high bytes to be signed
        // eslint-disable-next-line unicorn/prefer-math-trunc
        const this_high = this.buffer[1] << 0;
        // eslint-disable-next-line unicorn/prefer-math-trunc
        const other_high = other.buffer[1] << 0;
        return this_high < other_high ||
            (this_high === other_high && this.buffer[0] < other.buffer[0]);
    }
    /** @nocollapse */
    static from(val, out_buffer = new Uint32Array(2)) {
        return Int64.fromString(typeof (val) === 'string' ? val : val.toString(), out_buffer);
    }
    /** @nocollapse */
    static fromNumber(num, out_buffer = new Uint32Array(2)) {
        // Always parse numbers as strings - pulling out high and low bits
        // directly seems to lose precision sometimes
        // For example:
        //     > -4613034156400212000 >>> 0
        //     721782784
        // The correct lower 32-bits are 721782752
        return Int64.fromString(num.toString(), out_buffer);
    }
    /** @nocollapse */
    static fromString(str, out_buffer = new Uint32Array(2)) {
        // TODO: Assert that out_buffer is 0 and length = 2
        const negate = str.startsWith('-');
        const length = str.length;
        const out = new Int64(out_buffer);
        for (let posn = negate ? 1 : 0; posn < length;) {
            const group = kInt32DecimalDigits < length - posn ?
                kInt32DecimalDigits : length - posn;
            const chunk = new Int64(new Uint32Array([Number.parseInt(str.slice(posn, posn + group), 10), 0]));
            const multiple = new Int64(new Uint32Array([kPowersOfTen[group], 0]));
            out.times(multiple);
            out.plus(chunk);
            posn += group;
        }
        return negate ? out.negate() : out;
    }
    /** @nocollapse */
    static convertArray(values) {
        const data = new Uint32Array(values.length * 2);
        for (let i = -1, n = values.length; ++i < n;) {
            Int64.from(values[i], new Uint32Array(data.buffer, data.byteOffset + 2 * i * 4, 2));
        }
        return data;
    }
    /** @nocollapse */
    static multiply(left, right) {
        const rtrn = new Int64(new Uint32Array(left.buffer));
        return rtrn.times(right);
    }
    /** @nocollapse */
    static add(left, right) {
        const rtrn = new Int64(new Uint32Array(left.buffer));
        return rtrn.plus(right);
    }
}
exports.Int64 = Int64;
/** @ignore */
class Int128 {
    constructor(buffer) {
        this.buffer = buffer;
        // buffer[3] MSB (high)
        // buffer[2]
        // buffer[1]
        // buffer[0] LSB (low)
    }
    high() {
        return new Int64(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));
    }
    low() {
        return new Int64(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset, 2));
    }
    negate() {
        this.buffer[0] = ~this.buffer[0] + 1;
        this.buffer[1] = ~this.buffer[1];
        this.buffer[2] = ~this.buffer[2];
        this.buffer[3] = ~this.buffer[3];
        if (this.buffer[0] == 0) {
            ++this.buffer[1];
        }
        if (this.buffer[1] == 0) {
            ++this.buffer[2];
        }
        if (this.buffer[2] == 0) {
            ++this.buffer[3];
        }
        return this;
    }
    times(other) {
        // Break the left and right numbers into 32 bit chunks
        // so that we can multiply them without overflow.
        const L0 = new Uint64(new Uint32Array([this.buffer[3], 0]));
        const L1 = new Uint64(new Uint32Array([this.buffer[2], 0]));
        const L2 = new Uint64(new Uint32Array([this.buffer[1], 0]));
        const L3 = new Uint64(new Uint32Array([this.buffer[0], 0]));
        const R0 = new Uint64(new Uint32Array([other.buffer[3], 0]));
        const R1 = new Uint64(new Uint32Array([other.buffer[2], 0]));
        const R2 = new Uint64(new Uint32Array([other.buffer[1], 0]));
        const R3 = new Uint64(new Uint32Array([other.buffer[0], 0]));
        let product = Uint64.multiply(L3, R3);
        this.buffer[0] = product.low();
        const sum = new Uint64(new Uint32Array([product.high(), 0]));
        product = Uint64.multiply(L2, R3);
        sum.plus(product);
        product = Uint64.multiply(L3, R2);
        sum.plus(product);
        this.buffer[1] = sum.low();
        this.buffer[3] = (sum.lessThan(product) ? 1 : 0);
        this.buffer[2] = sum.high();
        const high = new Uint64(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));
        high.plus(Uint64.multiply(L1, R3))
            .plus(Uint64.multiply(L2, R2))
            .plus(Uint64.multiply(L3, R1));
        this.buffer[3] += Uint64.multiply(L0, R3)
            .plus(Uint64.multiply(L1, R2))
            .plus(Uint64.multiply(L2, R1))
            .plus(Uint64.multiply(L3, R0)).low();
        return this;
    }
    plus(other) {
        const sums = new Uint32Array(4);
        sums[3] = (this.buffer[3] + other.buffer[3]) >>> 0;
        sums[2] = (this.buffer[2] + other.buffer[2]) >>> 0;
        sums[1] = (this.buffer[1] + other.buffer[1]) >>> 0;
        sums[0] = (this.buffer[0] + other.buffer[0]) >>> 0;
        if (sums[0] < (this.buffer[0] >>> 0)) {
            ++sums[1];
        }
        if (sums[1] < (this.buffer[1] >>> 0)) {
            ++sums[2];
        }
        if (sums[2] < (this.buffer[2] >>> 0)) {
            ++sums[3];
        }
        this.buffer[3] = sums[3];
        this.buffer[2] = sums[2];
        this.buffer[1] = sums[1];
        this.buffer[0] = sums[0];
        return this;
    }
    hex() {
        return `${intAsHex(this.buffer[3])} ${intAsHex(this.buffer[2])} ${intAsHex(this.buffer[1])} ${intAsHex(this.buffer[0])}`;
    }
    /** @nocollapse */
    static multiply(left, right) {
        const rtrn = new Int128(new Uint32Array(left.buffer));
        return rtrn.times(right);
    }
    /** @nocollapse */
    static add(left, right) {
        const rtrn = new Int128(new Uint32Array(left.buffer));
        return rtrn.plus(right);
    }
    /** @nocollapse */
    static from(val, out_buffer = new Uint32Array(4)) {
        return Int128.fromString(typeof (val) === 'string' ? val : val.toString(), out_buffer);
    }
    /** @nocollapse */
    static fromNumber(num, out_buffer = new Uint32Array(4)) {
        // Always parse numbers as strings - pulling out high and low bits
        // directly seems to lose precision sometimes
        // For example:
        //     > -4613034156400212000 >>> 0
        //     721782784
        // The correct lower 32-bits are 721782752
        return Int128.fromString(num.toString(), out_buffer);
    }
    /** @nocollapse */
    static fromString(str, out_buffer = new Uint32Array(4)) {
        // TODO: Assert that out_buffer is 0 and length = 4
        const negate = str.startsWith('-');
        const length = str.length;
        const out = new Int128(out_buffer);
        for (let posn = negate ? 1 : 0; posn < length;) {
            const group = kInt32DecimalDigits < length - posn ?
                kInt32DecimalDigits : length - posn;
            const chunk = new Int128(new Uint32Array([Number.parseInt(str.slice(posn, posn + group), 10), 0, 0, 0]));
            const multiple = new Int128(new Uint32Array([kPowersOfTen[group], 0, 0, 0]));
            out.times(multiple);
            out.plus(chunk);
            posn += group;
        }
        return negate ? out.negate() : out;
    }
    /** @nocollapse */
    static convertArray(values) {
        // TODO: Distinguish between string and number at compile-time
        const data = new Uint32Array(values.length * 4);
        for (let i = -1, n = values.length; ++i < n;) {
            Int128.from(values[i], new Uint32Array(data.buffer, data.byteOffset + 4 * 4 * i, 4));
        }
        return data;
    }
}
exports.Int128 = Int128;

//# sourceMappingURL=int.js.map


/***/ }),
/* 134 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._InternalEmptyPlaceholderRecordBatch = exports.RecordBatch = void 0;
const data_js_1 = __webpack_require__(117);
const table_js_1 = __webpack_require__(135);
const vector_js_1 = __webpack_require__(47);
const schema_js_1 = __webpack_require__(128);
const type_js_1 = __webpack_require__(113);
const vector_js_2 = __webpack_require__(106);
const get_js_1 = __webpack_require__(109);
const set_js_1 = __webpack_require__(115);
const indexof_js_1 = __webpack_require__(120);
const iterator_js_1 = __webpack_require__(121);
/** @ignore */
class RecordBatch {
    constructor(...args) {
        switch (args.length) {
            case 2: {
                [this.schema] = args;
                if (!(this.schema instanceof schema_js_1.Schema)) {
                    throw new TypeError('RecordBatch constructor expects a [Schema, Data] pair.');
                }
                [,
                    this.data = (0, data_js_1.makeData)({
                        nullCount: 0,
                        type: new type_js_1.Struct(this.schema.fields),
                        children: this.schema.fields.map((f) => (0, data_js_1.makeData)({ type: f.type, nullCount: 0 }))
                    })
                ] = args;
                if (!(this.data instanceof data_js_1.Data)) {
                    throw new TypeError('RecordBatch constructor expects a [Schema, Data] pair.');
                }
                [this.schema, this.data] = ensureSameLengthData(this.schema, this.data.children);
                break;
            }
            case 1: {
                const [obj] = args;
                const { fields, children, length } = Object.keys(obj).reduce((memo, name, i) => {
                    memo.children[i] = obj[name];
                    memo.length = Math.max(memo.length, obj[name].length);
                    memo.fields[i] = schema_js_1.Field.new({ name, type: obj[name].type, nullable: true });
                    return memo;
                }, {
                    length: 0,
                    fields: new Array(),
                    children: new Array(),
                });
                const schema = new schema_js_1.Schema(fields);
                const data = (0, data_js_1.makeData)({ type: new type_js_1.Struct(fields), length, children, nullCount: 0 });
                [this.schema, this.data] = ensureSameLengthData(schema, data.children, length);
                break;
            }
            default: throw new TypeError('RecordBatch constructor expects an Object mapping names to child Data, or a [Schema, Data] pair.');
        }
    }
    get dictionaries() {
        return this._dictionaries || (this._dictionaries = collectDictionaries(this.schema.fields, this.data.children));
    }
    /**
     * The number of columns in this RecordBatch.
     */
    get numCols() { return this.schema.fields.length; }
    /**
     * The number of rows in this RecordBatch.
     */
    get numRows() { return this.data.length; }
    /**
     * The number of null rows in this RecordBatch.
     */
    get nullCount() {
        return this.data.nullCount;
    }
    /**
     * Check whether an row is null.
     * @param index The index at which to read the validity bitmap.
     */
    isValid(index) {
        return this.data.getValid(index);
    }
    /**
     * Get a row by position.
     * @param index The index of the row to read.
     */
    get(index) {
        return get_js_1.instance.visit(this.data, index);
    }
    /**
      * Get a row value by position.
      * @param index The index of the row to read. A negative index will count back from the last row.
      */
    at(index) {
        return this.get((0, vector_js_2.wrapIndex)(index, this.numRows));
    }
    /**
     * Set a row by position.
     * @param index The index of the row to write.
     * @param value The value to set.
     */
    set(index, value) {
        return set_js_1.instance.visit(this.data, index, value);
    }
    /**
     * Retrieve the index of the first occurrence of a row in an RecordBatch.
     * @param element The row to locate in the RecordBatch.
     * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
     */
    indexOf(element, offset) {
        return indexof_js_1.instance.visit(this.data, element, offset);
    }
    /**
     * Iterator for rows in this RecordBatch.
     */
    [Symbol.iterator]() {
        return iterator_js_1.instance.visit(new vector_js_1.Vector([this.data]));
    }
    /**
     * Return a JavaScript Array of the RecordBatch rows.
     * @returns An Array of RecordBatch rows.
     */
    toArray() {
        return [...this];
    }
    /**
     * Combines two or more RecordBatch of the same schema.
     * @param others Additional RecordBatch to add to the end of this RecordBatch.
     */
    concat(...others) {
        return new table_js_1.Table(this.schema, [this, ...others]);
    }
    /**
     * Return a zero-copy sub-section of this RecordBatch.
     * @param start The beginning of the specified portion of the RecordBatch.
     * @param end The end of the specified portion of the RecordBatch. This is exclusive of the row at the index 'end'.
     */
    slice(begin, end) {
        const [slice] = new vector_js_1.Vector([this.data]).slice(begin, end).data;
        return new RecordBatch(this.schema, slice);
    }
    /**
     * Returns a child Vector by name, or null if this Vector has no child with the given name.
     * @param name The name of the child to retrieve.
     */
    getChild(name) {
        var _b;
        return this.getChildAt((_b = this.schema.fields) === null || _b === void 0 ? void 0 : _b.findIndex((f) => f.name === name));
    }
    /**
     * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
     * @param index The index of the child to retrieve.
     */
    getChildAt(index) {
        if (index > -1 && index < this.schema.fields.length) {
            return new vector_js_1.Vector([this.data.children[index]]);
        }
        return null;
    }
    /**
     * Sets a child Vector by name.
     * @param name The name of the child to overwrite.
     * @returns A new RecordBatch with the new child for the specified name.
     */
    setChild(name, child) {
        var _b;
        return this.setChildAt((_b = this.schema.fields) === null || _b === void 0 ? void 0 : _b.findIndex((f) => f.name === name), child);
    }
    setChildAt(index, child) {
        let schema = this.schema;
        let data = this.data;
        if (index > -1 && index < this.numCols) {
            if (!child) {
                child = new vector_js_1.Vector([(0, data_js_1.makeData)({ type: new type_js_1.Null, length: this.numRows })]);
            }
            const fields = schema.fields.slice();
            const children = data.children.slice();
            const field = fields[index].clone({ type: child.type });
            [fields[index], children[index]] = [field, child.data[0]];
            schema = new schema_js_1.Schema(fields, new Map(this.schema.metadata));
            data = (0, data_js_1.makeData)({ type: new type_js_1.Struct(fields), children });
        }
        return new RecordBatch(schema, data);
    }
    /**
     * Construct a new RecordBatch containing only specified columns.
     *
     * @param columnNames Names of columns to keep.
     * @returns A new RecordBatch of columns matching the specified names.
     */
    select(columnNames) {
        const schema = this.schema.select(columnNames);
        const type = new type_js_1.Struct(schema.fields);
        const children = [];
        for (const name of columnNames) {
            const index = this.schema.fields.findIndex((f) => f.name === name);
            if (~index) {
                children[index] = this.data.children[index];
            }
        }
        return new RecordBatch(schema, (0, data_js_1.makeData)({ type, length: this.numRows, children }));
    }
    /**
     * Construct a new RecordBatch containing only columns at the specified indices.
     *
     * @param columnIndices Indices of columns to keep.
     * @returns A new RecordBatch of columns matching at the specified indices.
     */
    selectAt(columnIndices) {
        const schema = this.schema.selectAt(columnIndices);
        const children = columnIndices.map((i) => this.data.children[i]).filter(Boolean);
        const subset = (0, data_js_1.makeData)({ type: new type_js_1.Struct(schema.fields), length: this.numRows, children });
        return new RecordBatch(schema, subset);
    }
}
exports.RecordBatch = RecordBatch;
_a = Symbol.toStringTag;
// Initialize this static property via an IIFE so bundlers don't tree-shake
// out this logic, but also so we're still compliant with `"sideEffects": false`
RecordBatch[_a] = ((proto) => {
    proto._nullCount = -1;
    proto[Symbol.isConcatSpreadable] = true;
    return 'RecordBatch';
})(RecordBatch.prototype);
/** @ignore */
function ensureSameLengthData(schema, chunks, maxLength = chunks.reduce((max, col) => Math.max(max, col.length), 0)) {
    var _b;
    const fields = [...schema.fields];
    const children = [...chunks];
    const nullBitmapSize = ((maxLength + 63) & ~63) >> 3;
    for (const [idx, field] of schema.fields.entries()) {
        const chunk = chunks[idx];
        if (!chunk || chunk.length !== maxLength) {
            fields[idx] = field.clone({ nullable: true });
            children[idx] = (_b = chunk === null || chunk === void 0 ? void 0 : chunk._changeLengthAndBackfillNullBitmap(maxLength)) !== null && _b !== void 0 ? _b : (0, data_js_1.makeData)({
                type: field.type,
                length: maxLength,
                nullCount: maxLength,
                nullBitmap: new Uint8Array(nullBitmapSize)
            });
        }
    }
    return [
        schema.assign(fields),
        (0, data_js_1.makeData)({ type: new type_js_1.Struct(fields), length: maxLength, children })
    ];
}
/** @ignore */
function collectDictionaries(fields, children, dictionaries = new Map()) {
    var _b, _c;
    if (((_b = fields === null || fields === void 0 ? void 0 : fields.length) !== null && _b !== void 0 ? _b : 0) > 0 && ((fields === null || fields === void 0 ? void 0 : fields.length) === (children === null || children === void 0 ? void 0 : children.length))) {
        for (let i = -1, n = fields.length; ++i < n;) {
            const { type } = fields[i];
            const data = children[i];
            for (const next of [data, ...(((_c = data === null || data === void 0 ? void 0 : data.dictionary) === null || _c === void 0 ? void 0 : _c.data) || [])]) {
                collectDictionaries(type.children, next === null || next === void 0 ? void 0 : next.children, dictionaries);
            }
            if (type_js_1.DataType.isDictionary(type)) {
                const { id } = type;
                if (!dictionaries.has(id)) {
                    if (data === null || data === void 0 ? void 0 : data.dictionary) {
                        dictionaries.set(id, data.dictionary);
                    }
                }
                else if (dictionaries.get(id) !== data.dictionary) {
                    throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);
                }
            }
        }
    }
    return dictionaries;
}
/**
 * An internal class used by the `RecordBatchReader` and `RecordBatchWriter`
 * implementations to differentiate between a stream with valid zero-length
 * RecordBatches, and a stream with a Schema message, but no RecordBatches.
 * @see https://github.com/apache/arrow/pull/4373
 * @ignore
 * @private
 */
class _InternalEmptyPlaceholderRecordBatch extends RecordBatch {
    constructor(schema) {
        const children = schema.fields.map((f) => (0, data_js_1.makeData)({ type: f.type }));
        const data = (0, data_js_1.makeData)({ type: new type_js_1.Struct(schema.fields), nullCount: 0, children });
        super(schema, data);
    }
}
exports._InternalEmptyPlaceholderRecordBatch = _InternalEmptyPlaceholderRecordBatch;

//# sourceMappingURL=recordbatch.js.map


/***/ }),
/* 135 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.tableFromArrays = exports.makeTable = exports.Table = void 0;
const enum_js_1 = __webpack_require__(48);
const data_js_1 = __webpack_require__(117);
const factories_js_1 = __webpack_require__(136);
const vector_js_1 = __webpack_require__(47);
const schema_js_1 = __webpack_require__(128);
const type_js_1 = __webpack_require__(113);
const typecomparator_js_1 = __webpack_require__(159);
const recordbatch_js_1 = __webpack_require__(160);
const chunk_js_1 = __webpack_require__(119);
const get_js_1 = __webpack_require__(109);
const set_js_1 = __webpack_require__(115);
const indexof_js_1 = __webpack_require__(120);
const iterator_js_1 = __webpack_require__(121);
const vector_js_2 = __webpack_require__(106);
const recordbatch_js_2 = __webpack_require__(134);
/**
 * Tables are collections of {@link Vector}s and have a {@link Schema}. Use the convenience methods {@link makeTable}
 * or {@link tableFromArrays} to create a table in JavaScript. To create a table from the IPC format, use
 * {@link tableFromIPC}.
 */
class Table {
    constructor(...args) {
        var _b, _c;
        if (args.length === 0) {
            this.batches = [];
            this.schema = new schema_js_1.Schema([]);
            this._offsets = [0];
            return this;
        }
        let schema;
        let offsets;
        if (args[0] instanceof schema_js_1.Schema) {
            schema = args.shift();
        }
        if (args.at(-1) instanceof Uint32Array) {
            offsets = args.pop();
        }
        const unwrap = (x) => {
            if (x) {
                if (x instanceof recordbatch_js_2.RecordBatch) {
                    return [x];
                }
                else if (x instanceof Table) {
                    return x.batches;
                }
                else if (x instanceof data_js_1.Data) {
                    if (x.type instanceof type_js_1.Struct) {
                        return [new recordbatch_js_2.RecordBatch(new schema_js_1.Schema(x.type.children), x)];
                    }
                }
                else if (Array.isArray(x)) {
                    return x.flatMap(v => unwrap(v));
                }
                else if (typeof x[Symbol.iterator] === 'function') {
                    return [...x].flatMap(v => unwrap(v));
                }
                else if (typeof x === 'object') {
                    const keys = Object.keys(x);
                    const vecs = keys.map((k) => new vector_js_1.Vector([x[k]]));
                    const batchSchema = schema !== null && schema !== void 0 ? schema : new schema_js_1.Schema(keys.map((k, i) => new schema_js_1.Field(String(k), vecs[i].type, vecs[i].nullable)));
                    const [, batches] = (0, recordbatch_js_1.distributeVectorsIntoRecordBatches)(batchSchema, vecs);
                    return batches.length === 0 ? [new recordbatch_js_2.RecordBatch(x)] : batches;
                }
            }
            return [];
        };
        const batches = args.flatMap(v => unwrap(v));
        schema = (_c = schema !== null && schema !== void 0 ? schema : (_b = batches[0]) === null || _b === void 0 ? void 0 : _b.schema) !== null && _c !== void 0 ? _c : new schema_js_1.Schema([]);
        if (!(schema instanceof schema_js_1.Schema)) {
            throw new TypeError('Table constructor expects a [Schema, RecordBatch[]] pair.');
        }
        for (const batch of batches) {
            if (!(batch instanceof recordbatch_js_2.RecordBatch)) {
                throw new TypeError('Table constructor expects a [Schema, RecordBatch[]] pair.');
            }
            if (!(0, typecomparator_js_1.compareSchemas)(schema, batch.schema)) {
                throw new TypeError('Table and inner RecordBatch schemas must be equivalent.');
            }
        }
        this.schema = schema;
        this.batches = batches;
        this._offsets = offsets !== null && offsets !== void 0 ? offsets : (0, chunk_js_1.computeChunkOffsets)(this.data);
    }
    /**
     * The contiguous {@link RecordBatch `RecordBatch`} chunks of the Table rows.
     */
    get data() { return this.batches.map(({ data }) => data); }
    /**
     * The number of columns in this Table.
     */
    get numCols() { return this.schema.fields.length; }
    /**
     * The number of rows in this Table.
     */
    get numRows() {
        return this.data.reduce((numRows, data) => numRows + data.length, 0);
    }
    /**
     * The number of null rows in this Table.
     */
    get nullCount() {
        if (this._nullCount === -1) {
            this._nullCount = (0, chunk_js_1.computeChunkNullCounts)(this.data);
        }
        return this._nullCount;
    }
    /**
     * Check whether an element is null.
     *
     * @param index The index at which to read the validity bitmap.
     */
    // @ts-ignore
    isValid(index) { return false; }
    /**
     * Get an element value by position.
     *
     * @param index The index of the element to read.
     */
    // @ts-ignore
    get(index) { return null; }
    /**
      * Get an element value by position.
      * @param index The index of the element to read. A negative index will count back from the last element.
      */
    // @ts-ignore
    at(index) {
        return this.get((0, vector_js_2.wrapIndex)(index, this.numRows));
    }
    /**
     * Set an element value by position.
     *
     * @param index The index of the element to write.
     * @param value The value to set.
     */
    // @ts-ignore
    set(index, value) { return; }
    /**
     * Retrieve the index of the first occurrence of a value in an Vector.
     *
     * @param element The value to locate in the Vector.
     * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
     */
    // @ts-ignore
    indexOf(element, offset) { return -1; }
    /**
     * Iterator for rows in this Table.
     */
    [Symbol.iterator]() {
        if (this.batches.length > 0) {
            return iterator_js_1.instance.visit(new vector_js_1.Vector(this.data));
        }
        return (new Array(0))[Symbol.iterator]();
    }
    /**
     * Return a JavaScript Array of the Table rows.
     *
     * @returns An Array of Table rows.
     */
    toArray() {
        return [...this];
    }
    /**
     * Returns a string representation of the Table rows.
     *
     * @returns A string representation of the Table rows.
     */
    toString() {
        return `[\n  ${this.toArray().join(',\n  ')}\n]`;
    }
    /**
     * Combines two or more Tables of the same schema.
     *
     * @param others Additional Tables to add to the end of this Tables.
     */
    concat(...others) {
        const schema = this.schema;
        const data = this.data.concat(others.flatMap(({ data }) => data));
        return new Table(schema, data.map((data) => new recordbatch_js_2.RecordBatch(schema, data)));
    }
    /**
     * Return a zero-copy sub-section of this Table.
     *
     * @param begin The beginning of the specified portion of the Table.
     * @param end The end of the specified portion of the Table. This is exclusive of the element at the index 'end'.
     */
    slice(begin, end) {
        const schema = this.schema;
        [begin, end] = (0, vector_js_2.clampRange)({ length: this.numRows }, begin, end);
        const data = (0, chunk_js_1.sliceChunks)(this.data, this._offsets, begin, end);
        return new Table(schema, data.map((chunk) => new recordbatch_js_2.RecordBatch(schema, chunk)));
    }
    /**
     * Returns a child Vector by name, or null if this Vector has no child with the given name.
     *
     * @param name The name of the child to retrieve.
     */
    getChild(name) {
        return this.getChildAt(this.schema.fields.findIndex((f) => f.name === name));
    }
    /**
     * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
     *
     * @param index The index of the child to retrieve.
     */
    getChildAt(index) {
        if (index > -1 && index < this.schema.fields.length) {
            const data = this.data.map((data) => data.children[index]);
            if (data.length === 0) {
                const { type } = this.schema.fields[index];
                const empty = (0, data_js_1.makeData)({ type, length: 0, nullCount: 0 });
                data.push(empty._changeLengthAndBackfillNullBitmap(this.numRows));
            }
            return new vector_js_1.Vector(data);
        }
        return null;
    }
    /**
     * Sets a child Vector by name.
     *
     * @param name The name of the child to overwrite.
     * @returns A new Table with the supplied child for the specified name.
     */
    setChild(name, child) {
        var _b;
        return this.setChildAt((_b = this.schema.fields) === null || _b === void 0 ? void 0 : _b.findIndex((f) => f.name === name), child);
    }
    setChildAt(index, child) {
        let schema = this.schema;
        let batches = [...this.batches];
        if (index > -1 && index < this.numCols) {
            if (!child) {
                child = new vector_js_1.Vector([(0, data_js_1.makeData)({ type: new type_js_1.Null, length: this.numRows })]);
            }
            const fields = schema.fields.slice();
            const field = fields[index].clone({ type: child.type });
            const children = this.schema.fields.map((_, i) => this.getChildAt(i));
            [fields[index], children[index]] = [field, child];
            [schema, batches] = (0, recordbatch_js_1.distributeVectorsIntoRecordBatches)(schema, children);
        }
        return new Table(schema, batches);
    }
    /**
     * Construct a new Table containing only specified columns.
     *
     * @param columnNames Names of columns to keep.
     * @returns A new Table of columns matching the specified names.
     */
    select(columnNames) {
        const nameToIndex = this.schema.fields.reduce((m, f, i) => m.set(f.name, i), new Map());
        return this.selectAt(columnNames.map((columnName) => nameToIndex.get(columnName)).filter((x) => x > -1));
    }
    /**
     * Construct a new Table containing only columns at the specified indices.
     *
     * @param columnIndices Indices of columns to keep.
     * @returns A new Table of columns at the specified indices.
     */
    selectAt(columnIndices) {
        const schema = this.schema.selectAt(columnIndices);
        const data = this.batches.map((batch) => batch.selectAt(columnIndices));
        return new Table(schema, data);
    }
    assign(other) {
        const fields = this.schema.fields;
        const [indices, oldToNew] = other.schema.fields.reduce((memo, f2, newIdx) => {
            const [indices, oldToNew] = memo;
            const i = fields.findIndex((f) => f.name === f2.name);
            ~i ? (oldToNew[i] = newIdx) : indices.push(newIdx);
            return memo;
        }, [[], []]);
        const schema = this.schema.assign(other.schema);
        const columns = [
            ...fields.map((_, i) => [i, oldToNew[i]]).map(([i, j]) => (j === undefined ? this.getChildAt(i) : other.getChildAt(j))),
            ...indices.map((i) => other.getChildAt(i))
        ].filter(Boolean);
        return new Table(...(0, recordbatch_js_1.distributeVectorsIntoRecordBatches)(schema, columns));
    }
}
exports.Table = Table;
_a = Symbol.toStringTag;
// Initialize this static property via an IIFE so bundlers don't tree-shake
// out this logic, but also so we're still compliant with `"sideEffects": false`
Table[_a] = ((proto) => {
    proto.schema = null;
    proto.batches = [];
    proto._offsets = new Uint32Array([0]);
    proto._nullCount = -1;
    proto[Symbol.isConcatSpreadable] = true;
    proto['isValid'] = (0, chunk_js_1.wrapChunkedCall1)(chunk_js_1.isChunkedValid);
    proto['get'] = (0, chunk_js_1.wrapChunkedCall1)(get_js_1.instance.getVisitFn(enum_js_1.Type.Struct));
    proto['set'] = (0, chunk_js_1.wrapChunkedCall2)(set_js_1.instance.getVisitFn(enum_js_1.Type.Struct));
    proto['indexOf'] = (0, chunk_js_1.wrapChunkedIndexOf)(indexof_js_1.instance.getVisitFn(enum_js_1.Type.Struct));
    return 'Table';
})(Table.prototype);
/**
 * Creates a new Table from an object of typed arrays.
 *
*  @example
 * ```ts
 * const table = makeTable({
 *   a: new Int8Array([1, 2, 3]),
 * })
 * ```
 *
 * @param input Input an object of typed arrays.
 * @returns A new Table.
 */
function makeTable(input) {
    const vecs = {};
    const inputs = Object.entries(input);
    for (const [key, col] of inputs) {
        vecs[key] = (0, vector_js_1.makeVector)(col);
    }
    return new Table(vecs);
}
exports.makeTable = makeTable;
/**
 * Creates a new Table from an object of typed arrays or JavaScript arrays.
 *
 *  @example
 * ```ts
 * const table = tableFromArrays({
 *   a: [1, 2, 3],
 *   b: new Int8Array([1, 2, 3]),
 * })
 * ```
 *
 * @param input Input an object of typed arrays or JavaScript arrays.
 * @returns A new Table.
 */
function tableFromArrays(input) {
    const vecs = {};
    const inputs = Object.entries(input);
    for (const [key, col] of inputs) {
        vecs[key] = (0, factories_js_1.vectorFromArray)(col);
    }
    return new Table(vecs);
}
exports.tableFromArrays = tableFromArrays;

//# sourceMappingURL=table.js.map


/***/ }),
/* 136 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.builderThroughAsyncIterable = exports.builderThroughIterable = exports.tableFromJSON = exports.vectorFromArray = exports.makeBuilder = void 0;
const tslib_1 = __webpack_require__(41);
const schema_js_1 = __webpack_require__(128);
const dtypes = __webpack_require__(113);
const data_js_1 = __webpack_require__(117);
const vector_js_1 = __webpack_require__(47);
const builderctor_js_1 = __webpack_require__(137);
const table_js_1 = __webpack_require__(135);
const recordbatch_js_1 = __webpack_require__(134);
const typecomparator_js_1 = __webpack_require__(159);
function makeBuilder(options) {
    const type = options.type;
    const builder = new (builderctor_js_1.instance.getVisitFn(type)())(options);
    if (type.children && type.children.length > 0) {
        const children = options['children'] || [];
        const defaultOptions = { 'nullValues': options['nullValues'] };
        const getChildOptions = Array.isArray(children)
            ? ((_, i) => children[i] || defaultOptions)
            : (({ name }) => children[name] || defaultOptions);
        for (const [index, field] of type.children.entries()) {
            const { type } = field;
            const opts = getChildOptions(field, index);
            builder.children.push(makeBuilder(Object.assign(Object.assign({}, opts), { type })));
        }
    }
    return builder;
}
exports.makeBuilder = makeBuilder;
function vectorFromArray(init, type) {
    if (init instanceof data_js_1.Data || init instanceof vector_js_1.Vector || init.type instanceof dtypes.DataType || ArrayBuffer.isView(init)) {
        return (0, vector_js_1.makeVector)(init);
    }
    const options = { type: type !== null && type !== void 0 ? type : inferType(init), nullValues: [null] };
    const chunks = [...builderThroughIterable(options)(init)];
    const vector = chunks.length === 1 ? chunks[0] : chunks.reduce((a, b) => a.concat(b));
    if (dtypes.DataType.isDictionary(vector.type)) {
        return vector.memoize();
    }
    return vector;
}
exports.vectorFromArray = vectorFromArray;
/**
 * Creates a {@link Table} from an array of objects.
 *
 * @param array A table of objects.
 */
function tableFromJSON(array) {
    const vector = vectorFromArray(array);
    const batch = new recordbatch_js_1.RecordBatch(new schema_js_1.Schema(vector.type.children), vector.data[0]);
    return new table_js_1.Table(batch);
}
exports.tableFromJSON = tableFromJSON;
function inferType(value) {
    if (value.length === 0) {
        return new dtypes.Null;
    }
    let nullsCount = 0;
    let arraysCount = 0;
    let objectsCount = 0;
    let numbersCount = 0;
    let stringsCount = 0;
    let bigintsCount = 0;
    let booleansCount = 0;
    let datesCount = 0;
    for (const val of value) {
        if (val == null) {
            ++nullsCount;
            continue;
        }
        switch (typeof val) {
            case 'bigint':
                ++bigintsCount;
                continue;
            case 'boolean':
                ++booleansCount;
                continue;
            case 'number':
                ++numbersCount;
                continue;
            case 'string':
                ++stringsCount;
                continue;
            case 'object':
                if (Array.isArray(val)) {
                    ++arraysCount;
                }
                else if (Object.prototype.toString.call(val) === '[object Date]') {
                    ++datesCount;
                }
                else {
                    ++objectsCount;
                }
                continue;
        }
        throw new TypeError('Unable to infer Vector type from input values, explicit type declaration expected.');
    }
    if (numbersCount + nullsCount === value.length) {
        return new dtypes.Float64;
    }
    else if (stringsCount + nullsCount === value.length) {
        return new dtypes.Dictionary(new dtypes.Utf8, new dtypes.Int32);
    }
    else if (bigintsCount + nullsCount === value.length) {
        return new dtypes.Int64;
    }
    else if (booleansCount + nullsCount === value.length) {
        return new dtypes.Bool;
    }
    else if (datesCount + nullsCount === value.length) {
        return new dtypes.TimestampMillisecond;
    }
    else if (arraysCount + nullsCount === value.length) {
        const array = value;
        const childType = inferType(array[array.findIndex((ary) => ary != null)]);
        if (array.every((ary) => ary == null || (0, typecomparator_js_1.compareTypes)(childType, inferType(ary)))) {
            return new dtypes.List(new schema_js_1.Field('', childType, true));
        }
    }
    else if (objectsCount + nullsCount === value.length) {
        const fields = new Map();
        for (const row of value) {
            for (const key of Object.keys(row)) {
                if (!fields.has(key) && row[key] != null) {
                    // use the type inferred for the first instance of a found key
                    fields.set(key, new schema_js_1.Field(key, inferType([row[key]]), true));
                }
            }
        }
        return new dtypes.Struct([...fields.values()]);
    }
    throw new TypeError('Unable to infer Vector type from input values, explicit type declaration expected.');
}
/**
 * Transform a synchronous `Iterable` of arbitrary JavaScript values into a
 * sequence of Arrow Vector<T> following the chunking semantics defined in
 * the supplied `options` argument.
 *
 * This function returns a function that accepts an `Iterable` of values to
 * transform. When called, this function returns an Iterator of `Vector<T>`.
 *
 * The resulting `Iterator<Vector<T>>` yields Vectors based on the
 * `queueingStrategy` and `highWaterMark` specified in the `options` argument.
 *
 * * If `queueingStrategy` is `"count"` (or omitted), The `Iterator<Vector<T>>`
 *   will flush the underlying `Builder` (and yield a new `Vector<T>`) once the
 *   Builder's `length` reaches or exceeds the supplied `highWaterMark`.
 * * If `queueingStrategy` is `"bytes"`, the `Iterator<Vector<T>>` will flush
 *   the underlying `Builder` (and yield a new `Vector<T>`) once its `byteLength`
 *   reaches or exceeds the supplied `highWaterMark`.
 *
 * @param {IterableBuilderOptions<T, TNull>} options An object of properties which determine the `Builder` to create and the chunking semantics to use.
 * @returns A function which accepts a JavaScript `Iterable` of values to
 *          write, and returns an `Iterator` that yields Vectors according
 *          to the chunking semantics defined in the `options` argument.
 * @nocollapse
 */
function builderThroughIterable(options) {
    const { ['queueingStrategy']: queueingStrategy = 'count' } = options;
    const { ['highWaterMark']: highWaterMark = queueingStrategy !== 'bytes' ? Number.POSITIVE_INFINITY : Math.pow(2, 14) } = options;
    const sizeProperty = queueingStrategy !== 'bytes' ? 'length' : 'byteLength';
    return function* (source) {
        let numChunks = 0;
        const builder = makeBuilder(options);
        for (const value of source) {
            if (builder.append(value)[sizeProperty] >= highWaterMark) {
                ++numChunks && (yield builder.toVector());
            }
        }
        if (builder.finish().length > 0 || numChunks === 0) {
            yield builder.toVector();
        }
    };
}
exports.builderThroughIterable = builderThroughIterable;
/**
 * Transform an `AsyncIterable` of arbitrary JavaScript values into a
 * sequence of Arrow Vector<T> following the chunking semantics defined in
 * the supplied `options` argument.
 *
 * This function returns a function that accepts an `AsyncIterable` of values to
 * transform. When called, this function returns an AsyncIterator of `Vector<T>`.
 *
 * The resulting `AsyncIterator<Vector<T>>` yields Vectors based on the
 * `queueingStrategy` and `highWaterMark` specified in the `options` argument.
 *
 * * If `queueingStrategy` is `"count"` (or omitted), The `AsyncIterator<Vector<T>>`
 *   will flush the underlying `Builder` (and yield a new `Vector<T>`) once the
 *   Builder's `length` reaches or exceeds the supplied `highWaterMark`.
 * * If `queueingStrategy` is `"bytes"`, the `AsyncIterator<Vector<T>>` will flush
 *   the underlying `Builder` (and yield a new `Vector<T>`) once its `byteLength`
 *   reaches or exceeds the supplied `highWaterMark`.
 *
 * @param {IterableBuilderOptions<T, TNull>} options An object of properties which determine the `Builder` to create and the chunking semantics to use.
 * @returns A function which accepts a JavaScript `AsyncIterable` of values
 *          to write, and returns an `AsyncIterator` that yields Vectors
 *          according to the chunking semantics defined in the `options`
 *          argument.
 * @nocollapse
 */
function builderThroughAsyncIterable(options) {
    const { ['queueingStrategy']: queueingStrategy = 'count' } = options;
    const { ['highWaterMark']: highWaterMark = queueingStrategy !== 'bytes' ? Number.POSITIVE_INFINITY : Math.pow(2, 14) } = options;
    const sizeProperty = queueingStrategy !== 'bytes' ? 'length' : 'byteLength';
    return function (source) {
        return tslib_1.__asyncGenerator(this, arguments, function* () {
            var _a, e_1, _b, _c;
            let numChunks = 0;
            const builder = makeBuilder(options);
            try {
                for (var _d = true, source_1 = tslib_1.__asyncValues(source), source_1_1; source_1_1 = yield tslib_1.__await(source_1.next()), _a = source_1_1.done, !_a; _d = true) {
                    _c = source_1_1.value;
                    _d = false;
                    const value = _c;
                    if (builder.append(value)[sizeProperty] >= highWaterMark) {
                        ++numChunks && (yield yield tslib_1.__await(builder.toVector()));
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = source_1.return)) yield tslib_1.__await(_b.call(source_1));
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (builder.finish().length > 0 || numChunks === 0) {
                yield yield tslib_1.__await(builder.toVector());
            }
        });
    };
}
exports.builderThroughAsyncIterable = builderThroughAsyncIterable;

//# sourceMappingURL=factories.js.map


/***/ }),
/* 137 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.instance = exports.GetBuilderCtor = void 0;
const visitor_js_1 = __webpack_require__(112);
const binary_js_1 = __webpack_require__(138);
const largebinary_js_1 = __webpack_require__(139);
const bool_js_1 = __webpack_require__(140);
const date_js_1 = __webpack_require__(141);
const decimal_js_1 = __webpack_require__(142);
const dictionary_js_1 = __webpack_require__(143);
const fixedsizebinary_js_1 = __webpack_require__(144);
const fixedsizelist_js_1 = __webpack_require__(145);
const float_js_1 = __webpack_require__(146);
const interval_js_1 = __webpack_require__(147);
const duration_js_1 = __webpack_require__(148);
const int_js_1 = __webpack_require__(149);
const list_js_1 = __webpack_require__(150);
const map_js_1 = __webpack_require__(151);
const null_js_1 = __webpack_require__(152);
const struct_js_1 = __webpack_require__(153);
const timestamp_js_1 = __webpack_require__(154);
const time_js_1 = __webpack_require__(155);
const union_js_1 = __webpack_require__(156);
const utf8_js_1 = __webpack_require__(157);
const largeutf8_js_1 = __webpack_require__(158);
/** @ignore */
class GetBuilderCtor extends visitor_js_1.Visitor {
    visitNull() { return null_js_1.NullBuilder; }
    visitBool() { return bool_js_1.BoolBuilder; }
    visitInt() { return int_js_1.IntBuilder; }
    visitInt8() { return int_js_1.Int8Builder; }
    visitInt16() { return int_js_1.Int16Builder; }
    visitInt32() { return int_js_1.Int32Builder; }
    visitInt64() { return int_js_1.Int64Builder; }
    visitUint8() { return int_js_1.Uint8Builder; }
    visitUint16() { return int_js_1.Uint16Builder; }
    visitUint32() { return int_js_1.Uint32Builder; }
    visitUint64() { return int_js_1.Uint64Builder; }
    visitFloat() { return float_js_1.FloatBuilder; }
    visitFloat16() { return float_js_1.Float16Builder; }
    visitFloat32() { return float_js_1.Float32Builder; }
    visitFloat64() { return float_js_1.Float64Builder; }
    visitUtf8() { return utf8_js_1.Utf8Builder; }
    visitLargeUtf8() { return largeutf8_js_1.LargeUtf8Builder; }
    visitBinary() { return binary_js_1.BinaryBuilder; }
    visitLargeBinary() { return largebinary_js_1.LargeBinaryBuilder; }
    visitFixedSizeBinary() { return fixedsizebinary_js_1.FixedSizeBinaryBuilder; }
    visitDate() { return date_js_1.DateBuilder; }
    visitDateDay() { return date_js_1.DateDayBuilder; }
    visitDateMillisecond() { return date_js_1.DateMillisecondBuilder; }
    visitTimestamp() { return timestamp_js_1.TimestampBuilder; }
    visitTimestampSecond() { return timestamp_js_1.TimestampSecondBuilder; }
    visitTimestampMillisecond() { return timestamp_js_1.TimestampMillisecondBuilder; }
    visitTimestampMicrosecond() { return timestamp_js_1.TimestampMicrosecondBuilder; }
    visitTimestampNanosecond() { return timestamp_js_1.TimestampNanosecondBuilder; }
    visitTime() { return time_js_1.TimeBuilder; }
    visitTimeSecond() { return time_js_1.TimeSecondBuilder; }
    visitTimeMillisecond() { return time_js_1.TimeMillisecondBuilder; }
    visitTimeMicrosecond() { return time_js_1.TimeMicrosecondBuilder; }
    visitTimeNanosecond() { return time_js_1.TimeNanosecondBuilder; }
    visitDecimal() { return decimal_js_1.DecimalBuilder; }
    visitList() { return list_js_1.ListBuilder; }
    visitStruct() { return struct_js_1.StructBuilder; }
    visitUnion() { return union_js_1.UnionBuilder; }
    visitDenseUnion() { return union_js_1.DenseUnionBuilder; }
    visitSparseUnion() { return union_js_1.SparseUnionBuilder; }
    visitDictionary() { return dictionary_js_1.DictionaryBuilder; }
    visitInterval() { return interval_js_1.IntervalBuilder; }
    visitIntervalDayTime() { return interval_js_1.IntervalDayTimeBuilder; }
    visitIntervalYearMonth() { return interval_js_1.IntervalYearMonthBuilder; }
    visitDuration() { return duration_js_1.DurationBuilder; }
    visitDurationSecond() { return duration_js_1.DurationSecondBuilder; }
    visitDurationMillisecond() { return duration_js_1.DurationMillisecondBuilder; }
    visitDurationMicrosecond() { return duration_js_1.DurationMicrosecondBuilder; }
    visitDurationNanosecond() { return duration_js_1.DurationNanosecondBuilder; }
    visitFixedSizeList() { return fixedsizelist_js_1.FixedSizeListBuilder; }
    visitMap() { return map_js_1.MapBuilder; }
}
exports.GetBuilderCtor = GetBuilderCtor;
/** @ignore */
exports.instance = new GetBuilderCtor();

//# sourceMappingURL=builderctor.js.map


/***/ }),
/* 138 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BinaryBuilder = void 0;
const buffer_js_1 = __webpack_require__(123);
const builder_js_1 = __webpack_require__(46);
const buffer_js_2 = __webpack_require__(43);
/** @ignore */
class BinaryBuilder extends builder_js_1.VariableWidthBuilder {
    constructor(opts) {
        super(opts);
        this._values = new buffer_js_1.BufferBuilder(Uint8Array);
    }
    get byteLength() {
        let size = this._pendingLength + (this.length * 4);
        this._offsets && (size += this._offsets.byteLength);
        this._values && (size += this._values.byteLength);
        this._nulls && (size += this._nulls.byteLength);
        return size;
    }
    setValue(index, value) {
        return super.setValue(index, (0, buffer_js_2.toUint8Array)(value));
    }
    _flushPending(pending, pendingLength) {
        const offsets = this._offsets;
        const data = this._values.reserve(pendingLength).buffer;
        let offset = 0;
        for (const [index, value] of pending) {
            if (value === undefined) {
                offsets.set(index, 0);
            }
            else {
                const length = value.length;
                data.set(value, offset);
                offsets.set(index, length);
                offset += length;
            }
        }
    }
}
exports.BinaryBuilder = BinaryBuilder;

//# sourceMappingURL=binary.js.map


/***/ }),
/* 139 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LargeBinaryBuilder = void 0;
const buffer_js_1 = __webpack_require__(43);
const buffer_js_2 = __webpack_require__(123);
const builder_js_1 = __webpack_require__(46);
/** @ignore */
class LargeBinaryBuilder extends builder_js_1.VariableWidthBuilder {
    constructor(opts) {
        super(opts);
        this._values = new buffer_js_2.BufferBuilder(Uint8Array);
    }
    get byteLength() {
        let size = this._pendingLength + (this.length * 4);
        this._offsets && (size += this._offsets.byteLength);
        this._values && (size += this._values.byteLength);
        this._nulls && (size += this._nulls.byteLength);
        return size;
    }
    setValue(index, value) {
        return super.setValue(index, (0, buffer_js_1.toUint8Array)(value));
    }
    _flushPending(pending, pendingLength) {
        const offsets = this._offsets;
        const data = this._values.reserve(pendingLength).buffer;
        let offset = 0;
        for (const [index, value] of pending) {
            if (value === undefined) {
                offsets.set(index, BigInt(0));
            }
            else {
                const length = value.length;
                data.set(value, offset);
                offsets.set(index, BigInt(length));
                offset += length;
            }
        }
    }
}
exports.LargeBinaryBuilder = LargeBinaryBuilder;

//# sourceMappingURL=largebinary.js.map


/***/ }),
/* 140 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BoolBuilder = void 0;
const buffer_js_1 = __webpack_require__(123);
const builder_js_1 = __webpack_require__(46);
/** @ignore */
class BoolBuilder extends builder_js_1.Builder {
    constructor(options) {
        super(options);
        this._values = new buffer_js_1.BitmapBufferBuilder();
    }
    setValue(index, value) {
        this._values.set(index, +value);
    }
}
exports.BoolBuilder = BoolBuilder;

//# sourceMappingURL=bool.js.map


/***/ }),
/* 141 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DateMillisecondBuilder = exports.DateDayBuilder = exports.DateBuilder = void 0;
const builder_js_1 = __webpack_require__(46);
const set_js_1 = __webpack_require__(115);
/** @ignore */
class DateBuilder extends builder_js_1.FixedWidthBuilder {
}
exports.DateBuilder = DateBuilder;
DateBuilder.prototype._setValue = set_js_1.setDate;
/** @ignore */
class DateDayBuilder extends DateBuilder {
}
exports.DateDayBuilder = DateDayBuilder;
DateDayBuilder.prototype._setValue = set_js_1.setDateDay;
/** @ignore */
class DateMillisecondBuilder extends DateBuilder {
}
exports.DateMillisecondBuilder = DateMillisecondBuilder;
DateMillisecondBuilder.prototype._setValue = set_js_1.setDateMillisecond;

//# sourceMappingURL=date.js.map


/***/ }),
/* 142 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DecimalBuilder = void 0;
const builder_js_1 = __webpack_require__(46);
const set_js_1 = __webpack_require__(115);
/** @ignore */
class DecimalBuilder extends builder_js_1.FixedWidthBuilder {
}
exports.DecimalBuilder = DecimalBuilder;
DecimalBuilder.prototype._setValue = set_js_1.setDecimal;

//# sourceMappingURL=decimal.js.map


/***/ }),
/* 143 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DictionaryBuilder = void 0;
const type_js_1 = __webpack_require__(113);
const builder_js_1 = __webpack_require__(46);
const factories_js_1 = __webpack_require__(136);
/** @ignore */
class DictionaryBuilder extends builder_js_1.Builder {
    constructor({ 'type': type, 'nullValues': nulls, 'dictionaryHashFunction': hashFn }) {
        super({ type: new type_js_1.Dictionary(type.dictionary, type.indices, type.id, type.isOrdered) });
        this._nulls = null;
        this._dictionaryOffset = 0;
        this._keysToIndices = Object.create(null);
        this.indices = (0, factories_js_1.makeBuilder)({ 'type': this.type.indices, 'nullValues': nulls });
        this.dictionary = (0, factories_js_1.makeBuilder)({ 'type': this.type.dictionary, 'nullValues': null });
        if (typeof hashFn === 'function') {
            this.valueToKey = hashFn;
        }
    }
    get values() { return this.indices.values; }
    get nullCount() { return this.indices.nullCount; }
    get nullBitmap() { return this.indices.nullBitmap; }
    get byteLength() { return this.indices.byteLength + this.dictionary.byteLength; }
    get reservedLength() { return this.indices.reservedLength + this.dictionary.reservedLength; }
    get reservedByteLength() { return this.indices.reservedByteLength + this.dictionary.reservedByteLength; }
    isValid(value) { return this.indices.isValid(value); }
    setValid(index, valid) {
        const indices = this.indices;
        valid = indices.setValid(index, valid);
        this.length = indices.length;
        return valid;
    }
    setValue(index, value) {
        const keysToIndices = this._keysToIndices;
        const key = this.valueToKey(value);
        let idx = keysToIndices[key];
        if (idx === undefined) {
            keysToIndices[key] = idx = this._dictionaryOffset + this.dictionary.append(value).length - 1;
        }
        return this.indices.setValue(index, idx);
    }
    flush() {
        const type = this.type;
        const prev = this._dictionary;
        const curr = this.dictionary.toVector();
        const data = this.indices.flush().clone(type);
        data.dictionary = prev ? prev.concat(curr) : curr;
        this.finished || (this._dictionaryOffset += curr.length);
        this._dictionary = data.dictionary;
        this.clear();
        return data;
    }
    finish() {
        this.indices.finish();
        this.dictionary.finish();
        this._dictionaryOffset = 0;
        this._keysToIndices = Object.create(null);
        return super.finish();
    }
    clear() {
        this.indices.clear();
        this.dictionary.clear();
        return super.clear();
    }
    valueToKey(val) {
        return typeof val === 'string' ? val : `${val}`;
    }
}
exports.DictionaryBuilder = DictionaryBuilder;

//# sourceMappingURL=dictionary.js.map


/***/ }),
/* 144 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FixedSizeBinaryBuilder = void 0;
const builder_js_1 = __webpack_require__(46);
const set_js_1 = __webpack_require__(115);
/** @ignore */
class FixedSizeBinaryBuilder extends builder_js_1.FixedWidthBuilder {
}
exports.FixedSizeBinaryBuilder = FixedSizeBinaryBuilder;
FixedSizeBinaryBuilder.prototype._setValue = set_js_1.setFixedSizeBinary;

//# sourceMappingURL=fixedsizebinary.js.map


/***/ }),
/* 145 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FixedSizeListBuilder = void 0;
const schema_js_1 = __webpack_require__(128);
const builder_js_1 = __webpack_require__(46);
const type_js_1 = __webpack_require__(113);
/** @ignore */
class FixedSizeListBuilder extends builder_js_1.Builder {
    setValue(index, value) {
        const [child] = this.children;
        const start = index * this.stride;
        for (let i = -1, n = value.length; ++i < n;) {
            child.set(start + i, value[i]);
        }
    }
    addChild(child, name = '0') {
        if (this.numChildren > 0) {
            throw new Error('FixedSizeListBuilder can only have one child.');
        }
        const childIndex = this.children.push(child);
        this.type = new type_js_1.FixedSizeList(this.type.listSize, new schema_js_1.Field(name, child.type, true));
        return childIndex;
    }
}
exports.FixedSizeListBuilder = FixedSizeListBuilder;

//# sourceMappingURL=fixedsizelist.js.map


/***/ }),
/* 146 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Float64Builder = exports.Float32Builder = exports.Float16Builder = exports.FloatBuilder = void 0;
const math_js_1 = __webpack_require__(116);
const builder_js_1 = __webpack_require__(46);
/** @ignore */
class FloatBuilder extends builder_js_1.FixedWidthBuilder {
    setValue(index, value) {
        this._values.set(index, value);
    }
}
exports.FloatBuilder = FloatBuilder;
/** @ignore */
class Float16Builder extends FloatBuilder {
    setValue(index, value) {
        // convert JS float64 to a uint16
        super.setValue(index, (0, math_js_1.float64ToUint16)(value));
    }
}
exports.Float16Builder = Float16Builder;
/** @ignore */
class Float32Builder extends FloatBuilder {
}
exports.Float32Builder = Float32Builder;
/** @ignore */
class Float64Builder extends FloatBuilder {
}
exports.Float64Builder = Float64Builder;

//# sourceMappingURL=float.js.map


/***/ }),
/* 147 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IntervalYearMonthBuilder = exports.IntervalDayTimeBuilder = exports.IntervalBuilder = void 0;
const builder_js_1 = __webpack_require__(46);
const set_js_1 = __webpack_require__(115);
/** @ignore */
class IntervalBuilder extends builder_js_1.FixedWidthBuilder {
}
exports.IntervalBuilder = IntervalBuilder;
IntervalBuilder.prototype._setValue = set_js_1.setIntervalValue;
/** @ignore */
class IntervalDayTimeBuilder extends IntervalBuilder {
}
exports.IntervalDayTimeBuilder = IntervalDayTimeBuilder;
IntervalDayTimeBuilder.prototype._setValue = set_js_1.setIntervalDayTime;
/** @ignore */
class IntervalYearMonthBuilder extends IntervalBuilder {
}
exports.IntervalYearMonthBuilder = IntervalYearMonthBuilder;
IntervalYearMonthBuilder.prototype._setValue = set_js_1.setIntervalYearMonth;

//# sourceMappingURL=interval.js.map


/***/ }),
/* 148 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DurationNanosecondBuilder = exports.DurationMicrosecondBuilder = exports.DurationMillisecondBuilder = exports.DurationSecondBuilder = exports.DurationBuilder = void 0;
const builder_js_1 = __webpack_require__(46);
const set_js_1 = __webpack_require__(115);
/** @ignore */
class DurationBuilder extends builder_js_1.FixedWidthBuilder {
}
exports.DurationBuilder = DurationBuilder;
DurationBuilder.prototype._setValue = set_js_1.setDuration;
/** @ignore */
class DurationSecondBuilder extends DurationBuilder {
}
exports.DurationSecondBuilder = DurationSecondBuilder;
DurationSecondBuilder.prototype._setValue = set_js_1.setDurationSecond;
/** @ignore */
class DurationMillisecondBuilder extends DurationBuilder {
}
exports.DurationMillisecondBuilder = DurationMillisecondBuilder;
DurationMillisecondBuilder.prototype._setValue = set_js_1.setDurationMillisecond;
/** @ignore */
class DurationMicrosecondBuilder extends DurationBuilder {
}
exports.DurationMicrosecondBuilder = DurationMicrosecondBuilder;
DurationMicrosecondBuilder.prototype._setValue = set_js_1.setDurationMicrosecond;
/** @ignore */
class DurationNanosecondBuilder extends DurationBuilder {
}
exports.DurationNanosecondBuilder = DurationNanosecondBuilder;
DurationNanosecondBuilder.prototype._setValue = set_js_1.setDurationNanosecond;

//# sourceMappingURL=duration.js.map


/***/ }),
/* 149 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Uint64Builder = exports.Uint32Builder = exports.Uint16Builder = exports.Uint8Builder = exports.Int64Builder = exports.Int32Builder = exports.Int16Builder = exports.Int8Builder = exports.IntBuilder = void 0;
const builder_js_1 = __webpack_require__(46);
/** @ignore */
class IntBuilder extends builder_js_1.FixedWidthBuilder {
    setValue(index, value) {
        this._values.set(index, value);
    }
}
exports.IntBuilder = IntBuilder;
/** @ignore */
class Int8Builder extends IntBuilder {
}
exports.Int8Builder = Int8Builder;
/** @ignore */
class Int16Builder extends IntBuilder {
}
exports.Int16Builder = Int16Builder;
/** @ignore */
class Int32Builder extends IntBuilder {
}
exports.Int32Builder = Int32Builder;
/** @ignore */
class Int64Builder extends IntBuilder {
}
exports.Int64Builder = Int64Builder;
/** @ignore */
class Uint8Builder extends IntBuilder {
}
exports.Uint8Builder = Uint8Builder;
/** @ignore */
class Uint16Builder extends IntBuilder {
}
exports.Uint16Builder = Uint16Builder;
/** @ignore */
class Uint32Builder extends IntBuilder {
}
exports.Uint32Builder = Uint32Builder;
/** @ignore */
class Uint64Builder extends IntBuilder {
}
exports.Uint64Builder = Uint64Builder;

//# sourceMappingURL=int.js.map


/***/ }),
/* 150 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ListBuilder = void 0;
const schema_js_1 = __webpack_require__(128);
const type_js_1 = __webpack_require__(113);
const buffer_js_1 = __webpack_require__(123);
const builder_js_1 = __webpack_require__(46);
/** @ignore */
class ListBuilder extends builder_js_1.VariableWidthBuilder {
    constructor(opts) {
        super(opts);
        this._offsets = new buffer_js_1.OffsetsBufferBuilder(opts.type);
    }
    addChild(child, name = '0') {
        if (this.numChildren > 0) {
            throw new Error('ListBuilder can only have one child.');
        }
        this.children[this.numChildren] = child;
        this.type = new type_js_1.List(new schema_js_1.Field(name, child.type, true));
        return this.numChildren - 1;
    }
    _flushPending(pending) {
        const offsets = this._offsets;
        const [child] = this.children;
        for (const [index, value] of pending) {
            if (typeof value === 'undefined') {
                offsets.set(index, 0);
            }
            else {
                const v = value;
                const n = v.length;
                const start = offsets.set(index, n).buffer[index];
                for (let i = -1; ++i < n;) {
                    child.set(start + i, v[i]);
                }
            }
        }
    }
}
exports.ListBuilder = ListBuilder;

//# sourceMappingURL=list.js.map


/***/ }),
/* 151 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MapBuilder = void 0;
const schema_js_1 = __webpack_require__(128);
const type_js_1 = __webpack_require__(113);
const builder_js_1 = __webpack_require__(46);
/** @ignore */
class MapBuilder extends builder_js_1.VariableWidthBuilder {
    set(index, value) {
        return super.set(index, value);
    }
    setValue(index, value) {
        const row = (value instanceof Map ? value : new Map(Object.entries(value)));
        const pending = this._pending || (this._pending = new Map());
        const current = pending.get(index);
        current && (this._pendingLength -= current.size);
        this._pendingLength += row.size;
        pending.set(index, row);
    }
    addChild(child, name = `${this.numChildren}`) {
        if (this.numChildren > 0) {
            throw new Error('ListBuilder can only have one child.');
        }
        this.children[this.numChildren] = child;
        this.type = new type_js_1.Map_(new schema_js_1.Field(name, child.type, true), this.type.keysSorted);
        return this.numChildren - 1;
    }
    _flushPending(pending) {
        const offsets = this._offsets;
        const [child] = this.children;
        for (const [index, value] of pending) {
            if (value === undefined) {
                offsets.set(index, 0);
            }
            else {
                let { [index]: idx, [index + 1]: end } = offsets.set(index, value.size).buffer;
                for (const val of value.entries()) {
                    child.set(idx, val);
                    if (++idx >= end)
                        break;
                }
            }
        }
    }
}
exports.MapBuilder = MapBuilder;

//# sourceMappingURL=map.js.map


/***/ }),
/* 152 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NullBuilder = void 0;
const builder_js_1 = __webpack_require__(46);
/** @ignore */
class NullBuilder extends builder_js_1.Builder {
    // @ts-ignore
    setValue(index, value) { }
    setValid(index, valid) {
        this.length = Math.max(index + 1, this.length);
        return valid;
    }
}
exports.NullBuilder = NullBuilder;

//# sourceMappingURL=null.js.map


/***/ }),
/* 153 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StructBuilder = void 0;
/* eslint-disable unicorn/no-array-for-each */
const schema_js_1 = __webpack_require__(128);
const builder_js_1 = __webpack_require__(46);
const type_js_1 = __webpack_require__(113);
/** @ignore */
class StructBuilder extends builder_js_1.Builder {
    setValue(index, value) {
        const { children, type } = this;
        switch (Array.isArray(value) || value.constructor) {
            case true: return type.children.forEach((_, i) => children[i].set(index, value[i]));
            case Map: return type.children.forEach((f, i) => children[i].set(index, value.get(f.name)));
            default: return type.children.forEach((f, i) => children[i].set(index, value[f.name]));
        }
    }
    /** @inheritdoc */
    setValid(index, valid) {
        if (!super.setValid(index, valid)) {
            this.children.forEach((child) => child.setValid(index, valid));
        }
        return valid;
    }
    addChild(child, name = `${this.numChildren}`) {
        const childIndex = this.children.push(child);
        this.type = new type_js_1.Struct([...this.type.children, new schema_js_1.Field(name, child.type, true)]);
        return childIndex;
    }
}
exports.StructBuilder = StructBuilder;

//# sourceMappingURL=struct.js.map


/***/ }),
/* 154 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimestampNanosecondBuilder = exports.TimestampMicrosecondBuilder = exports.TimestampMillisecondBuilder = exports.TimestampSecondBuilder = exports.TimestampBuilder = void 0;
const builder_js_1 = __webpack_require__(46);
const set_js_1 = __webpack_require__(115);
/** @ignore */
class TimestampBuilder extends builder_js_1.FixedWidthBuilder {
}
exports.TimestampBuilder = TimestampBuilder;
TimestampBuilder.prototype._setValue = set_js_1.setTimestamp;
/** @ignore */
class TimestampSecondBuilder extends TimestampBuilder {
}
exports.TimestampSecondBuilder = TimestampSecondBuilder;
TimestampSecondBuilder.prototype._setValue = set_js_1.setTimestampSecond;
/** @ignore */
class TimestampMillisecondBuilder extends TimestampBuilder {
}
exports.TimestampMillisecondBuilder = TimestampMillisecondBuilder;
TimestampMillisecondBuilder.prototype._setValue = set_js_1.setTimestampMillisecond;
/** @ignore */
class TimestampMicrosecondBuilder extends TimestampBuilder {
}
exports.TimestampMicrosecondBuilder = TimestampMicrosecondBuilder;
TimestampMicrosecondBuilder.prototype._setValue = set_js_1.setTimestampMicrosecond;
/** @ignore */
class TimestampNanosecondBuilder extends TimestampBuilder {
}
exports.TimestampNanosecondBuilder = TimestampNanosecondBuilder;
TimestampNanosecondBuilder.prototype._setValue = set_js_1.setTimestampNanosecond;

//# sourceMappingURL=timestamp.js.map


/***/ }),
/* 155 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimeNanosecondBuilder = exports.TimeMicrosecondBuilder = exports.TimeMillisecondBuilder = exports.TimeSecondBuilder = exports.TimeBuilder = void 0;
const builder_js_1 = __webpack_require__(46);
const set_js_1 = __webpack_require__(115);
/** @ignore */
class TimeBuilder extends builder_js_1.FixedWidthBuilder {
}
exports.TimeBuilder = TimeBuilder;
TimeBuilder.prototype._setValue = set_js_1.setTime;
/** @ignore */
class TimeSecondBuilder extends TimeBuilder {
}
exports.TimeSecondBuilder = TimeSecondBuilder;
TimeSecondBuilder.prototype._setValue = set_js_1.setTimeSecond;
/** @ignore */
class TimeMillisecondBuilder extends TimeBuilder {
}
exports.TimeMillisecondBuilder = TimeMillisecondBuilder;
TimeMillisecondBuilder.prototype._setValue = set_js_1.setTimeMillisecond;
/** @ignore */
class TimeMicrosecondBuilder extends TimeBuilder {
}
exports.TimeMicrosecondBuilder = TimeMicrosecondBuilder;
TimeMicrosecondBuilder.prototype._setValue = set_js_1.setTimeMicrosecond;
/** @ignore */
class TimeNanosecondBuilder extends TimeBuilder {
}
exports.TimeNanosecondBuilder = TimeNanosecondBuilder;
TimeNanosecondBuilder.prototype._setValue = set_js_1.setTimeNanosecond;

//# sourceMappingURL=time.js.map


/***/ }),
/* 156 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DenseUnionBuilder = exports.SparseUnionBuilder = exports.UnionBuilder = void 0;
const schema_js_1 = __webpack_require__(128);
const buffer_js_1 = __webpack_require__(123);
const builder_js_1 = __webpack_require__(46);
const type_js_1 = __webpack_require__(113);
/** @ignore */
class UnionBuilder extends builder_js_1.Builder {
    constructor(options) {
        super(options);
        this._typeIds = new buffer_js_1.DataBufferBuilder(Int8Array, 0, 1);
        if (typeof options['valueToChildTypeId'] === 'function') {
            this._valueToChildTypeId = options['valueToChildTypeId'];
        }
    }
    get typeIdToChildIndex() { return this.type.typeIdToChildIndex; }
    append(value, childTypeId) {
        return this.set(this.length, value, childTypeId);
    }
    set(index, value, childTypeId) {
        if (childTypeId === undefined) {
            childTypeId = this._valueToChildTypeId(this, value, index);
        }
        this.setValue(index, value, childTypeId);
        return this;
    }
    setValue(index, value, childTypeId) {
        this._typeIds.set(index, childTypeId);
        const childIndex = this.type.typeIdToChildIndex[childTypeId];
        const child = this.children[childIndex];
        child === null || child === void 0 ? void 0 : child.set(index, value);
    }
    addChild(child, name = `${this.children.length}`) {
        const childTypeId = this.children.push(child);
        const { type: { children, mode, typeIds } } = this;
        const fields = [...children, new schema_js_1.Field(name, child.type)];
        this.type = new type_js_1.Union(mode, [...typeIds, childTypeId], fields);
        return childTypeId;
    }
    /** @ignore */
    // @ts-ignore
    _valueToChildTypeId(builder, value, offset) {
        throw new Error(`Cannot map UnionBuilder value to child typeId. \
Pass the \`childTypeId\` as the second argument to unionBuilder.append(), \
or supply a \`valueToChildTypeId\` function as part of the UnionBuilder constructor options.`);
    }
}
exports.UnionBuilder = UnionBuilder;
/** @ignore */
class SparseUnionBuilder extends UnionBuilder {
}
exports.SparseUnionBuilder = SparseUnionBuilder;
/** @ignore */
class DenseUnionBuilder extends UnionBuilder {
    constructor(options) {
        super(options);
        this._offsets = new buffer_js_1.DataBufferBuilder(Int32Array);
    }
    /** @ignore */
    setValue(index, value, childTypeId) {
        const id = this._typeIds.set(index, childTypeId).buffer[index];
        const child = this.getChildAt(this.type.typeIdToChildIndex[id]);
        const denseIndex = this._offsets.set(index, child.length).buffer[index];
        child === null || child === void 0 ? void 0 : child.set(denseIndex, value);
    }
}
exports.DenseUnionBuilder = DenseUnionBuilder;

//# sourceMappingURL=union.js.map


/***/ }),
/* 157 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Utf8Builder = void 0;
const utf8_js_1 = __webpack_require__(44);
const binary_js_1 = __webpack_require__(138);
const buffer_js_1 = __webpack_require__(123);
const builder_js_1 = __webpack_require__(46);
/** @ignore */
class Utf8Builder extends builder_js_1.VariableWidthBuilder {
    constructor(opts) {
        super(opts);
        this._values = new buffer_js_1.BufferBuilder(Uint8Array);
    }
    get byteLength() {
        let size = this._pendingLength + (this.length * 4);
        this._offsets && (size += this._offsets.byteLength);
        this._values && (size += this._values.byteLength);
        this._nulls && (size += this._nulls.byteLength);
        return size;
    }
    setValue(index, value) {
        return super.setValue(index, (0, utf8_js_1.encodeUtf8)(value));
    }
    // @ts-ignore
    _flushPending(pending, pendingLength) { }
}
exports.Utf8Builder = Utf8Builder;
Utf8Builder.prototype._flushPending = binary_js_1.BinaryBuilder.prototype._flushPending;

//# sourceMappingURL=utf8.js.map


/***/ }),
/* 158 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LargeUtf8Builder = void 0;
const utf8_js_1 = __webpack_require__(44);
const buffer_js_1 = __webpack_require__(123);
const builder_js_1 = __webpack_require__(46);
const largebinary_js_1 = __webpack_require__(139);
/** @ignore */
class LargeUtf8Builder extends builder_js_1.VariableWidthBuilder {
    constructor(opts) {
        super(opts);
        this._values = new buffer_js_1.BufferBuilder(Uint8Array);
    }
    get byteLength() {
        let size = this._pendingLength + (this.length * 4);
        this._offsets && (size += this._offsets.byteLength);
        this._values && (size += this._values.byteLength);
        this._nulls && (size += this._nulls.byteLength);
        return size;
    }
    setValue(index, value) {
        return super.setValue(index, (0, utf8_js_1.encodeUtf8)(value));
    }
    // @ts-ignore
    _flushPending(pending, pendingLength) { }
}
exports.LargeUtf8Builder = LargeUtf8Builder;
LargeUtf8Builder.prototype._flushPending = largebinary_js_1.LargeBinaryBuilder.prototype._flushPending;

//# sourceMappingURL=largeutf8.js.map


/***/ }),
/* 159 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.compareTypes = exports.compareFields = exports.compareSchemas = exports.instance = exports.TypeComparator = void 0;
const visitor_js_1 = __webpack_require__(112);
/** @ignore */
class TypeComparator extends visitor_js_1.Visitor {
    compareSchemas(schema, other) {
        return (schema === other) || (other instanceof schema.constructor &&
            this.compareManyFields(schema.fields, other.fields));
    }
    compareManyFields(fields, others) {
        return (fields === others) || (Array.isArray(fields) &&
            Array.isArray(others) &&
            fields.length === others.length &&
            fields.every((f, i) => this.compareFields(f, others[i])));
    }
    compareFields(field, other) {
        return (field === other) || (other instanceof field.constructor &&
            field.name === other.name &&
            field.nullable === other.nullable &&
            this.visit(field.type, other.type));
    }
}
exports.TypeComparator = TypeComparator;
function compareConstructor(type, other) {
    return other instanceof type.constructor;
}
function compareAny(type, other) {
    return (type === other) || compareConstructor(type, other);
}
function compareInt(type, other) {
    return (type === other) || (compareConstructor(type, other) &&
        type.bitWidth === other.bitWidth &&
        type.isSigned === other.isSigned);
}
function compareFloat(type, other) {
    return (type === other) || (compareConstructor(type, other) &&
        type.precision === other.precision);
}
function compareFixedSizeBinary(type, other) {
    return (type === other) || (compareConstructor(type, other) &&
        type.byteWidth === other.byteWidth);
}
function compareDate(type, other) {
    return (type === other) || (compareConstructor(type, other) &&
        type.unit === other.unit);
}
function compareTimestamp(type, other) {
    return (type === other) || (compareConstructor(type, other) &&
        type.unit === other.unit &&
        type.timezone === other.timezone);
}
function compareTime(type, other) {
    return (type === other) || (compareConstructor(type, other) &&
        type.unit === other.unit &&
        type.bitWidth === other.bitWidth);
}
function compareList(type, other) {
    return (type === other) || (compareConstructor(type, other) &&
        type.children.length === other.children.length &&
        exports.instance.compareManyFields(type.children, other.children));
}
function compareStruct(type, other) {
    return (type === other) || (compareConstructor(type, other) &&
        type.children.length === other.children.length &&
        exports.instance.compareManyFields(type.children, other.children));
}
function compareUnion(type, other) {
    return (type === other) || (compareConstructor(type, other) &&
        type.mode === other.mode &&
        type.typeIds.every((x, i) => x === other.typeIds[i]) &&
        exports.instance.compareManyFields(type.children, other.children));
}
function compareDictionary(type, other) {
    return (type === other) || (compareConstructor(type, other) &&
        type.id === other.id &&
        type.isOrdered === other.isOrdered &&
        exports.instance.visit(type.indices, other.indices) &&
        exports.instance.visit(type.dictionary, other.dictionary));
}
function compareInterval(type, other) {
    return (type === other) || (compareConstructor(type, other) &&
        type.unit === other.unit);
}
function compareDuration(type, other) {
    return (type === other) || (compareConstructor(type, other) &&
        type.unit === other.unit);
}
function compareFixedSizeList(type, other) {
    return (type === other) || (compareConstructor(type, other) &&
        type.listSize === other.listSize &&
        type.children.length === other.children.length &&
        exports.instance.compareManyFields(type.children, other.children));
}
function compareMap(type, other) {
    return (type === other) || (compareConstructor(type, other) &&
        type.keysSorted === other.keysSorted &&
        type.children.length === other.children.length &&
        exports.instance.compareManyFields(type.children, other.children));
}
TypeComparator.prototype.visitNull = compareAny;
TypeComparator.prototype.visitBool = compareAny;
TypeComparator.prototype.visitInt = compareInt;
TypeComparator.prototype.visitInt8 = compareInt;
TypeComparator.prototype.visitInt16 = compareInt;
TypeComparator.prototype.visitInt32 = compareInt;
TypeComparator.prototype.visitInt64 = compareInt;
TypeComparator.prototype.visitUint8 = compareInt;
TypeComparator.prototype.visitUint16 = compareInt;
TypeComparator.prototype.visitUint32 = compareInt;
TypeComparator.prototype.visitUint64 = compareInt;
TypeComparator.prototype.visitFloat = compareFloat;
TypeComparator.prototype.visitFloat16 = compareFloat;
TypeComparator.prototype.visitFloat32 = compareFloat;
TypeComparator.prototype.visitFloat64 = compareFloat;
TypeComparator.prototype.visitUtf8 = compareAny;
TypeComparator.prototype.visitLargeUtf8 = compareAny;
TypeComparator.prototype.visitBinary = compareAny;
TypeComparator.prototype.visitLargeBinary = compareAny;
TypeComparator.prototype.visitFixedSizeBinary = compareFixedSizeBinary;
TypeComparator.prototype.visitDate = compareDate;
TypeComparator.prototype.visitDateDay = compareDate;
TypeComparator.prototype.visitDateMillisecond = compareDate;
TypeComparator.prototype.visitTimestamp = compareTimestamp;
TypeComparator.prototype.visitTimestampSecond = compareTimestamp;
TypeComparator.prototype.visitTimestampMillisecond = compareTimestamp;
TypeComparator.prototype.visitTimestampMicrosecond = compareTimestamp;
TypeComparator.prototype.visitTimestampNanosecond = compareTimestamp;
TypeComparator.prototype.visitTime = compareTime;
TypeComparator.prototype.visitTimeSecond = compareTime;
TypeComparator.prototype.visitTimeMillisecond = compareTime;
TypeComparator.prototype.visitTimeMicrosecond = compareTime;
TypeComparator.prototype.visitTimeNanosecond = compareTime;
TypeComparator.prototype.visitDecimal = compareAny;
TypeComparator.prototype.visitList = compareList;
TypeComparator.prototype.visitStruct = compareStruct;
TypeComparator.prototype.visitUnion = compareUnion;
TypeComparator.prototype.visitDenseUnion = compareUnion;
TypeComparator.prototype.visitSparseUnion = compareUnion;
TypeComparator.prototype.visitDictionary = compareDictionary;
TypeComparator.prototype.visitInterval = compareInterval;
TypeComparator.prototype.visitIntervalDayTime = compareInterval;
TypeComparator.prototype.visitIntervalYearMonth = compareInterval;
TypeComparator.prototype.visitDuration = compareDuration;
TypeComparator.prototype.visitDurationSecond = compareDuration;
TypeComparator.prototype.visitDurationMillisecond = compareDuration;
TypeComparator.prototype.visitDurationMicrosecond = compareDuration;
TypeComparator.prototype.visitDurationNanosecond = compareDuration;
TypeComparator.prototype.visitFixedSizeList = compareFixedSizeList;
TypeComparator.prototype.visitMap = compareMap;
/** @ignore */
exports.instance = new TypeComparator();
function compareSchemas(schema, other) {
    return exports.instance.compareSchemas(schema, other);
}
exports.compareSchemas = compareSchemas;
function compareFields(field, other) {
    return exports.instance.compareFields(field, other);
}
exports.compareFields = compareFields;
function compareTypes(type, other) {
    return exports.instance.visit(type, other);
}
exports.compareTypes = compareTypes;

//# sourceMappingURL=typecomparator.js.map


/***/ }),
/* 160 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.distributeVectorsIntoRecordBatches = void 0;
const data_js_1 = __webpack_require__(117);
const type_js_1 = __webpack_require__(113);
const recordbatch_js_1 = __webpack_require__(134);
/** @ignore */
function distributeVectorsIntoRecordBatches(schema, vecs) {
    return uniformlyDistributeChunksAcrossRecordBatches(schema, vecs.map((v) => v.data.concat()));
}
exports.distributeVectorsIntoRecordBatches = distributeVectorsIntoRecordBatches;
/** @ignore */
function uniformlyDistributeChunksAcrossRecordBatches(schema, cols) {
    const fields = [...schema.fields];
    const batches = [];
    const memo = { numBatches: cols.reduce((n, c) => Math.max(n, c.length), 0) };
    let numBatches = 0, batchLength = 0;
    let i = -1;
    const numColumns = cols.length;
    let child, children = [];
    while (memo.numBatches-- > 0) {
        for (batchLength = Number.POSITIVE_INFINITY, i = -1; ++i < numColumns;) {
            children[i] = child = cols[i].shift();
            batchLength = Math.min(batchLength, child ? child.length : batchLength);
        }
        if (Number.isFinite(batchLength)) {
            children = distributeChildren(fields, batchLength, children, cols, memo);
            if (batchLength > 0) {
                batches[numBatches++] = (0, data_js_1.makeData)({
                    type: new type_js_1.Struct(fields),
                    length: batchLength,
                    nullCount: 0,
                    children: children.slice()
                });
            }
        }
    }
    return [
        schema = schema.assign(fields),
        batches.map((data) => new recordbatch_js_1.RecordBatch(schema, data))
    ];
}
/** @ignore */
function distributeChildren(fields, batchLength, children, columns, memo) {
    var _a;
    const nullBitmapSize = ((batchLength + 63) & ~63) >> 3;
    for (let i = -1, n = columns.length; ++i < n;) {
        const child = children[i];
        const length = child === null || child === void 0 ? void 0 : child.length;
        if (length >= batchLength) {
            if (length === batchLength) {
                children[i] = child;
            }
            else {
                children[i] = child.slice(0, batchLength);
                memo.numBatches = Math.max(memo.numBatches, columns[i].unshift(child.slice(batchLength, length - batchLength)));
            }
        }
        else {
            const field = fields[i];
            fields[i] = field.clone({ nullable: true });
            children[i] = (_a = child === null || child === void 0 ? void 0 : child._changeLengthAndBackfillNullBitmap(batchLength)) !== null && _a !== void 0 ? _a : (0, data_js_1.makeData)({
                type: field.type,
                length: batchLength,
                nullCount: batchLength,
                nullBitmap: new Uint8Array(nullBitmapSize)
            });
        }
    }
    return children;
}

//# sourceMappingURL=recordbatch.js.map


/***/ }),
/* 161 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.magicX2AndPadding = exports.magicAndPadding = exports.magicLength = exports.checkForMagicArrowString = exports.MAGIC = exports.MAGIC_STR = exports.PADDING = exports.JSONMessageReader = exports.AsyncMessageReader = exports.MessageReader = void 0;
const tslib_1 = __webpack_require__(41);
const enum_js_1 = __webpack_require__(48);
const flatbuffers_1 = __webpack_require__(57);
const message_js_1 = __webpack_require__(162);
const compat_js_1 = __webpack_require__(45);
const file_js_1 = __webpack_require__(131);
const buffer_js_1 = __webpack_require__(43);
const stream_js_1 = __webpack_require__(129);
const interfaces_js_1 = __webpack_require__(130);
/** @ignore */ const invalidMessageType = (type) => `Expected ${enum_js_1.MessageHeader[type]} Message in stream, but was null or length 0.`;
/** @ignore */ const nullMessage = (type) => `Header pointer of flatbuffer-encoded ${enum_js_1.MessageHeader[type]} Message is null or length 0.`;
/** @ignore */ const invalidMessageMetadata = (expected, actual) => `Expected to read ${expected} metadata bytes, but only read ${actual}.`;
/** @ignore */ const invalidMessageBodyLength = (expected, actual) => `Expected to read ${expected} bytes for message body, but only read ${actual}.`;
/** @ignore */
class MessageReader {
    constructor(source) {
        this.source = source instanceof stream_js_1.ByteStream ? source : new stream_js_1.ByteStream(source);
    }
    [Symbol.iterator]() { return this; }
    next() {
        let r;
        if ((r = this.readMetadataLength()).done) {
            return interfaces_js_1.ITERATOR_DONE;
        }
        // ARROW-6313: If the first 4 bytes are continuation indicator (-1), read
        // the next 4 for the 32-bit metadata length. Otherwise, assume this is a
        // pre-v0.15 message, where the first 4 bytes are the metadata length.
        if ((r.value === -1) &&
            (r = this.readMetadataLength()).done) {
            return interfaces_js_1.ITERATOR_DONE;
        }
        if ((r = this.readMetadata(r.value)).done) {
            return interfaces_js_1.ITERATOR_DONE;
        }
        return r;
    }
    throw(value) { return this.source.throw(value); }
    return(value) { return this.source.return(value); }
    readMessage(type) {
        let r;
        if ((r = this.next()).done) {
            return null;
        }
        if ((type != null) && r.value.headerType !== type) {
            throw new Error(invalidMessageType(type));
        }
        return r.value;
    }
    readMessageBody(bodyLength) {
        if (bodyLength <= 0) {
            return new Uint8Array(0);
        }
        const buf = (0, buffer_js_1.toUint8Array)(this.source.read(bodyLength));
        if (buf.byteLength < bodyLength) {
            throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));
        }
        // 1. Work around bugs in fs.ReadStream's internal Buffer pooling, see: https://github.com/nodejs/node/issues/24817
        // 2. Work around https://github.com/whatwg/streams/blob/0ebe4b042e467d9876d80ae045de3843092ad797/reference-implementation/lib/helpers.js#L126
        return /* 1. */ (buf.byteOffset % 8 === 0) &&
            /* 2. */ (buf.byteOffset + buf.byteLength) <= buf.buffer.byteLength ? buf : buf.slice();
    }
    readSchema(throwIfNull = false) {
        const type = enum_js_1.MessageHeader.Schema;
        const message = this.readMessage(type);
        const schema = message === null || message === void 0 ? void 0 : message.header();
        if (throwIfNull && !schema) {
            throw new Error(nullMessage(type));
        }
        return schema;
    }
    readMetadataLength() {
        const buf = this.source.read(exports.PADDING);
        const bb = buf && new flatbuffers_1.ByteBuffer(buf);
        const len = (bb === null || bb === void 0 ? void 0 : bb.readInt32(0)) || 0;
        return { done: len === 0, value: len };
    }
    readMetadata(metadataLength) {
        const buf = this.source.read(metadataLength);
        if (!buf) {
            return interfaces_js_1.ITERATOR_DONE;
        }
        if (buf.byteLength < metadataLength) {
            throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));
        }
        return { done: false, value: message_js_1.Message.decode(buf) };
    }
}
exports.MessageReader = MessageReader;
/** @ignore */
class AsyncMessageReader {
    constructor(source, byteLength) {
        this.source = source instanceof stream_js_1.AsyncByteStream ? source
            : (0, compat_js_1.isFileHandle)(source)
                ? new file_js_1.AsyncRandomAccessFile(source, byteLength)
                : new stream_js_1.AsyncByteStream(source);
    }
    [Symbol.asyncIterator]() { return this; }
    next() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let r;
            if ((r = yield this.readMetadataLength()).done) {
                return interfaces_js_1.ITERATOR_DONE;
            }
            // ARROW-6313: If the first 4 bytes are continuation indicator (-1), read
            // the next 4 for the 32-bit metadata length. Otherwise, assume this is a
            // pre-v0.15 message, where the first 4 bytes are the metadata length.
            if ((r.value === -1) &&
                (r = yield this.readMetadataLength()).done) {
                return interfaces_js_1.ITERATOR_DONE;
            }
            if ((r = yield this.readMetadata(r.value)).done) {
                return interfaces_js_1.ITERATOR_DONE;
            }
            return r;
        });
    }
    throw(value) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { return yield this.source.throw(value); });
    }
    return(value) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () { return yield this.source.return(value); });
    }
    readMessage(type) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let r;
            if ((r = yield this.next()).done) {
                return null;
            }
            if ((type != null) && r.value.headerType !== type) {
                throw new Error(invalidMessageType(type));
            }
            return r.value;
        });
    }
    readMessageBody(bodyLength) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (bodyLength <= 0) {
                return new Uint8Array(0);
            }
            const buf = (0, buffer_js_1.toUint8Array)(yield this.source.read(bodyLength));
            if (buf.byteLength < bodyLength) {
                throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));
            }
            // 1. Work around bugs in fs.ReadStream's internal Buffer pooling, see: https://github.com/nodejs/node/issues/24817
            // 2. Work around https://github.com/whatwg/streams/blob/0ebe4b042e467d9876d80ae045de3843092ad797/reference-implementation/lib/helpers.js#L126
            return /* 1. */ (buf.byteOffset % 8 === 0) &&
                /* 2. */ (buf.byteOffset + buf.byteLength) <= buf.buffer.byteLength ? buf : buf.slice();
        });
    }
    readSchema() {
        return tslib_1.__awaiter(this, arguments, void 0, function* (throwIfNull = false) {
            const type = enum_js_1.MessageHeader.Schema;
            const message = yield this.readMessage(type);
            const schema = message === null || message === void 0 ? void 0 : message.header();
            if (throwIfNull && !schema) {
                throw new Error(nullMessage(type));
            }
            return schema;
        });
    }
    readMetadataLength() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const buf = yield this.source.read(exports.PADDING);
            const bb = buf && new flatbuffers_1.ByteBuffer(buf);
            const len = (bb === null || bb === void 0 ? void 0 : bb.readInt32(0)) || 0;
            return { done: len === 0, value: len };
        });
    }
    readMetadata(metadataLength) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const buf = yield this.source.read(metadataLength);
            if (!buf) {
                return interfaces_js_1.ITERATOR_DONE;
            }
            if (buf.byteLength < metadataLength) {
                throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));
            }
            return { done: false, value: message_js_1.Message.decode(buf) };
        });
    }
}
exports.AsyncMessageReader = AsyncMessageReader;
/** @ignore */
class JSONMessageReader extends MessageReader {
    constructor(source) {
        super(new Uint8Array(0));
        this._schema = false;
        this._body = [];
        this._batchIndex = 0;
        this._dictionaryIndex = 0;
        this._json = source instanceof interfaces_js_1.ArrowJSON ? source : new interfaces_js_1.ArrowJSON(source);
    }
    next() {
        const { _json } = this;
        if (!this._schema) {
            this._schema = true;
            const message = message_js_1.Message.fromJSON(_json.schema, enum_js_1.MessageHeader.Schema);
            return { done: false, value: message };
        }
        if (this._dictionaryIndex < _json.dictionaries.length) {
            const batch = _json.dictionaries[this._dictionaryIndex++];
            this._body = batch['data']['columns'];
            const message = message_js_1.Message.fromJSON(batch, enum_js_1.MessageHeader.DictionaryBatch);
            return { done: false, value: message };
        }
        if (this._batchIndex < _json.batches.length) {
            const batch = _json.batches[this._batchIndex++];
            this._body = batch['columns'];
            const message = message_js_1.Message.fromJSON(batch, enum_js_1.MessageHeader.RecordBatch);
            return { done: false, value: message };
        }
        this._body = [];
        return interfaces_js_1.ITERATOR_DONE;
    }
    readMessageBody(_bodyLength) {
        return flattenDataSources(this._body);
        function flattenDataSources(xs) {
            return (xs || []).reduce((buffers, column) => [
                ...buffers,
                ...(column['VALIDITY'] && [column['VALIDITY']] || []),
                ...(column['TYPE_ID'] && [column['TYPE_ID']] || []),
                ...(column['OFFSET'] && [column['OFFSET']] || []),
                ...(column['DATA'] && [column['DATA']] || []),
                ...flattenDataSources(column['children'])
            ], []);
        }
    }
    readMessage(type) {
        let r;
        if ((r = this.next()).done) {
            return null;
        }
        if ((type != null) && r.value.headerType !== type) {
            throw new Error(invalidMessageType(type));
        }
        return r.value;
    }
    readSchema() {
        const type = enum_js_1.MessageHeader.Schema;
        const message = this.readMessage(type);
        const schema = message === null || message === void 0 ? void 0 : message.header();
        if (!message || !schema) {
            throw new Error(nullMessage(type));
        }
        return schema;
    }
}
exports.JSONMessageReader = JSONMessageReader;
/** @ignore */
exports.PADDING = 4;
/** @ignore */
exports.MAGIC_STR = 'ARROW1';
/** @ignore */
exports.MAGIC = new Uint8Array(exports.MAGIC_STR.length);
for (let i = 0; i < exports.MAGIC_STR.length; i += 1) {
    exports.MAGIC[i] = exports.MAGIC_STR.codePointAt(i);
}
/** @ignore */
function checkForMagicArrowString(buffer, index = 0) {
    for (let i = -1, n = exports.MAGIC.length; ++i < n;) {
        if (exports.MAGIC[i] !== buffer[index + i]) {
            return false;
        }
    }
    return true;
}
exports.checkForMagicArrowString = checkForMagicArrowString;
/** @ignore */
exports.magicLength = exports.MAGIC.length;
/** @ignore */
exports.magicAndPadding = exports.magicLength + exports.PADDING;
/** @ignore */
exports.magicX2AndPadding = exports.magicLength * 2 + exports.PADDING;

//# sourceMappingURL=message.js.map


/***/ }),
/* 162 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FieldNode = exports.BufferRegion = exports.DictionaryBatch = exports.RecordBatch = exports.Message = void 0;
/* eslint-disable brace-style */
const flatbuffers = __webpack_require__(57);
const schema_js_1 = __webpack_require__(69);
const int_js_1 = __webpack_require__(74);
const record_batch_js_1 = __webpack_require__(63);
const dictionary_batch_js_1 = __webpack_require__(56);
const buffer_js_1 = __webpack_require__(67);
const field_js_1 = __webpack_require__(71);
const field_node_js_1 = __webpack_require__(68);
const type_js_1 = __webpack_require__(76);
const key_value_js_1 = __webpack_require__(75);
const endianness_js_1 = __webpack_require__(70);
const floating_point_js_1 = __webpack_require__(84);
const decimal_js_1 = __webpack_require__(80);
const date_js_1 = __webpack_require__(79);
const time_js_1 = __webpack_require__(94);
const timestamp_js_1 = __webpack_require__(95);
const interval_js_1 = __webpack_require__(85);
const duration_js_1 = __webpack_require__(81);
const union_js_1 = __webpack_require__(96);
const fixed_size_binary_js_1 = __webpack_require__(82);
const fixed_size_list_js_1 = __webpack_require__(83);
const map_js_1 = __webpack_require__(90);
const message_js_1 = __webpack_require__(163);
const schema_js_2 = __webpack_require__(128);
const buffer_js_2 = __webpack_require__(43);
const bigint_js_1 = __webpack_require__(111);
const enum_js_1 = __webpack_require__(48);
const typeassembler_js_1 = __webpack_require__(164);
const json_js_1 = __webpack_require__(165);
var Builder = flatbuffers.Builder;
var ByteBuffer = flatbuffers.ByteBuffer;
const type_js_2 = __webpack_require__(113);
/**
 * @ignore
 * @private
 **/
class Message {
    /** @nocollapse */
    static fromJSON(msg, headerType) {
        const message = new Message(0, enum_js_1.MetadataVersion.V5, headerType);
        message._createHeader = messageHeaderFromJSON(msg, headerType);
        return message;
    }
    /** @nocollapse */
    static decode(buf) {
        buf = new ByteBuffer((0, buffer_js_2.toUint8Array)(buf));
        const _message = message_js_1.Message.getRootAsMessage(buf);
        const bodyLength = _message.bodyLength();
        const version = _message.version();
        const headerType = _message.headerType();
        const message = new Message(bodyLength, version, headerType);
        message._createHeader = decodeMessageHeader(_message, headerType);
        return message;
    }
    /** @nocollapse */
    static encode(message) {
        const b = new Builder();
        let headerOffset = -1;
        if (message.isSchema()) {
            headerOffset = schema_js_2.Schema.encode(b, message.header());
        }
        else if (message.isRecordBatch()) {
            headerOffset = RecordBatch.encode(b, message.header());
        }
        else if (message.isDictionaryBatch()) {
            headerOffset = DictionaryBatch.encode(b, message.header());
        }
        message_js_1.Message.startMessage(b);
        message_js_1.Message.addVersion(b, enum_js_1.MetadataVersion.V5);
        message_js_1.Message.addHeader(b, headerOffset);
        message_js_1.Message.addHeaderType(b, message.headerType);
        message_js_1.Message.addBodyLength(b, BigInt(message.bodyLength));
        message_js_1.Message.finishMessageBuffer(b, message_js_1.Message.endMessage(b));
        return b.asUint8Array();
    }
    /** @nocollapse */
    static from(header, bodyLength = 0) {
        if (header instanceof schema_js_2.Schema) {
            return new Message(0, enum_js_1.MetadataVersion.V5, enum_js_1.MessageHeader.Schema, header);
        }
        if (header instanceof RecordBatch) {
            return new Message(bodyLength, enum_js_1.MetadataVersion.V5, enum_js_1.MessageHeader.RecordBatch, header);
        }
        if (header instanceof DictionaryBatch) {
            return new Message(bodyLength, enum_js_1.MetadataVersion.V5, enum_js_1.MessageHeader.DictionaryBatch, header);
        }
        throw new Error(`Unrecognized Message header: ${header}`);
    }
    get type() { return this.headerType; }
    get version() { return this._version; }
    get headerType() { return this._headerType; }
    get bodyLength() { return this._bodyLength; }
    header() { return this._createHeader(); }
    isSchema() { return this.headerType === enum_js_1.MessageHeader.Schema; }
    isRecordBatch() { return this.headerType === enum_js_1.MessageHeader.RecordBatch; }
    isDictionaryBatch() { return this.headerType === enum_js_1.MessageHeader.DictionaryBatch; }
    constructor(bodyLength, version, headerType, header) {
        this._version = version;
        this._headerType = headerType;
        this.body = new Uint8Array(0);
        header && (this._createHeader = () => header);
        this._bodyLength = (0, bigint_js_1.bigIntToNumber)(bodyLength);
    }
}
exports.Message = Message;
/**
 * @ignore
 * @private
 **/
class RecordBatch {
    get nodes() { return this._nodes; }
    get length() { return this._length; }
    get buffers() { return this._buffers; }
    constructor(length, nodes, buffers) {
        this._nodes = nodes;
        this._buffers = buffers;
        this._length = (0, bigint_js_1.bigIntToNumber)(length);
    }
}
exports.RecordBatch = RecordBatch;
/**
 * @ignore
 * @private
 **/
class DictionaryBatch {
    get id() { return this._id; }
    get data() { return this._data; }
    get isDelta() { return this._isDelta; }
    get length() { return this.data.length; }
    get nodes() { return this.data.nodes; }
    get buffers() { return this.data.buffers; }
    constructor(data, id, isDelta = false) {
        this._data = data;
        this._isDelta = isDelta;
        this._id = (0, bigint_js_1.bigIntToNumber)(id);
    }
}
exports.DictionaryBatch = DictionaryBatch;
/**
 * @ignore
 * @private
 **/
class BufferRegion {
    constructor(offset, length) {
        this.offset = (0, bigint_js_1.bigIntToNumber)(offset);
        this.length = (0, bigint_js_1.bigIntToNumber)(length);
    }
}
exports.BufferRegion = BufferRegion;
/**
 * @ignore
 * @private
 **/
class FieldNode {
    constructor(length, nullCount) {
        this.length = (0, bigint_js_1.bigIntToNumber)(length);
        this.nullCount = (0, bigint_js_1.bigIntToNumber)(nullCount);
    }
}
exports.FieldNode = FieldNode;
/** @ignore */
function messageHeaderFromJSON(message, type) {
    return (() => {
        switch (type) {
            case enum_js_1.MessageHeader.Schema: return schema_js_2.Schema.fromJSON(message);
            case enum_js_1.MessageHeader.RecordBatch: return RecordBatch.fromJSON(message);
            case enum_js_1.MessageHeader.DictionaryBatch: return DictionaryBatch.fromJSON(message);
        }
        throw new Error(`Unrecognized Message type: { name: ${enum_js_1.MessageHeader[type]}, type: ${type} }`);
    });
}
/** @ignore */
function decodeMessageHeader(message, type) {
    return (() => {
        switch (type) {
            case enum_js_1.MessageHeader.Schema: return schema_js_2.Schema.decode(message.header(new schema_js_1.Schema()), new Map(), message.version());
            case enum_js_1.MessageHeader.RecordBatch: return RecordBatch.decode(message.header(new record_batch_js_1.RecordBatch()), message.version());
            case enum_js_1.MessageHeader.DictionaryBatch: return DictionaryBatch.decode(message.header(new dictionary_batch_js_1.DictionaryBatch()), message.version());
        }
        throw new Error(`Unrecognized Message type: { name: ${enum_js_1.MessageHeader[type]}, type: ${type} }`);
    });
}
schema_js_2.Field['encode'] = encodeField;
schema_js_2.Field['decode'] = decodeField;
schema_js_2.Field['fromJSON'] = json_js_1.fieldFromJSON;
schema_js_2.Schema['encode'] = encodeSchema;
schema_js_2.Schema['decode'] = decodeSchema;
schema_js_2.Schema['fromJSON'] = json_js_1.schemaFromJSON;
RecordBatch['encode'] = encodeRecordBatch;
RecordBatch['decode'] = decodeRecordBatch;
RecordBatch['fromJSON'] = json_js_1.recordBatchFromJSON;
DictionaryBatch['encode'] = encodeDictionaryBatch;
DictionaryBatch['decode'] = decodeDictionaryBatch;
DictionaryBatch['fromJSON'] = json_js_1.dictionaryBatchFromJSON;
FieldNode['encode'] = encodeFieldNode;
FieldNode['decode'] = decodeFieldNode;
BufferRegion['encode'] = encodeBufferRegion;
BufferRegion['decode'] = decodeBufferRegion;
/** @ignore */
function decodeSchema(_schema, dictionaries = new Map(), version = enum_js_1.MetadataVersion.V5) {
    const fields = decodeSchemaFields(_schema, dictionaries);
    return new schema_js_2.Schema(fields, decodeCustomMetadata(_schema), dictionaries, version);
}
/** @ignore */
function decodeRecordBatch(batch, version = enum_js_1.MetadataVersion.V5) {
    if (batch.compression() !== null) {
        throw new Error('Record batch compression not implemented');
    }
    return new RecordBatch(batch.length(), decodeFieldNodes(batch), decodeBuffers(batch, version));
}
/** @ignore */
function decodeDictionaryBatch(batch, version = enum_js_1.MetadataVersion.V5) {
    return new DictionaryBatch(RecordBatch.decode(batch.data(), version), batch.id(), batch.isDelta());
}
/** @ignore */
function decodeBufferRegion(b) {
    return new BufferRegion(b.offset(), b.length());
}
/** @ignore */
function decodeFieldNode(f) {
    return new FieldNode(f.length(), f.nullCount());
}
/** @ignore */
function decodeFieldNodes(batch) {
    const nodes = [];
    for (let f, i = -1, j = -1, n = batch.nodesLength(); ++i < n;) {
        if (f = batch.nodes(i)) {
            nodes[++j] = FieldNode.decode(f);
        }
    }
    return nodes;
}
/** @ignore */
function decodeBuffers(batch, version) {
    const bufferRegions = [];
    for (let b, i = -1, j = -1, n = batch.buffersLength(); ++i < n;) {
        if (b = batch.buffers(i)) {
            // If this Arrow buffer was written before version 4,
            // advance the buffer's bb_pos 8 bytes to skip past
            // the now-removed page_id field
            if (version < enum_js_1.MetadataVersion.V4) {
                b.bb_pos += (8 * (i + 1));
            }
            bufferRegions[++j] = BufferRegion.decode(b);
        }
    }
    return bufferRegions;
}
/** @ignore */
function decodeSchemaFields(schema, dictionaries) {
    const fields = [];
    for (let f, i = -1, j = -1, n = schema.fieldsLength(); ++i < n;) {
        if (f = schema.fields(i)) {
            fields[++j] = schema_js_2.Field.decode(f, dictionaries);
        }
    }
    return fields;
}
/** @ignore */
function decodeFieldChildren(field, dictionaries) {
    const children = [];
    for (let f, i = -1, j = -1, n = field.childrenLength(); ++i < n;) {
        if (f = field.children(i)) {
            children[++j] = schema_js_2.Field.decode(f, dictionaries);
        }
    }
    return children;
}
/** @ignore */
function decodeField(f, dictionaries) {
    let id;
    let field;
    let type;
    let keys;
    let dictType;
    let dictMeta;
    // If no dictionary encoding
    if (!dictionaries || !(dictMeta = f.dictionary())) {
        type = decodeFieldType(f, decodeFieldChildren(f, dictionaries));
        field = new schema_js_2.Field(f.name(), type, f.nullable(), decodeCustomMetadata(f));
    }
    // If dictionary encoded and the first time we've seen this dictionary id, decode
    // the data type and child fields, then wrap in a Dictionary type and insert the
    // data type into the dictionary types map.
    else if (!dictionaries.has(id = (0, bigint_js_1.bigIntToNumber)(dictMeta.id()))) {
        // a dictionary index defaults to signed 32 bit int if unspecified
        keys = (keys = dictMeta.indexType()) ? decodeIndexType(keys) : new type_js_2.Int32();
        dictionaries.set(id, type = decodeFieldType(f, decodeFieldChildren(f, dictionaries)));
        dictType = new type_js_2.Dictionary(type, keys, id, dictMeta.isOrdered());
        field = new schema_js_2.Field(f.name(), dictType, f.nullable(), decodeCustomMetadata(f));
    }
    // If dictionary encoded, and have already seen this dictionary Id in the schema, then reuse the
    // data type and wrap in a new Dictionary type and field.
    else {
        // a dictionary index defaults to signed 32 bit int if unspecified
        keys = (keys = dictMeta.indexType()) ? decodeIndexType(keys) : new type_js_2.Int32();
        dictType = new type_js_2.Dictionary(dictionaries.get(id), keys, id, dictMeta.isOrdered());
        field = new schema_js_2.Field(f.name(), dictType, f.nullable(), decodeCustomMetadata(f));
    }
    return field || null;
}
/** @ignore */
function decodeCustomMetadata(parent) {
    const data = new Map();
    if (parent) {
        for (let entry, key, i = -1, n = Math.trunc(parent.customMetadataLength()); ++i < n;) {
            if ((entry = parent.customMetadata(i)) && (key = entry.key()) != null) {
                data.set(key, entry.value());
            }
        }
    }
    return data;
}
/** @ignore */
function decodeIndexType(_type) {
    return new type_js_2.Int(_type.isSigned(), _type.bitWidth());
}
/** @ignore */
function decodeFieldType(f, children) {
    const typeId = f.typeType();
    switch (typeId) {
        case type_js_1.Type['NONE']: return new type_js_2.Null();
        case type_js_1.Type['Null']: return new type_js_2.Null();
        case type_js_1.Type['Binary']: return new type_js_2.Binary();
        case type_js_1.Type['LargeBinary']: return new type_js_2.LargeBinary();
        case type_js_1.Type['Utf8']: return new type_js_2.Utf8();
        case type_js_1.Type['LargeUtf8']: return new type_js_2.LargeUtf8();
        case type_js_1.Type['Bool']: return new type_js_2.Bool();
        case type_js_1.Type['List']: return new type_js_2.List((children || [])[0]);
        case type_js_1.Type['Struct_']: return new type_js_2.Struct(children || []);
    }
    switch (typeId) {
        case type_js_1.Type['Int']: {
            const t = f.type(new int_js_1.Int());
            return new type_js_2.Int(t.isSigned(), t.bitWidth());
        }
        case type_js_1.Type['FloatingPoint']: {
            const t = f.type(new floating_point_js_1.FloatingPoint());
            return new type_js_2.Float(t.precision());
        }
        case type_js_1.Type['Decimal']: {
            const t = f.type(new decimal_js_1.Decimal());
            return new type_js_2.Decimal(t.scale(), t.precision(), t.bitWidth());
        }
        case type_js_1.Type['Date']: {
            const t = f.type(new date_js_1.Date());
            return new type_js_2.Date_(t.unit());
        }
        case type_js_1.Type['Time']: {
            const t = f.type(new time_js_1.Time());
            return new type_js_2.Time(t.unit(), t.bitWidth());
        }
        case type_js_1.Type['Timestamp']: {
            const t = f.type(new timestamp_js_1.Timestamp());
            return new type_js_2.Timestamp(t.unit(), t.timezone());
        }
        case type_js_1.Type['Interval']: {
            const t = f.type(new interval_js_1.Interval());
            return new type_js_2.Interval(t.unit());
        }
        case type_js_1.Type['Duration']: {
            const t = f.type(new duration_js_1.Duration());
            return new type_js_2.Duration(t.unit());
        }
        case type_js_1.Type['Union']: {
            const t = f.type(new union_js_1.Union());
            return new type_js_2.Union(t.mode(), t.typeIdsArray() || [], children || []);
        }
        case type_js_1.Type['FixedSizeBinary']: {
            const t = f.type(new fixed_size_binary_js_1.FixedSizeBinary());
            return new type_js_2.FixedSizeBinary(t.byteWidth());
        }
        case type_js_1.Type['FixedSizeList']: {
            const t = f.type(new fixed_size_list_js_1.FixedSizeList());
            return new type_js_2.FixedSizeList(t.listSize(), (children || [])[0]);
        }
        case type_js_1.Type['Map']: {
            const t = f.type(new map_js_1.Map());
            return new type_js_2.Map_((children || [])[0], t.keysSorted());
        }
    }
    throw new Error(`Unrecognized type: "${type_js_1.Type[typeId]}" (${typeId})`);
}
/** @ignore */
function encodeSchema(b, schema) {
    const fieldOffsets = schema.fields.map((f) => schema_js_2.Field.encode(b, f));
    schema_js_1.Schema.startFieldsVector(b, fieldOffsets.length);
    const fieldsVectorOffset = schema_js_1.Schema.createFieldsVector(b, fieldOffsets);
    const metadataOffset = !(schema.metadata && schema.metadata.size > 0) ? -1 :
        schema_js_1.Schema.createCustomMetadataVector(b, [...schema.metadata].map(([k, v]) => {
            const key = b.createString(`${k}`);
            const val = b.createString(`${v}`);
            key_value_js_1.KeyValue.startKeyValue(b);
            key_value_js_1.KeyValue.addKey(b, key);
            key_value_js_1.KeyValue.addValue(b, val);
            return key_value_js_1.KeyValue.endKeyValue(b);
        }));
    schema_js_1.Schema.startSchema(b);
    schema_js_1.Schema.addFields(b, fieldsVectorOffset);
    schema_js_1.Schema.addEndianness(b, platformIsLittleEndian ? endianness_js_1.Endianness.Little : endianness_js_1.Endianness.Big);
    if (metadataOffset !== -1) {
        schema_js_1.Schema.addCustomMetadata(b, metadataOffset);
    }
    return schema_js_1.Schema.endSchema(b);
}
/** @ignore */
function encodeField(b, field) {
    let nameOffset = -1;
    let typeOffset = -1;
    let dictionaryOffset = -1;
    const type = field.type;
    let typeId = field.typeId;
    if (!type_js_2.DataType.isDictionary(type)) {
        typeOffset = typeassembler_js_1.instance.visit(type, b);
    }
    else {
        typeId = type.dictionary.typeId;
        dictionaryOffset = typeassembler_js_1.instance.visit(type, b);
        typeOffset = typeassembler_js_1.instance.visit(type.dictionary, b);
    }
    const childOffsets = (type.children || []).map((f) => schema_js_2.Field.encode(b, f));
    const childrenVectorOffset = field_js_1.Field.createChildrenVector(b, childOffsets);
    const metadataOffset = !(field.metadata && field.metadata.size > 0) ? -1 :
        field_js_1.Field.createCustomMetadataVector(b, [...field.metadata].map(([k, v]) => {
            const key = b.createString(`${k}`);
            const val = b.createString(`${v}`);
            key_value_js_1.KeyValue.startKeyValue(b);
            key_value_js_1.KeyValue.addKey(b, key);
            key_value_js_1.KeyValue.addValue(b, val);
            return key_value_js_1.KeyValue.endKeyValue(b);
        }));
    if (field.name) {
        nameOffset = b.createString(field.name);
    }
    field_js_1.Field.startField(b);
    field_js_1.Field.addType(b, typeOffset);
    field_js_1.Field.addTypeType(b, typeId);
    field_js_1.Field.addChildren(b, childrenVectorOffset);
    field_js_1.Field.addNullable(b, !!field.nullable);
    if (nameOffset !== -1) {
        field_js_1.Field.addName(b, nameOffset);
    }
    if (dictionaryOffset !== -1) {
        field_js_1.Field.addDictionary(b, dictionaryOffset);
    }
    if (metadataOffset !== -1) {
        field_js_1.Field.addCustomMetadata(b, metadataOffset);
    }
    return field_js_1.Field.endField(b);
}
/** @ignore */
function encodeRecordBatch(b, recordBatch) {
    const nodes = recordBatch.nodes || [];
    const buffers = recordBatch.buffers || [];
    record_batch_js_1.RecordBatch.startNodesVector(b, nodes.length);
    for (const n of nodes.slice().reverse())
        FieldNode.encode(b, n);
    const nodesVectorOffset = b.endVector();
    record_batch_js_1.RecordBatch.startBuffersVector(b, buffers.length);
    for (const b_ of buffers.slice().reverse())
        BufferRegion.encode(b, b_);
    const buffersVectorOffset = b.endVector();
    record_batch_js_1.RecordBatch.startRecordBatch(b);
    record_batch_js_1.RecordBatch.addLength(b, BigInt(recordBatch.length));
    record_batch_js_1.RecordBatch.addNodes(b, nodesVectorOffset);
    record_batch_js_1.RecordBatch.addBuffers(b, buffersVectorOffset);
    return record_batch_js_1.RecordBatch.endRecordBatch(b);
}
/** @ignore */
function encodeDictionaryBatch(b, dictionaryBatch) {
    const dataOffset = RecordBatch.encode(b, dictionaryBatch.data);
    dictionary_batch_js_1.DictionaryBatch.startDictionaryBatch(b);
    dictionary_batch_js_1.DictionaryBatch.addId(b, BigInt(dictionaryBatch.id));
    dictionary_batch_js_1.DictionaryBatch.addIsDelta(b, dictionaryBatch.isDelta);
    dictionary_batch_js_1.DictionaryBatch.addData(b, dataOffset);
    return dictionary_batch_js_1.DictionaryBatch.endDictionaryBatch(b);
}
/** @ignore */
function encodeFieldNode(b, node) {
    return field_node_js_1.FieldNode.createFieldNode(b, BigInt(node.length), BigInt(node.nullCount));
}
/** @ignore */
function encodeBufferRegion(b, node) {
    return buffer_js_1.Buffer.createBuffer(b, BigInt(node.offset), BigInt(node.length));
}
/** @ignore */
const platformIsLittleEndian = (() => {
    const buffer = new ArrayBuffer(2);
    new DataView(buffer).setInt16(0, 256, true /* littleEndian */);
    // Int16Array uses the platform's endianness.
    return new Int16Array(buffer)[0] === 256;
})();

//# sourceMappingURL=message.js.map


/***/ }),
/* 163 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Message = void 0;
const flatbuffers = __webpack_require__(57);
const key_value_js_1 = __webpack_require__(75);
const message_header_js_1 = __webpack_require__(55);
const metadata_version_js_1 = __webpack_require__(49);
class Message {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsMessage(bb, obj) {
        return (obj || new Message()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsMessage(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Message()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    version() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : metadata_version_js_1.MetadataVersion.V1;
    }
    headerType() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : message_header_js_1.MessageHeader.NONE;
    }
    header(obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    bodyLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt('0');
    }
    customMetadata(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? (obj || new key_value_js_1.KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    customMetadataLength() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startMessage(builder) {
        builder.startObject(5);
    }
    static addVersion(builder, version) {
        builder.addFieldInt16(0, version, metadata_version_js_1.MetadataVersion.V1);
    }
    static addHeaderType(builder, headerType) {
        builder.addFieldInt8(1, headerType, message_header_js_1.MessageHeader.NONE);
    }
    static addHeader(builder, headerOffset) {
        builder.addFieldOffset(2, headerOffset, 0);
    }
    static addBodyLength(builder, bodyLength) {
        builder.addFieldInt64(3, bodyLength, BigInt('0'));
    }
    static addCustomMetadata(builder, customMetadataOffset) {
        builder.addFieldOffset(4, customMetadataOffset, 0);
    }
    static createCustomMetadataVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startCustomMetadataVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endMessage(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static finishMessageBuffer(builder, offset) {
        builder.finish(offset);
    }
    static finishSizePrefixedMessageBuffer(builder, offset) {
        builder.finish(offset, undefined, true);
    }
    static createMessage(builder, version, headerType, headerOffset, bodyLength, customMetadataOffset) {
        Message.startMessage(builder);
        Message.addVersion(builder, version);
        Message.addHeaderType(builder, headerType);
        Message.addHeader(builder, headerOffset);
        Message.addBodyLength(builder, bodyLength);
        Message.addCustomMetadata(builder, customMetadataOffset);
        return Message.endMessage(builder);
    }
}
exports.Message = Message;

//# sourceMappingURL=message.js.map


/***/ }),
/* 164 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.instance = exports.TypeAssembler = void 0;
const visitor_js_1 = __webpack_require__(112);
const null_js_1 = __webpack_require__(91);
const int_js_1 = __webpack_require__(74);
const floating_point_js_1 = __webpack_require__(84);
const binary_js_1 = __webpack_require__(77);
const large_binary_js_1 = __webpack_require__(86);
const bool_js_1 = __webpack_require__(78);
const utf8_js_1 = __webpack_require__(97);
const large_utf8_js_1 = __webpack_require__(88);
const decimal_js_1 = __webpack_require__(80);
const date_js_1 = __webpack_require__(79);
const time_js_1 = __webpack_require__(94);
const timestamp_js_1 = __webpack_require__(95);
const interval_js_1 = __webpack_require__(85);
const duration_js_1 = __webpack_require__(81);
const list_js_1 = __webpack_require__(89);
const struct__js_1 = __webpack_require__(93);
const union_js_1 = __webpack_require__(96);
const dictionary_encoding_js_1 = __webpack_require__(72);
const fixed_size_binary_js_1 = __webpack_require__(82);
const fixed_size_list_js_1 = __webpack_require__(83);
const map_js_1 = __webpack_require__(90);
/** @ignore */
class TypeAssembler extends visitor_js_1.Visitor {
    visit(node, builder) {
        return (node == null || builder == null) ? undefined : super.visit(node, builder);
    }
    visitNull(_node, b) {
        null_js_1.Null.startNull(b);
        return null_js_1.Null.endNull(b);
    }
    visitInt(node, b) {
        int_js_1.Int.startInt(b);
        int_js_1.Int.addBitWidth(b, node.bitWidth);
        int_js_1.Int.addIsSigned(b, node.isSigned);
        return int_js_1.Int.endInt(b);
    }
    visitFloat(node, b) {
        floating_point_js_1.FloatingPoint.startFloatingPoint(b);
        floating_point_js_1.FloatingPoint.addPrecision(b, node.precision);
        return floating_point_js_1.FloatingPoint.endFloatingPoint(b);
    }
    visitBinary(_node, b) {
        binary_js_1.Binary.startBinary(b);
        return binary_js_1.Binary.endBinary(b);
    }
    visitLargeBinary(_node, b) {
        large_binary_js_1.LargeBinary.startLargeBinary(b);
        return large_binary_js_1.LargeBinary.endLargeBinary(b);
    }
    visitBool(_node, b) {
        bool_js_1.Bool.startBool(b);
        return bool_js_1.Bool.endBool(b);
    }
    visitUtf8(_node, b) {
        utf8_js_1.Utf8.startUtf8(b);
        return utf8_js_1.Utf8.endUtf8(b);
    }
    visitLargeUtf8(_node, b) {
        large_utf8_js_1.LargeUtf8.startLargeUtf8(b);
        return large_utf8_js_1.LargeUtf8.endLargeUtf8(b);
    }
    visitDecimal(node, b) {
        decimal_js_1.Decimal.startDecimal(b);
        decimal_js_1.Decimal.addScale(b, node.scale);
        decimal_js_1.Decimal.addPrecision(b, node.precision);
        decimal_js_1.Decimal.addBitWidth(b, node.bitWidth);
        return decimal_js_1.Decimal.endDecimal(b);
    }
    visitDate(node, b) {
        date_js_1.Date.startDate(b);
        date_js_1.Date.addUnit(b, node.unit);
        return date_js_1.Date.endDate(b);
    }
    visitTime(node, b) {
        time_js_1.Time.startTime(b);
        time_js_1.Time.addUnit(b, node.unit);
        time_js_1.Time.addBitWidth(b, node.bitWidth);
        return time_js_1.Time.endTime(b);
    }
    visitTimestamp(node, b) {
        const timezone = (node.timezone && b.createString(node.timezone)) || undefined;
        timestamp_js_1.Timestamp.startTimestamp(b);
        timestamp_js_1.Timestamp.addUnit(b, node.unit);
        if (timezone !== undefined) {
            timestamp_js_1.Timestamp.addTimezone(b, timezone);
        }
        return timestamp_js_1.Timestamp.endTimestamp(b);
    }
    visitInterval(node, b) {
        interval_js_1.Interval.startInterval(b);
        interval_js_1.Interval.addUnit(b, node.unit);
        return interval_js_1.Interval.endInterval(b);
    }
    visitDuration(node, b) {
        duration_js_1.Duration.startDuration(b);
        duration_js_1.Duration.addUnit(b, node.unit);
        return duration_js_1.Duration.endDuration(b);
    }
    visitList(_node, b) {
        list_js_1.List.startList(b);
        return list_js_1.List.endList(b);
    }
    visitStruct(_node, b) {
        struct__js_1.Struct_.startStruct_(b);
        return struct__js_1.Struct_.endStruct_(b);
    }
    visitUnion(node, b) {
        union_js_1.Union.startTypeIdsVector(b, node.typeIds.length);
        const typeIds = union_js_1.Union.createTypeIdsVector(b, node.typeIds);
        union_js_1.Union.startUnion(b);
        union_js_1.Union.addMode(b, node.mode);
        union_js_1.Union.addTypeIds(b, typeIds);
        return union_js_1.Union.endUnion(b);
    }
    visitDictionary(node, b) {
        const indexType = this.visit(node.indices, b);
        dictionary_encoding_js_1.DictionaryEncoding.startDictionaryEncoding(b);
        dictionary_encoding_js_1.DictionaryEncoding.addId(b, BigInt(node.id));
        dictionary_encoding_js_1.DictionaryEncoding.addIsOrdered(b, node.isOrdered);
        if (indexType !== undefined) {
            dictionary_encoding_js_1.DictionaryEncoding.addIndexType(b, indexType);
        }
        return dictionary_encoding_js_1.DictionaryEncoding.endDictionaryEncoding(b);
    }
    visitFixedSizeBinary(node, b) {
        fixed_size_binary_js_1.FixedSizeBinary.startFixedSizeBinary(b);
        fixed_size_binary_js_1.FixedSizeBinary.addByteWidth(b, node.byteWidth);
        return fixed_size_binary_js_1.FixedSizeBinary.endFixedSizeBinary(b);
    }
    visitFixedSizeList(node, b) {
        fixed_size_list_js_1.FixedSizeList.startFixedSizeList(b);
        fixed_size_list_js_1.FixedSizeList.addListSize(b, node.listSize);
        return fixed_size_list_js_1.FixedSizeList.endFixedSizeList(b);
    }
    visitMap(node, b) {
        map_js_1.Map.startMap(b);
        map_js_1.Map.addKeysSorted(b, node.keysSorted);
        return map_js_1.Map.endMap(b);
    }
}
exports.TypeAssembler = TypeAssembler;
/** @ignore */
exports.instance = new TypeAssembler();

//# sourceMappingURL=typeassembler.js.map


/***/ }),
/* 165 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fieldFromJSON = exports.dictionaryBatchFromJSON = exports.recordBatchFromJSON = exports.schemaFromJSON = void 0;
/* eslint-disable brace-style */
const schema_js_1 = __webpack_require__(128);
const type_js_1 = __webpack_require__(113);
const message_js_1 = __webpack_require__(162);
const enum_js_1 = __webpack_require__(48);
/** @ignore */
function schemaFromJSON(_schema, dictionaries = new Map()) {
    return new schema_js_1.Schema(schemaFieldsFromJSON(_schema, dictionaries), customMetadataFromJSON(_schema['metadata']), dictionaries);
}
exports.schemaFromJSON = schemaFromJSON;
/** @ignore */
function recordBatchFromJSON(b) {
    return new message_js_1.RecordBatch(b['count'], fieldNodesFromJSON(b['columns']), buffersFromJSON(b['columns']));
}
exports.recordBatchFromJSON = recordBatchFromJSON;
/** @ignore */
function dictionaryBatchFromJSON(b) {
    return new message_js_1.DictionaryBatch(recordBatchFromJSON(b['data']), b['id'], b['isDelta']);
}
exports.dictionaryBatchFromJSON = dictionaryBatchFromJSON;
/** @ignore */
function schemaFieldsFromJSON(_schema, dictionaries) {
    return (_schema['fields'] || []).filter(Boolean).map((f) => schema_js_1.Field.fromJSON(f, dictionaries));
}
/** @ignore */
function fieldChildrenFromJSON(_field, dictionaries) {
    return (_field['children'] || []).filter(Boolean).map((f) => schema_js_1.Field.fromJSON(f, dictionaries));
}
/** @ignore */
function fieldNodesFromJSON(xs) {
    return (xs || []).reduce((fieldNodes, column) => [
        ...fieldNodes,
        new message_js_1.FieldNode(column['count'], nullCountFromJSON(column['VALIDITY'])),
        ...fieldNodesFromJSON(column['children'])
    ], []);
}
/** @ignore */
function buffersFromJSON(xs, buffers = []) {
    for (let i = -1, n = (xs || []).length; ++i < n;) {
        const column = xs[i];
        column['VALIDITY'] && buffers.push(new message_js_1.BufferRegion(buffers.length, column['VALIDITY'].length));
        column['TYPE_ID'] && buffers.push(new message_js_1.BufferRegion(buffers.length, column['TYPE_ID'].length));
        column['OFFSET'] && buffers.push(new message_js_1.BufferRegion(buffers.length, column['OFFSET'].length));
        column['DATA'] && buffers.push(new message_js_1.BufferRegion(buffers.length, column['DATA'].length));
        buffers = buffersFromJSON(column['children'], buffers);
    }
    return buffers;
}
/** @ignore */
function nullCountFromJSON(validity) {
    return (validity || []).reduce((sum, val) => sum + +(val === 0), 0);
}
/** @ignore */
function fieldFromJSON(_field, dictionaries) {
    let id;
    let keys;
    let field;
    let dictMeta;
    let type;
    let dictType;
    // If no dictionary encoding
    if (!dictionaries || !(dictMeta = _field['dictionary'])) {
        type = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries));
        field = new schema_js_1.Field(_field['name'], type, _field['nullable'], customMetadataFromJSON(_field['metadata']));
    }
    // If dictionary encoded and the first time we've seen this dictionary id, decode
    // the data type and child fields, then wrap in a Dictionary type and insert the
    // data type into the dictionary types map.
    else if (!dictionaries.has(id = dictMeta['id'])) {
        // a dictionary index defaults to signed 32 bit int if unspecified
        keys = (keys = dictMeta['indexType']) ? indexTypeFromJSON(keys) : new type_js_1.Int32();
        dictionaries.set(id, type = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries)));
        dictType = new type_js_1.Dictionary(type, keys, id, dictMeta['isOrdered']);
        field = new schema_js_1.Field(_field['name'], dictType, _field['nullable'], customMetadataFromJSON(_field['metadata']));
    }
    // If dictionary encoded, and have already seen this dictionary Id in the schema, then reuse the
    // data type and wrap in a new Dictionary type and field.
    else {
        // a dictionary index defaults to signed 32 bit int if unspecified
        keys = (keys = dictMeta['indexType']) ? indexTypeFromJSON(keys) : new type_js_1.Int32();
        dictType = new type_js_1.Dictionary(dictionaries.get(id), keys, id, dictMeta['isOrdered']);
        field = new schema_js_1.Field(_field['name'], dictType, _field['nullable'], customMetadataFromJSON(_field['metadata']));
    }
    return field || null;
}
exports.fieldFromJSON = fieldFromJSON;
/** @ignore */
function customMetadataFromJSON(metadata = []) {
    return new Map(metadata.map(({ key, value }) => [key, value]));
}
/** @ignore */
function indexTypeFromJSON(_type) {
    return new type_js_1.Int(_type['isSigned'], _type['bitWidth']);
}
/** @ignore */
function typeFromJSON(f, children) {
    const typeId = f['type']['name'];
    switch (typeId) {
        case 'NONE': return new type_js_1.Null();
        case 'null': return new type_js_1.Null();
        case 'binary': return new type_js_1.Binary();
        case 'largebinary': return new type_js_1.LargeBinary();
        case 'utf8': return new type_js_1.Utf8();
        case 'largeutf8': return new type_js_1.LargeUtf8();
        case 'bool': return new type_js_1.Bool();
        case 'list': return new type_js_1.List((children || [])[0]);
        case 'struct': return new type_js_1.Struct(children || []);
        case 'struct_': return new type_js_1.Struct(children || []);
    }
    switch (typeId) {
        case 'int': {
            const t = f['type'];
            return new type_js_1.Int(t['isSigned'], t['bitWidth']);
        }
        case 'floatingpoint': {
            const t = f['type'];
            return new type_js_1.Float(enum_js_1.Precision[t['precision']]);
        }
        case 'decimal': {
            const t = f['type'];
            return new type_js_1.Decimal(t['scale'], t['precision'], t['bitWidth']);
        }
        case 'date': {
            const t = f['type'];
            return new type_js_1.Date_(enum_js_1.DateUnit[t['unit']]);
        }
        case 'time': {
            const t = f['type'];
            return new type_js_1.Time(enum_js_1.TimeUnit[t['unit']], t['bitWidth']);
        }
        case 'timestamp': {
            const t = f['type'];
            return new type_js_1.Timestamp(enum_js_1.TimeUnit[t['unit']], t['timezone']);
        }
        case 'interval': {
            const t = f['type'];
            return new type_js_1.Interval(enum_js_1.IntervalUnit[t['unit']]);
        }
        case 'duration': {
            const t = f['type'];
            return new type_js_1.Duration(enum_js_1.TimeUnit[t['unit']]);
        }
        case 'union': {
            const t = f['type'];
            const [m, ...ms] = (t['mode'] + '').toLowerCase();
            const mode = (m.toUpperCase() + ms.join(''));
            return new type_js_1.Union(enum_js_1.UnionMode[mode], (t['typeIds'] || []), children || []);
        }
        case 'fixedsizebinary': {
            const t = f['type'];
            return new type_js_1.FixedSizeBinary(t['byteWidth']);
        }
        case 'fixedsizelist': {
            const t = f['type'];
            return new type_js_1.FixedSizeList(t['listSize'], (children || [])[0]);
        }
        case 'map': {
            const t = f['type'];
            return new type_js_1.Map_((children || [])[0], t['keysSorted']);
        }
    }
    throw new Error(`Unrecognized type: "${typeId}"`);
}

//# sourceMappingURL=json.js.map


/***/ }),
/* 166 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RecordBatchJSONWriter = exports.RecordBatchFileWriter = exports.RecordBatchStreamWriter = exports.RecordBatchWriter = void 0;
const tslib_1 = __webpack_require__(41);
const table_js_1 = __webpack_require__(135);
const message_js_1 = __webpack_require__(161);
const vector_js_1 = __webpack_require__(47);
const type_js_1 = __webpack_require__(113);
const message_js_2 = __webpack_require__(162);
const metadata = __webpack_require__(162);
const file_js_1 = __webpack_require__(125);
const enum_js_1 = __webpack_require__(48);
const typecomparator_js_1 = __webpack_require__(159);
const stream_js_1 = __webpack_require__(129);
const vectorassembler_js_1 = __webpack_require__(167);
const jsontypeassembler_js_1 = __webpack_require__(168);
const jsonvectorassembler_js_1 = __webpack_require__(169);
const buffer_js_1 = __webpack_require__(43);
const recordbatch_js_1 = __webpack_require__(134);
const interfaces_js_1 = __webpack_require__(130);
const compat_js_1 = __webpack_require__(45);
class RecordBatchWriter extends interfaces_js_1.ReadableInterop {
    /** @nocollapse */
    // @ts-ignore
    static throughNode(options) {
        throw new Error(`"throughNode" not available in this environment`);
    }
    /** @nocollapse */
    static throughDOM(
    // @ts-ignore
    writableStrategy, 
    // @ts-ignore
    readableStrategy) {
        throw new Error(`"throughDOM" not available in this environment`);
    }
    constructor(options) {
        super();
        this._position = 0;
        this._started = false;
        // @ts-ignore
        this._sink = new stream_js_1.AsyncByteQueue();
        this._schema = null;
        this._dictionaryBlocks = [];
        this._recordBatchBlocks = [];
        this._seenDictionaries = new Map();
        this._dictionaryDeltaOffsets = new Map();
        (0, compat_js_1.isObject)(options) || (options = { autoDestroy: true, writeLegacyIpcFormat: false });
        this._autoDestroy = (typeof options.autoDestroy === 'boolean') ? options.autoDestroy : true;
        this._writeLegacyIpcFormat = (typeof options.writeLegacyIpcFormat === 'boolean') ? options.writeLegacyIpcFormat : false;
    }
    toString(sync = false) {
        return this._sink.toString(sync);
    }
    toUint8Array(sync = false) {
        return this._sink.toUint8Array(sync);
    }
    writeAll(input) {
        if ((0, compat_js_1.isPromise)(input)) {
            return input.then((x) => this.writeAll(x));
        }
        else if ((0, compat_js_1.isAsyncIterable)(input)) {
            return writeAllAsync(this, input);
        }
        return writeAll(this, input);
    }
    get closed() { return this._sink.closed; }
    [Symbol.asyncIterator]() { return this._sink[Symbol.asyncIterator](); }
    toDOMStream(options) { return this._sink.toDOMStream(options); }
    toNodeStream(options) { return this._sink.toNodeStream(options); }
    close() {
        return this.reset()._sink.close();
    }
    abort(reason) {
        return this.reset()._sink.abort(reason);
    }
    finish() {
        this._autoDestroy ? this.close() : this.reset(this._sink, this._schema);
        return this;
    }
    reset(sink = this._sink, schema = null) {
        if ((sink === this._sink) || (sink instanceof stream_js_1.AsyncByteQueue)) {
            this._sink = sink;
        }
        else {
            this._sink = new stream_js_1.AsyncByteQueue();
            if (sink && (0, compat_js_1.isWritableDOMStream)(sink)) {
                this.toDOMStream({ type: 'bytes' }).pipeTo(sink);
            }
            else if (sink && (0, compat_js_1.isWritableNodeStream)(sink)) {
                this.toNodeStream({ objectMode: false }).pipe(sink);
            }
        }
        if (this._started && this._schema) {
            this._writeFooter(this._schema);
        }
        this._started = false;
        this._dictionaryBlocks = [];
        this._recordBatchBlocks = [];
        this._seenDictionaries = new Map();
        this._dictionaryDeltaOffsets = new Map();
        if (!schema || !((0, typecomparator_js_1.compareSchemas)(schema, this._schema))) {
            if (schema == null) {
                this._position = 0;
                this._schema = null;
            }
            else {
                this._started = true;
                this._schema = schema;
                this._writeSchema(schema);
            }
        }
        return this;
    }
    write(payload) {
        let schema = null;
        if (!this._sink) {
            throw new Error(`RecordBatchWriter is closed`);
        }
        else if (payload == null) {
            return this.finish() && undefined;
        }
        else if (payload instanceof table_js_1.Table && !(schema = payload.schema)) {
            return this.finish() && undefined;
        }
        else if (payload instanceof recordbatch_js_1.RecordBatch && !(schema = payload.schema)) {
            return this.finish() && undefined;
        }
        if (schema && !(0, typecomparator_js_1.compareSchemas)(schema, this._schema)) {
            if (this._started && this._autoDestroy) {
                return this.close();
            }
            this.reset(this._sink, schema);
        }
        if (payload instanceof recordbatch_js_1.RecordBatch) {
            if (!(payload instanceof recordbatch_js_1._InternalEmptyPlaceholderRecordBatch)) {
                this._writeRecordBatch(payload);
            }
        }
        else if (payload instanceof table_js_1.Table) {
            this.writeAll(payload.batches);
        }
        else if ((0, compat_js_1.isIterable)(payload)) {
            this.writeAll(payload);
        }
    }
    _writeMessage(message, alignment = 8) {
        const a = alignment - 1;
        const buffer = message_js_2.Message.encode(message);
        const flatbufferSize = buffer.byteLength;
        const prefixSize = !this._writeLegacyIpcFormat ? 8 : 4;
        const alignedSize = (flatbufferSize + prefixSize + a) & ~a;
        const nPaddingBytes = alignedSize - flatbufferSize - prefixSize;
        if (message.headerType === enum_js_1.MessageHeader.RecordBatch) {
            this._recordBatchBlocks.push(new file_js_1.FileBlock(alignedSize, message.bodyLength, this._position));
        }
        else if (message.headerType === enum_js_1.MessageHeader.DictionaryBatch) {
            this._dictionaryBlocks.push(new file_js_1.FileBlock(alignedSize, message.bodyLength, this._position));
        }
        // If not in legacy pre-0.15.0 mode, write the stream continuation indicator
        if (!this._writeLegacyIpcFormat) {
            this._write(Int32Array.of(-1));
        }
        // Write the flatbuffer size prefix including padding
        this._write(Int32Array.of(alignedSize - prefixSize));
        // Write the flatbuffer
        if (flatbufferSize > 0) {
            this._write(buffer);
        }
        // Write any padding
        return this._writePadding(nPaddingBytes);
    }
    _write(chunk) {
        if (this._started) {
            const buffer = (0, buffer_js_1.toUint8Array)(chunk);
            if (buffer && buffer.byteLength > 0) {
                this._sink.write(buffer);
                this._position += buffer.byteLength;
            }
        }
        return this;
    }
    _writeSchema(schema) {
        return this._writeMessage(message_js_2.Message.from(schema));
    }
    // @ts-ignore
    _writeFooter(schema) {
        // eos bytes
        return this._writeLegacyIpcFormat
            ? this._write(Int32Array.of(0))
            : this._write(Int32Array.of(-1, 0));
    }
    _writeMagic() {
        return this._write(message_js_1.MAGIC);
    }
    _writePadding(nBytes) {
        return nBytes > 0 ? this._write(new Uint8Array(nBytes)) : this;
    }
    _writeRecordBatch(batch) {
        const { byteLength, nodes, bufferRegions, buffers } = vectorassembler_js_1.VectorAssembler.assemble(batch);
        const recordBatch = new metadata.RecordBatch(batch.numRows, nodes, bufferRegions);
        const message = message_js_2.Message.from(recordBatch, byteLength);
        return this
            ._writeDictionaries(batch)
            ._writeMessage(message)
            ._writeBodyBuffers(buffers);
    }
    _writeDictionaryBatch(dictionary, id, isDelta = false) {
        const { byteLength, nodes, bufferRegions, buffers } = vectorassembler_js_1.VectorAssembler.assemble(new vector_js_1.Vector([dictionary]));
        const recordBatch = new metadata.RecordBatch(dictionary.length, nodes, bufferRegions);
        const dictionaryBatch = new metadata.DictionaryBatch(recordBatch, id, isDelta);
        const message = message_js_2.Message.from(dictionaryBatch, byteLength);
        return this
            ._writeMessage(message)
            ._writeBodyBuffers(buffers);
    }
    _writeBodyBuffers(buffers) {
        let buffer;
        let size, padding;
        for (let i = -1, n = buffers.length; ++i < n;) {
            if ((buffer = buffers[i]) && (size = buffer.byteLength) > 0) {
                this._write(buffer);
                if ((padding = ((size + 7) & ~7) - size) > 0) {
                    this._writePadding(padding);
                }
            }
        }
        return this;
    }
    _writeDictionaries(batch) {
        var _a, _b;
        for (const [id, dictionary] of batch.dictionaries) {
            const chunks = (_a = dictionary === null || dictionary === void 0 ? void 0 : dictionary.data) !== null && _a !== void 0 ? _a : [];
            const prevDictionary = this._seenDictionaries.get(id);
            const offset = (_b = this._dictionaryDeltaOffsets.get(id)) !== null && _b !== void 0 ? _b : 0;
            // * If no previous dictionary was written, write an initial DictionaryMessage.
            // * If the current dictionary does not share chunks with the previous dictionary, write a replacement DictionaryMessage.
            if (!prevDictionary || prevDictionary.data[0] !== chunks[0]) {
                // * If `index > 0`, then `isDelta` is true.
                // * If `index = 0`, then `isDelta` is false, because this is either the initial or a replacement DictionaryMessage.
                for (const [index, chunk] of chunks.entries())
                    this._writeDictionaryBatch(chunk, id, index > 0);
            }
            else if (offset < chunks.length) {
                for (const chunk of chunks.slice(offset))
                    this._writeDictionaryBatch(chunk, id, true);
            }
            this._seenDictionaries.set(id, dictionary);
            this._dictionaryDeltaOffsets.set(id, chunks.length);
        }
        return this;
    }
}
exports.RecordBatchWriter = RecordBatchWriter;
/** @ignore */
class RecordBatchStreamWriter extends RecordBatchWriter {
    /** @nocollapse */
    static writeAll(input, options) {
        const writer = new RecordBatchStreamWriter(options);
        if ((0, compat_js_1.isPromise)(input)) {
            return input.then((x) => writer.writeAll(x));
        }
        else if ((0, compat_js_1.isAsyncIterable)(input)) {
            return writeAllAsync(writer, input);
        }
        return writeAll(writer, input);
    }
}
exports.RecordBatchStreamWriter = RecordBatchStreamWriter;
/** @ignore */
class RecordBatchFileWriter extends RecordBatchWriter {
    /** @nocollapse */
    static writeAll(input) {
        const writer = new RecordBatchFileWriter();
        if ((0, compat_js_1.isPromise)(input)) {
            return input.then((x) => writer.writeAll(x));
        }
        else if ((0, compat_js_1.isAsyncIterable)(input)) {
            return writeAllAsync(writer, input);
        }
        return writeAll(writer, input);
    }
    constructor() {
        super();
        this._autoDestroy = true;
    }
    // @ts-ignore
    _writeSchema(schema) {
        return this._writeMagic()._writePadding(2);
    }
    _writeDictionaryBatch(dictionary, id, isDelta = false) {
        if (!isDelta && this._seenDictionaries.has(id)) {
            throw new Error('The Arrow File format does not support replacement dictionaries. ');
        }
        return super._writeDictionaryBatch(dictionary, id, isDelta);
    }
    _writeFooter(schema) {
        const buffer = file_js_1.Footer.encode(new file_js_1.Footer(schema, enum_js_1.MetadataVersion.V5, this._recordBatchBlocks, this._dictionaryBlocks));
        return super
            ._writeFooter(schema) // EOS bytes for sequential readers
            ._write(buffer) // Write the flatbuffer
            ._write(Int32Array.of(buffer.byteLength)) // then the footer size suffix
            ._writeMagic(); // then the magic suffix
    }
}
exports.RecordBatchFileWriter = RecordBatchFileWriter;
/** @ignore */
class RecordBatchJSONWriter extends RecordBatchWriter {
    /** @nocollapse */
    static writeAll(input) {
        return new RecordBatchJSONWriter().writeAll(input);
    }
    constructor() {
        super();
        this._autoDestroy = true;
        this._recordBatches = [];
        this._recordBatchesWithDictionaries = [];
    }
    _writeMessage() { return this; }
    // @ts-ignore
    _writeFooter(schema) { return this; }
    _writeSchema(schema) {
        return this._write(`{\n  "schema": ${JSON.stringify({ fields: schema.fields.map(field => fieldToJSON(field)) }, null, 2)}`);
    }
    _writeDictionaries(batch) {
        if (batch.dictionaries.size > 0) {
            this._recordBatchesWithDictionaries.push(batch);
        }
        return this;
    }
    _writeDictionaryBatch(dictionary, id, isDelta = false) {
        this._write(this._dictionaryBlocks.length === 0 ? `    ` : `,\n    `);
        this._write(dictionaryBatchToJSON(dictionary, id, isDelta));
        this._dictionaryBlocks.push(new file_js_1.FileBlock(0, 0, 0));
        return this;
    }
    _writeRecordBatch(batch) {
        this._writeDictionaries(batch);
        this._recordBatches.push(batch);
        return this;
    }
    close() {
        if (this._recordBatchesWithDictionaries.length > 0) {
            this._write(`,\n  "dictionaries": [\n`);
            for (const batch of this._recordBatchesWithDictionaries) {
                super._writeDictionaries(batch);
            }
            this._write(`\n  ]`);
        }
        if (this._recordBatches.length > 0) {
            for (let i = -1, n = this._recordBatches.length; ++i < n;) {
                this._write(i === 0 ? `,\n  "batches": [\n    ` : `,\n    `);
                this._write(recordBatchToJSON(this._recordBatches[i]));
                this._recordBatchBlocks.push(new file_js_1.FileBlock(0, 0, 0));
            }
            this._write(`\n  ]`);
        }
        if (this._schema) {
            this._write(`\n}`);
        }
        this._recordBatchesWithDictionaries = [];
        this._recordBatches = [];
        return super.close();
    }
}
exports.RecordBatchJSONWriter = RecordBatchJSONWriter;
/** @ignore */
function writeAll(writer, input) {
    let chunks = input;
    if (input instanceof table_js_1.Table) {
        chunks = input.batches;
        writer.reset(undefined, input.schema);
    }
    for (const batch of chunks) {
        writer.write(batch);
    }
    return writer.finish();
}
/** @ignore */
function writeAllAsync(writer, batches) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        var _a, batches_1, batches_1_1;
        var _b, e_1, _c, _d;
        try {
            for (_a = true, batches_1 = tslib_1.__asyncValues(batches); batches_1_1 = yield batches_1.next(), _b = batches_1_1.done, !_b; _a = true) {
                _d = batches_1_1.value;
                _a = false;
                const batch = _d;
                writer.write(batch);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (!_a && !_b && (_c = batches_1.return)) yield _c.call(batches_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return writer.finish();
    });
}
/** @ignore */
function fieldToJSON({ name, type, nullable }) {
    const assembler = new jsontypeassembler_js_1.JSONTypeAssembler();
    return {
        'name': name, 'nullable': nullable,
        'type': assembler.visit(type),
        'children': (type.children || []).map((field) => fieldToJSON(field)),
        'dictionary': !type_js_1.DataType.isDictionary(type) ? undefined : {
            'id': type.id,
            'isOrdered': type.isOrdered,
            'indexType': assembler.visit(type.indices)
        }
    };
}
/** @ignore */
function dictionaryBatchToJSON(dictionary, id, isDelta = false) {
    const [columns] = jsonvectorassembler_js_1.JSONVectorAssembler.assemble(new recordbatch_js_1.RecordBatch({ [id]: dictionary }));
    return JSON.stringify({
        'id': id,
        'isDelta': isDelta,
        'data': {
            'count': dictionary.length,
            'columns': columns
        }
    }, null, 2);
}
/** @ignore */
function recordBatchToJSON(records) {
    const [columns] = jsonvectorassembler_js_1.JSONVectorAssembler.assemble(records);
    return JSON.stringify({
        'count': records.numRows,
        'columns': columns
    }, null, 2);
}

//# sourceMappingURL=writer.js.map


/***/ }),
/* 167 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VectorAssembler = void 0;
const vector_js_1 = __webpack_require__(47);
const visitor_js_1 = __webpack_require__(112);
const enum_js_1 = __webpack_require__(48);
const recordbatch_js_1 = __webpack_require__(134);
const buffer_js_1 = __webpack_require__(43);
const bit_js_1 = __webpack_require__(118);
const message_js_1 = __webpack_require__(162);
const type_js_1 = __webpack_require__(113);
const bigint_js_1 = __webpack_require__(111);
/** @ignore */
class VectorAssembler extends visitor_js_1.Visitor {
    /** @nocollapse */
    static assemble(...args) {
        const unwrap = (nodes) => nodes.flatMap((node) => Array.isArray(node) ? unwrap(node) :
            (node instanceof recordbatch_js_1.RecordBatch) ? node.data.children : node.data);
        const assembler = new VectorAssembler();
        assembler.visitMany(unwrap(args));
        return assembler;
    }
    constructor() {
        super();
        this._byteLength = 0;
        this._nodes = [];
        this._buffers = [];
        this._bufferRegions = [];
    }
    visit(data) {
        if (data instanceof vector_js_1.Vector) {
            this.visitMany(data.data);
            return this;
        }
        const { type } = data;
        if (!type_js_1.DataType.isDictionary(type)) {
            const { length } = data;
            if (length > 2147483647) {
                /* istanbul ignore next */
                throw new RangeError('Cannot write arrays larger than 2^31 - 1 in length');
            }
            if (type_js_1.DataType.isUnion(type)) {
                this.nodes.push(new message_js_1.FieldNode(length, 0));
            }
            else {
                const { nullCount } = data;
                if (!type_js_1.DataType.isNull(type)) {
                    addBuffer.call(this, nullCount <= 0
                        ? new Uint8Array(0) // placeholder validity buffer
                        : (0, bit_js_1.truncateBitmap)(data.offset, length, data.nullBitmap));
                }
                this.nodes.push(new message_js_1.FieldNode(length, nullCount));
            }
        }
        return super.visit(data);
    }
    visitNull(_null) {
        return this;
    }
    visitDictionary(data) {
        // Assemble the indices here, Dictionary assembled separately.
        return this.visit(data.clone(data.type.indices));
    }
    get nodes() { return this._nodes; }
    get buffers() { return this._buffers; }
    get byteLength() { return this._byteLength; }
    get bufferRegions() { return this._bufferRegions; }
}
exports.VectorAssembler = VectorAssembler;
/** @ignore */
function addBuffer(values) {
    const byteLength = (values.byteLength + 7) & ~7; // Round up to a multiple of 8
    this.buffers.push(values);
    this.bufferRegions.push(new message_js_1.BufferRegion(this._byteLength, byteLength));
    this._byteLength += byteLength;
    return this;
}
/** @ignore */
function assembleUnion(data) {
    var _a;
    const { type, length, typeIds, valueOffsets } = data;
    // All Union Vectors have a typeIds buffer
    addBuffer.call(this, typeIds);
    // If this is a Sparse Union, treat it like all other Nested types
    if (type.mode === enum_js_1.UnionMode.Sparse) {
        return assembleNestedVector.call(this, data);
    }
    else if (type.mode === enum_js_1.UnionMode.Dense) {
        // If this is a Dense Union, add the valueOffsets buffer and potentially slice the children
        if (data.offset <= 0) {
            // If the Vector hasn't been sliced, write the existing valueOffsets
            addBuffer.call(this, valueOffsets);
            // We can treat this like all other Nested types
            return assembleNestedVector.call(this, data);
        }
        else {
            // A sliced Dense Union is an unpleasant case. Because the offsets are different for
            // each child vector, we need to "rebase" the valueOffsets for each child
            // Union typeIds are not necessary 0-indexed
            const shiftedOffsets = new Int32Array(length);
            const childOffsets = Object.create(null);
            const childLengths = Object.create(null);
            // If we have a non-zero offset, then the value offsets do not start at
            // zero. We must a) create a new offsets array with shifted offsets and
            // b) slice the values array accordingly
            for (let typeId, shift, index = -1; ++index < length;) {
                if ((typeId = typeIds[index]) === undefined) {
                    continue;
                }
                if ((shift = childOffsets[typeId]) === undefined) {
                    shift = childOffsets[typeId] = valueOffsets[index];
                }
                shiftedOffsets[index] = valueOffsets[index] - shift;
                childLengths[typeId] = ((_a = childLengths[typeId]) !== null && _a !== void 0 ? _a : 0) + 1;
            }
            addBuffer.call(this, shiftedOffsets);
            // Slice and visit children accordingly
            this.visitMany(data.children.map((child, childIndex) => {
                const typeId = type.typeIds[childIndex];
                const childOffset = childOffsets[typeId];
                const childLength = childLengths[typeId];
                return child.slice(childOffset, Math.min(length, childLength));
            }));
        }
    }
    return this;
}
/** @ignore */
function assembleBoolVector(data) {
    // Bool vector is a special case of FlatVector, as its data buffer needs to stay packed
    let values;
    if (data.nullCount >= data.length) {
        // If all values are null, just insert a placeholder empty data buffer (fastest path)
        return addBuffer.call(this, new Uint8Array(0));
    }
    else if ((values = data.values) instanceof Uint8Array) {
        // If values is already a Uint8Array, slice the bitmap (fast path)
        return addBuffer.call(this, (0, bit_js_1.truncateBitmap)(data.offset, data.length, values));
    }
    // Otherwise if the underlying data *isn't* a Uint8Array, enumerate the
    // values as bools and re-pack them into a Uint8Array. This code isn't
    // reachable unless you're trying to manipulate the Data internals,
    // we're only doing this for safety.
    /* istanbul ignore next */
    return addBuffer.call(this, (0, bit_js_1.packBools)(data.values));
}
/** @ignore */
function assembleFlatVector(data) {
    return addBuffer.call(this, data.values.subarray(0, data.length * data.stride));
}
/** @ignore */
function assembleFlatListVector(data) {
    const { length, values, valueOffsets } = data;
    const begin = (0, bigint_js_1.bigIntToNumber)(valueOffsets[0]);
    const end = (0, bigint_js_1.bigIntToNumber)(valueOffsets[length]);
    const byteLength = Math.min(end - begin, values.byteLength - begin);
    // Push in the order FlatList types read their buffers
    addBuffer.call(this, (0, buffer_js_1.rebaseValueOffsets)(-begin, length + 1, valueOffsets)); // valueOffsets buffer first
    addBuffer.call(this, values.subarray(begin, begin + byteLength)); // sliced values buffer second
    return this;
}
/** @ignore */
function assembleListVector(data) {
    const { length, valueOffsets } = data;
    // If we have valueOffsets (MapVector, ListVector), push that buffer first
    if (valueOffsets) {
        const { [0]: begin, [length]: end } = valueOffsets;
        addBuffer.call(this, (0, buffer_js_1.rebaseValueOffsets)(-begin, length + 1, valueOffsets));
        // Then insert the List's values child
        return this.visit(data.children[0].slice(begin, end - begin));
    }
    // Then insert the List's values child
    return this.visit(data.children[0]);
}
/** @ignore */
function assembleNestedVector(data) {
    return this.visitMany(data.type.children.map((_, i) => data.children[i]).filter(Boolean))[0];
}
VectorAssembler.prototype.visitBool = assembleBoolVector;
VectorAssembler.prototype.visitInt = assembleFlatVector;
VectorAssembler.prototype.visitFloat = assembleFlatVector;
VectorAssembler.prototype.visitUtf8 = assembleFlatListVector;
VectorAssembler.prototype.visitLargeUtf8 = assembleFlatListVector;
VectorAssembler.prototype.visitBinary = assembleFlatListVector;
VectorAssembler.prototype.visitLargeBinary = assembleFlatListVector;
VectorAssembler.prototype.visitFixedSizeBinary = assembleFlatVector;
VectorAssembler.prototype.visitDate = assembleFlatVector;
VectorAssembler.prototype.visitTimestamp = assembleFlatVector;
VectorAssembler.prototype.visitTime = assembleFlatVector;
VectorAssembler.prototype.visitDecimal = assembleFlatVector;
VectorAssembler.prototype.visitList = assembleListVector;
VectorAssembler.prototype.visitStruct = assembleNestedVector;
VectorAssembler.prototype.visitUnion = assembleUnion;
VectorAssembler.prototype.visitInterval = assembleFlatVector;
VectorAssembler.prototype.visitDuration = assembleFlatVector;
VectorAssembler.prototype.visitFixedSizeList = assembleListVector;
VectorAssembler.prototype.visitMap = assembleListVector;

//# sourceMappingURL=vectorassembler.js.map


/***/ }),
/* 168 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JSONTypeAssembler = void 0;
const visitor_js_1 = __webpack_require__(112);
const type_js_1 = __webpack_require__(76);
const enum_js_1 = __webpack_require__(48);
/** @ignore */
class JSONTypeAssembler extends visitor_js_1.Visitor {
    visit(node) {
        return node == null ? undefined : super.visit(node);
    }
    visitNull({ typeId }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase() };
    }
    visitInt({ typeId, bitWidth, isSigned }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase(), 'bitWidth': bitWidth, 'isSigned': isSigned };
    }
    visitFloat({ typeId, precision }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase(), 'precision': enum_js_1.Precision[precision] };
    }
    visitBinary({ typeId }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase() };
    }
    visitLargeBinary({ typeId }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase() };
    }
    visitBool({ typeId }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase() };
    }
    visitUtf8({ typeId }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase() };
    }
    visitLargeUtf8({ typeId }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase() };
    }
    visitDecimal({ typeId, scale, precision, bitWidth }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase(), 'scale': scale, 'precision': precision, 'bitWidth': bitWidth };
    }
    visitDate({ typeId, unit }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase(), 'unit': enum_js_1.DateUnit[unit] };
    }
    visitTime({ typeId, unit, bitWidth }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase(), 'unit': enum_js_1.TimeUnit[unit], bitWidth };
    }
    visitTimestamp({ typeId, timezone, unit }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase(), 'unit': enum_js_1.TimeUnit[unit], timezone };
    }
    visitInterval({ typeId, unit }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase(), 'unit': enum_js_1.IntervalUnit[unit] };
    }
    visitDuration({ typeId, unit }) {
        return { 'name': type_js_1.Type[typeId].toLocaleLowerCase(), 'unit': enum_js_1.TimeUnit[unit] };
    }
    visitList({ typeId }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase() };
    }
    visitStruct({ typeId }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase() };
    }
    visitUnion({ typeId, mode, typeIds }) {
        return {
            'name': type_js_1.Type[typeId].toLowerCase(),
            'mode': enum_js_1.UnionMode[mode].toUpperCase(),
            'typeIds': [...typeIds]
        };
    }
    visitDictionary(node) {
        return this.visit(node.dictionary);
    }
    visitFixedSizeBinary({ typeId, byteWidth }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase(), 'byteWidth': byteWidth };
    }
    visitFixedSizeList({ typeId, listSize }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase(), 'listSize': listSize };
    }
    visitMap({ typeId, keysSorted }) {
        return { 'name': type_js_1.Type[typeId].toLowerCase(), 'keysSorted': keysSorted };
    }
}
exports.JSONTypeAssembler = JSONTypeAssembler;

//# sourceMappingURL=jsontypeassembler.js.map


/***/ }),
/* 169 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JSONVectorAssembler = void 0;
const bn_js_1 = __webpack_require__(110);
const vector_js_1 = __webpack_require__(47);
const visitor_js_1 = __webpack_require__(112);
const enum_js_1 = __webpack_require__(48);
const enum_js_2 = __webpack_require__(48);
const bit_js_1 = __webpack_require__(118);
const type_js_1 = __webpack_require__(113);
/** @ignore */
class JSONVectorAssembler extends visitor_js_1.Visitor {
    /** @nocollapse */
    static assemble(...batches) {
        const assembler = new JSONVectorAssembler();
        return batches.map(({ schema, data }) => {
            return assembler.visitMany(schema.fields, data.children);
        });
    }
    visit({ name }, data) {
        const { length } = data;
        const { offset, nullCount, nullBitmap } = data;
        const type = type_js_1.DataType.isDictionary(data.type) ? data.type.indices : data.type;
        const buffers = Object.assign([], data.buffers, { [enum_js_1.BufferType.VALIDITY]: undefined });
        return Object.assign({ 'name': name, 'count': length, 'VALIDITY': (type_js_1.DataType.isNull(type) || type_js_1.DataType.isUnion(type))
                ? undefined
                : nullCount <= 0 ? Array.from({ length }, () => 1)
                    : [...new bit_js_1.BitIterator(nullBitmap, offset, length, null, bit_js_1.getBit)] }, super.visit(data.clone(type, offset, length, 0, buffers)));
    }
    visitNull() { return {}; }
    visitBool({ values, offset, length }) {
        return { 'DATA': [...new bit_js_1.BitIterator(values, offset, length, null, bit_js_1.getBool)] };
    }
    visitInt(data) {
        return {
            'DATA': data.type.bitWidth < 64
                ? [...data.values]
                : [...bigNumsToStrings(data.values, 2)]
        };
    }
    visitFloat(data) {
        return { 'DATA': [...data.values] };
    }
    visitUtf8(data) {
        return { 'DATA': [...new vector_js_1.Vector([data])], 'OFFSET': [...data.valueOffsets] };
    }
    visitLargeUtf8(data) {
        return { 'DATA': [...new vector_js_1.Vector([data])], 'OFFSET': [...bigNumsToStrings(data.valueOffsets, 2)] };
    }
    visitBinary(data) {
        return { 'DATA': [...binaryToString(new vector_js_1.Vector([data]))], 'OFFSET': [...data.valueOffsets] };
    }
    visitLargeBinary(data) {
        return { 'DATA': [...binaryToString(new vector_js_1.Vector([data]))], 'OFFSET': [...bigNumsToStrings(data.valueOffsets, 2)] };
    }
    visitFixedSizeBinary(data) {
        return { 'DATA': [...binaryToString(new vector_js_1.Vector([data]))] };
    }
    visitDate(data) {
        return {
            'DATA': data.type.unit === enum_js_2.DateUnit.DAY
                ? [...data.values]
                : [...bigNumsToStrings(data.values, 2)]
        };
    }
    visitTimestamp(data) {
        return { 'DATA': [...bigNumsToStrings(data.values, 2)] };
    }
    visitTime(data) {
        return {
            'DATA': data.type.unit < enum_js_2.TimeUnit.MICROSECOND
                ? [...data.values]
                : [...bigNumsToStrings(data.values, 2)]
        };
    }
    visitDecimal(data) {
        return { 'DATA': [...bigNumsToStrings(data.values, 4)] };
    }
    visitList(data) {
        return {
            'OFFSET': [...data.valueOffsets],
            'children': this.visitMany(data.type.children, data.children)
        };
    }
    visitStruct(data) {
        return {
            'children': this.visitMany(data.type.children, data.children)
        };
    }
    visitUnion(data) {
        return {
            'TYPE_ID': [...data.typeIds],
            'OFFSET': data.type.mode === enum_js_2.UnionMode.Dense ? [...data.valueOffsets] : undefined,
            'children': this.visitMany(data.type.children, data.children)
        };
    }
    visitInterval(data) {
        return { 'DATA': [...data.values] };
    }
    visitDuration(data) {
        return { 'DATA': [...bigNumsToStrings(data.values, 2)] };
    }
    visitFixedSizeList(data) {
        return {
            'children': this.visitMany(data.type.children, data.children)
        };
    }
    visitMap(data) {
        return {
            'OFFSET': [...data.valueOffsets],
            'children': this.visitMany(data.type.children, data.children)
        };
    }
}
exports.JSONVectorAssembler = JSONVectorAssembler;
/** @ignore */
function* binaryToString(vector) {
    for (const octets of vector) {
        yield octets.reduce((str, byte) => {
            return `${str}${('0' + (byte & 0xFF).toString(16)).slice(-2)}`;
        }, '').toUpperCase();
    }
}
/** @ignore */
function* bigNumsToStrings(values, stride) {
    const u32s = new Uint32Array(values.buffer);
    for (let i = -1, n = u32s.length / stride; ++i < n;) {
        yield `${bn_js_1.BN.new(u32s.subarray((i + 0) * stride, (i + 1) * stride), false)}`;
    }
}

//# sourceMappingURL=jsonvectorassembler.js.map


/***/ }),
/* 170 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toNodeStream = void 0;
const tslib_1 = __webpack_require__(41);
const node_stream_1 = __webpack_require__(171);
const compat_js_1 = __webpack_require__(45);
/** @ignore */
function toNodeStream(source, options) {
    if ((0, compat_js_1.isAsyncIterable)(source)) {
        return new AsyncIterableReadable(source[Symbol.asyncIterator](), options);
    }
    if ((0, compat_js_1.isIterable)(source)) {
        return new IterableReadable(source[Symbol.iterator](), options);
    }
    /* istanbul ignore next */
    throw new Error(`toNodeStream() must be called with an Iterable or AsyncIterable`);
}
exports.toNodeStream = toNodeStream;
/** @ignore */
class IterableReadable extends node_stream_1.Readable {
    constructor(it, options) {
        super(options);
        this._iterator = it;
        this._pulling = false;
        this._bytesMode = !options || !options.objectMode;
    }
    _read(size) {
        const it = this._iterator;
        if (it && !this._pulling && (this._pulling = true)) {
            this._pulling = this._pull(size, it);
        }
    }
    _destroy(e, cb) {
        const it = this._iterator;
        let fn;
        it && (fn = e != null && it.throw || it.return);
        fn === null || fn === void 0 ? void 0 : fn.call(it, e);
        cb && cb(null);
    }
    _pull(size, it) {
        const bm = this._bytesMode;
        let r = null;
        while (this.readable && !(r = it.next(bm ? size : null)).done) {
            if (size != null) {
                size -= (bm && ArrayBuffer.isView(r.value) ? r.value.byteLength : 1);
            }
            if (!this.push(r.value) || size <= 0) {
                break;
            }
        }
        if (((r === null || r === void 0 ? void 0 : r.done) || !this.readable) && (this.push(null) || true)) {
            it.return && it.return();
        }
        return !this.readable;
    }
}
/** @ignore */
class AsyncIterableReadable extends node_stream_1.Readable {
    constructor(it, options) {
        super(options);
        this._iterator = it;
        this._pulling = false;
        this._bytesMode = !options || !options.objectMode;
    }
    _read(size) {
        const it = this._iterator;
        if (it && !this._pulling && (this._pulling = true)) {
            (() => tslib_1.__awaiter(this, void 0, void 0, function* () { return this._pulling = yield this._pull(size, it); }))();
        }
    }
    _destroy(e, cb) {
        const it = this._iterator;
        let fn;
        it && (fn = e != null && it.throw || it.return);
        (fn === null || fn === void 0 ? void 0 : fn.call(it, e).then(() => cb && cb(null))) || (cb && cb(null));
    }
    _pull(size, it) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const bm = this._bytesMode;
            let r = null;
            while (this.readable && !(r = yield it.next(bm ? size : null)).done) {
                if (size != null) {
                    size -= (bm && ArrayBuffer.isView(r.value) ? r.value.byteLength : 1);
                }
                if (!this.push(r.value) || size <= 0) {
                    break;
                }
            }
            if (((r === null || r === void 0 ? void 0 : r.done) || !this.readable) && (this.push(null) || true)) {
                it.return && it.return();
            }
            return !this.readable;
        });
    }
}

//# sourceMappingURL=iterable.js.map


/***/ }),
/* 171 */
/***/ ((module) => {

"use strict";
module.exports = require("node:stream");

/***/ }),
/* 172 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.builderThroughNodeStream = void 0;
const node_stream_1 = __webpack_require__(171);
const factories_js_1 = __webpack_require__(136);
/** @ignore */
function builderThroughNodeStream(options) {
    return new BuilderDuplex((0, factories_js_1.makeBuilder)(options), options);
}
exports.builderThroughNodeStream = builderThroughNodeStream;
/** @ignore */
class BuilderDuplex extends node_stream_1.Duplex {
    constructor(builder, options) {
        const { queueingStrategy = 'count', autoDestroy = true } = options;
        const { highWaterMark = queueingStrategy !== 'bytes' ? 1000 : Math.pow(2, 14) } = options;
        super({ autoDestroy, highWaterMark: 1, allowHalfOpen: true, writableObjectMode: true, readableObjectMode: true });
        this._numChunks = 0;
        this._finished = false;
        this._builder = builder;
        this._desiredSize = highWaterMark;
        this._getSize = queueingStrategy !== 'bytes' ? builderLength : builderByteLength;
    }
    _read(size) {
        this._maybeFlush(this._builder, this._desiredSize = size);
    }
    _final(cb) {
        this._maybeFlush(this._builder.finish(), this._desiredSize);
        cb && cb();
    }
    _write(value, _, cb) {
        const result = this._maybeFlush(this._builder.append(value), this._desiredSize);
        cb && cb();
        return result;
    }
    _destroy(err, cb) {
        this._builder.clear();
        cb && cb(err);
    }
    _maybeFlush(builder, size) {
        if (this._getSize(builder) >= size) {
            ++this._numChunks && this.push(builder.toVector());
        }
        if (builder.finished) {
            if (builder.length > 0 || this._numChunks === 0) {
                ++this._numChunks && this.push(builder.toVector());
            }
            if (!this._finished && (this._finished = true)) {
                this.push(null);
            }
            return false;
        }
        return this._getSize(builder) < this.writableHighWaterMark;
    }
}
/** @ignore */ const builderLength = (builder) => builder.length;
/** @ignore */ const builderByteLength = (builder) => builder.byteLength;

//# sourceMappingURL=builder.js.map


/***/ }),
/* 173 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.recordBatchReaderThroughNodeStream = void 0;
const tslib_1 = __webpack_require__(41);
const node_stream_1 = __webpack_require__(171);
const stream_js_1 = __webpack_require__(129);
const reader_js_1 = __webpack_require__(124);
/** @ignore */
function recordBatchReaderThroughNodeStream(options) {
    return new RecordBatchReaderDuplex(options);
}
exports.recordBatchReaderThroughNodeStream = recordBatchReaderThroughNodeStream;
/** @ignore */
class RecordBatchReaderDuplex extends node_stream_1.Duplex {
    constructor(options) {
        super(Object.assign(Object.assign({ allowHalfOpen: false }, options), { readableObjectMode: true, writableObjectMode: false }));
        this._pulling = false;
        this._autoDestroy = true;
        this._reader = null;
        this._pulling = false;
        this._asyncQueue = new stream_js_1.AsyncByteQueue();
        this._autoDestroy = options && (typeof options.autoDestroy === 'boolean') ? options.autoDestroy : true;
    }
    _final(cb) {
        const aq = this._asyncQueue;
        aq === null || aq === void 0 ? void 0 : aq.close();
        cb && cb();
    }
    _write(x, _, cb) {
        const aq = this._asyncQueue;
        aq === null || aq === void 0 ? void 0 : aq.write(x);
        cb && cb();
        return true;
    }
    _read(size) {
        const aq = this._asyncQueue;
        if (aq && !this._pulling && (this._pulling = true)) {
            (() => tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (!this._reader) {
                    this._reader = yield this._open(aq);
                }
                this._pulling = yield this._pull(size, this._reader);
            }))();
        }
    }
    _destroy(err, cb) {
        const aq = this._asyncQueue;
        if (aq) {
            err ? aq.abort(err) : aq.close();
        }
        cb(this._asyncQueue = this._reader = null);
    }
    _open(source) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield (yield reader_js_1.RecordBatchReader.from(source)).open({ autoDestroy: this._autoDestroy });
        });
    }
    _pull(size, reader) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let r = null;
            while (this.readable && !(r = yield reader.next()).done) {
                if (!this.push(r.value) || (size != null && --size <= 0)) {
                    break;
                }
            }
            if (!this.readable || ((r === null || r === void 0 ? void 0 : r.done) && (reader.autoDestroy || (yield reader.reset().open()).closed))) {
                this.push(null);
                yield reader.cancel();
            }
            return !this.readable;
        });
    }
}

//# sourceMappingURL=reader.js.map


/***/ }),
/* 174 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.recordBatchWriterThroughNodeStream = void 0;
const tslib_1 = __webpack_require__(41);
const node_stream_1 = __webpack_require__(171);
const stream_js_1 = __webpack_require__(129);
/** @ignore */
function recordBatchWriterThroughNodeStream(options) {
    return new RecordBatchWriterDuplex(new this(options));
}
exports.recordBatchWriterThroughNodeStream = recordBatchWriterThroughNodeStream;
/** @ignore */
class RecordBatchWriterDuplex extends node_stream_1.Duplex {
    constructor(writer, options) {
        super(Object.assign(Object.assign({ allowHalfOpen: false }, options), { writableObjectMode: true, readableObjectMode: false }));
        this._pulling = false;
        this._writer = writer;
        this._reader = new stream_js_1.AsyncByteStream(writer);
    }
    _final(cb) {
        const writer = this._writer;
        writer === null || writer === void 0 ? void 0 : writer.close();
        cb && cb();
    }
    _write(x, _, cb) {
        const writer = this._writer;
        writer === null || writer === void 0 ? void 0 : writer.write(x);
        cb && cb();
        return true;
    }
    _read(size) {
        const it = this._reader;
        if (it && !this._pulling && (this._pulling = true)) {
            (() => tslib_1.__awaiter(this, void 0, void 0, function* () { return this._pulling = yield this._pull(size, it); }))();
        }
    }
    _destroy(err, cb) {
        const writer = this._writer;
        if (writer) {
            err ? writer.abort(err) : writer.close();
        }
        cb(this._reader = this._writer = null);
    }
    _pull(size, reader) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let r = null;
            while (this.readable && !(r = yield reader.next(size || null)).done) {
                if (size != null && r.value) {
                    size -= r.value.byteLength;
                }
                if (!this.push(r.value) || size <= 0) {
                    break;
                }
            }
            if (((r === null || r === void 0 ? void 0 : r.done) || !this.readable)) {
                this.push(null);
                yield reader.cancel();
            }
            return !this.readable;
        });
    }
}

//# sourceMappingURL=writer.js.map


/***/ }),
/* 175 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Union = exports.StructRow = exports.Struct = exports.List = exports.Decimal = exports.TimeNanosecond = exports.TimeMicrosecond = exports.TimeMillisecond = exports.TimeSecond = exports.Time = exports.TimestampNanosecond = exports.TimestampMicrosecond = exports.TimestampMillisecond = exports.TimestampSecond = exports.Timestamp = exports.DateMillisecond = exports.DateDay = exports.Date_ = exports.FixedSizeBinary = exports.LargeBinary = exports.Binary = exports.LargeUtf8 = exports.Utf8 = exports.Float64 = exports.Float32 = exports.Float16 = exports.Float = exports.Uint64 = exports.Uint32 = exports.Uint16 = exports.Uint8 = exports.Int64 = exports.Int32 = exports.Int16 = exports.Int8 = exports.Int = exports.Bool = exports.Null = exports.DataType = exports.makeData = exports.Data = exports.BufferType = exports.UnionMode = exports.Type = exports.TimeUnit = exports.Precision = exports.MetadataVersion = exports.MessageHeader = exports.IntervalUnit = exports.DateUnit = void 0;
exports.LargeBinaryBuilder = exports.BinaryBuilder = exports.builderThroughAsyncIterable = exports.builderThroughIterable = exports.makeBuilder = exports.Builder = exports.util = exports.RecordBatch = exports.Message = exports.JSONMessageReader = exports.AsyncMessageReader = exports.MessageReader = exports.tableToIPC = exports.tableFromIPC = exports.RecordBatchJSONWriter = exports.RecordBatchStreamWriter = exports.RecordBatchFileWriter = exports.RecordBatchWriter = exports.AsyncRecordBatchStreamReader = exports.AsyncRecordBatchFileReader = exports.RecordBatchStreamReader = exports.RecordBatchFileReader = exports.RecordBatchReader = exports.AsyncByteQueue = exports.AsyncByteStream = exports.ByteStream = exports.tableFromJSON = exports.vectorFromArray = exports.makeVector = exports.Vector = exports.Visitor = exports.Field = exports.Schema = exports.tableFromArrays = exports.makeTable = exports.Table = exports.MapRow = exports.Map_ = exports.FixedSizeList = exports.DurationNanosecond = exports.DurationMicrosecond = exports.DurationMillisecond = exports.DurationSecond = exports.Duration = exports.IntervalYearMonth = exports.IntervalDayTime = exports.Interval = exports.Dictionary = exports.SparseUnion = exports.DenseUnion = void 0;
exports.LargeUtf8Builder = exports.Utf8Builder = exports.SparseUnionBuilder = exports.DenseUnionBuilder = exports.UnionBuilder = exports.TimeNanosecondBuilder = exports.TimeMicrosecondBuilder = exports.TimeMillisecondBuilder = exports.TimeSecondBuilder = exports.TimeBuilder = exports.TimestampNanosecondBuilder = exports.TimestampMicrosecondBuilder = exports.TimestampMillisecondBuilder = exports.TimestampSecondBuilder = exports.TimestampBuilder = exports.StructBuilder = exports.NullBuilder = exports.MapBuilder = exports.ListBuilder = exports.Uint64Builder = exports.Uint32Builder = exports.Uint16Builder = exports.Uint8Builder = exports.Int64Builder = exports.Int32Builder = exports.Int16Builder = exports.Int8Builder = exports.IntBuilder = exports.DurationNanosecondBuilder = exports.DurationMicrosecondBuilder = exports.DurationMillisecondBuilder = exports.DurationSecondBuilder = exports.DurationBuilder = exports.IntervalYearMonthBuilder = exports.IntervalDayTimeBuilder = exports.IntervalBuilder = exports.Float64Builder = exports.Float32Builder = exports.Float16Builder = exports.FloatBuilder = exports.FixedSizeListBuilder = exports.FixedSizeBinaryBuilder = exports.DictionaryBuilder = exports.DecimalBuilder = exports.DateMillisecondBuilder = exports.DateDayBuilder = exports.DateBuilder = exports.BoolBuilder = void 0;
const adapters_js_1 = __webpack_require__(42);
const builder_js_1 = __webpack_require__(46);
const reader_js_1 = __webpack_require__(124);
const writer_js_1 = __webpack_require__(166);
const iterable_js_1 = __webpack_require__(176);
const builder_js_2 = __webpack_require__(177);
const reader_js_2 = __webpack_require__(178);
const writer_js_2 = __webpack_require__(179);
adapters_js_1.default.toDOMStream = iterable_js_1.toDOMStream;
builder_js_1.Builder['throughDOM'] = builder_js_2.builderThroughDOMStream;
reader_js_1.RecordBatchReader['throughDOM'] = reader_js_2.recordBatchReaderThroughDOMStream;
reader_js_1.RecordBatchFileReader['throughDOM'] = reader_js_2.recordBatchReaderThroughDOMStream;
reader_js_1.RecordBatchStreamReader['throughDOM'] = reader_js_2.recordBatchReaderThroughDOMStream;
writer_js_1.RecordBatchWriter['throughDOM'] = writer_js_2.recordBatchWriterThroughDOMStream;
writer_js_1.RecordBatchFileWriter['throughDOM'] = writer_js_2.recordBatchWriterThroughDOMStream;
writer_js_1.RecordBatchStreamWriter['throughDOM'] = writer_js_2.recordBatchWriterThroughDOMStream;
var Arrow_js_1 = __webpack_require__(180);
Object.defineProperty(exports, "DateUnit", ({ enumerable: true, get: function () { return Arrow_js_1.DateUnit; } }));
Object.defineProperty(exports, "IntervalUnit", ({ enumerable: true, get: function () { return Arrow_js_1.IntervalUnit; } }));
Object.defineProperty(exports, "MessageHeader", ({ enumerable: true, get: function () { return Arrow_js_1.MessageHeader; } }));
Object.defineProperty(exports, "MetadataVersion", ({ enumerable: true, get: function () { return Arrow_js_1.MetadataVersion; } }));
Object.defineProperty(exports, "Precision", ({ enumerable: true, get: function () { return Arrow_js_1.Precision; } }));
Object.defineProperty(exports, "TimeUnit", ({ enumerable: true, get: function () { return Arrow_js_1.TimeUnit; } }));
Object.defineProperty(exports, "Type", ({ enumerable: true, get: function () { return Arrow_js_1.Type; } }));
Object.defineProperty(exports, "UnionMode", ({ enumerable: true, get: function () { return Arrow_js_1.UnionMode; } }));
Object.defineProperty(exports, "BufferType", ({ enumerable: true, get: function () { return Arrow_js_1.BufferType; } }));
Object.defineProperty(exports, "Data", ({ enumerable: true, get: function () { return Arrow_js_1.Data; } }));
Object.defineProperty(exports, "makeData", ({ enumerable: true, get: function () { return Arrow_js_1.makeData; } }));
Object.defineProperty(exports, "DataType", ({ enumerable: true, get: function () { return Arrow_js_1.DataType; } }));
Object.defineProperty(exports, "Null", ({ enumerable: true, get: function () { return Arrow_js_1.Null; } }));
Object.defineProperty(exports, "Bool", ({ enumerable: true, get: function () { return Arrow_js_1.Bool; } }));
Object.defineProperty(exports, "Int", ({ enumerable: true, get: function () { return Arrow_js_1.Int; } }));
Object.defineProperty(exports, "Int8", ({ enumerable: true, get: function () { return Arrow_js_1.Int8; } }));
Object.defineProperty(exports, "Int16", ({ enumerable: true, get: function () { return Arrow_js_1.Int16; } }));
Object.defineProperty(exports, "Int32", ({ enumerable: true, get: function () { return Arrow_js_1.Int32; } }));
Object.defineProperty(exports, "Int64", ({ enumerable: true, get: function () { return Arrow_js_1.Int64; } }));
Object.defineProperty(exports, "Uint8", ({ enumerable: true, get: function () { return Arrow_js_1.Uint8; } }));
Object.defineProperty(exports, "Uint16", ({ enumerable: true, get: function () { return Arrow_js_1.Uint16; } }));
Object.defineProperty(exports, "Uint32", ({ enumerable: true, get: function () { return Arrow_js_1.Uint32; } }));
Object.defineProperty(exports, "Uint64", ({ enumerable: true, get: function () { return Arrow_js_1.Uint64; } }));
Object.defineProperty(exports, "Float", ({ enumerable: true, get: function () { return Arrow_js_1.Float; } }));
Object.defineProperty(exports, "Float16", ({ enumerable: true, get: function () { return Arrow_js_1.Float16; } }));
Object.defineProperty(exports, "Float32", ({ enumerable: true, get: function () { return Arrow_js_1.Float32; } }));
Object.defineProperty(exports, "Float64", ({ enumerable: true, get: function () { return Arrow_js_1.Float64; } }));
Object.defineProperty(exports, "Utf8", ({ enumerable: true, get: function () { return Arrow_js_1.Utf8; } }));
Object.defineProperty(exports, "LargeUtf8", ({ enumerable: true, get: function () { return Arrow_js_1.LargeUtf8; } }));
Object.defineProperty(exports, "Binary", ({ enumerable: true, get: function () { return Arrow_js_1.Binary; } }));
Object.defineProperty(exports, "LargeBinary", ({ enumerable: true, get: function () { return Arrow_js_1.LargeBinary; } }));
Object.defineProperty(exports, "FixedSizeBinary", ({ enumerable: true, get: function () { return Arrow_js_1.FixedSizeBinary; } }));
Object.defineProperty(exports, "Date_", ({ enumerable: true, get: function () { return Arrow_js_1.Date_; } }));
Object.defineProperty(exports, "DateDay", ({ enumerable: true, get: function () { return Arrow_js_1.DateDay; } }));
Object.defineProperty(exports, "DateMillisecond", ({ enumerable: true, get: function () { return Arrow_js_1.DateMillisecond; } }));
Object.defineProperty(exports, "Timestamp", ({ enumerable: true, get: function () { return Arrow_js_1.Timestamp; } }));
Object.defineProperty(exports, "TimestampSecond", ({ enumerable: true, get: function () { return Arrow_js_1.TimestampSecond; } }));
Object.defineProperty(exports, "TimestampMillisecond", ({ enumerable: true, get: function () { return Arrow_js_1.TimestampMillisecond; } }));
Object.defineProperty(exports, "TimestampMicrosecond", ({ enumerable: true, get: function () { return Arrow_js_1.TimestampMicrosecond; } }));
Object.defineProperty(exports, "TimestampNanosecond", ({ enumerable: true, get: function () { return Arrow_js_1.TimestampNanosecond; } }));
Object.defineProperty(exports, "Time", ({ enumerable: true, get: function () { return Arrow_js_1.Time; } }));
Object.defineProperty(exports, "TimeSecond", ({ enumerable: true, get: function () { return Arrow_js_1.TimeSecond; } }));
Object.defineProperty(exports, "TimeMillisecond", ({ enumerable: true, get: function () { return Arrow_js_1.TimeMillisecond; } }));
Object.defineProperty(exports, "TimeMicrosecond", ({ enumerable: true, get: function () { return Arrow_js_1.TimeMicrosecond; } }));
Object.defineProperty(exports, "TimeNanosecond", ({ enumerable: true, get: function () { return Arrow_js_1.TimeNanosecond; } }));
Object.defineProperty(exports, "Decimal", ({ enumerable: true, get: function () { return Arrow_js_1.Decimal; } }));
Object.defineProperty(exports, "List", ({ enumerable: true, get: function () { return Arrow_js_1.List; } }));
Object.defineProperty(exports, "Struct", ({ enumerable: true, get: function () { return Arrow_js_1.Struct; } }));
Object.defineProperty(exports, "StructRow", ({ enumerable: true, get: function () { return Arrow_js_1.StructRow; } }));
Object.defineProperty(exports, "Union", ({ enumerable: true, get: function () { return Arrow_js_1.Union; } }));
Object.defineProperty(exports, "DenseUnion", ({ enumerable: true, get: function () { return Arrow_js_1.DenseUnion; } }));
Object.defineProperty(exports, "SparseUnion", ({ enumerable: true, get: function () { return Arrow_js_1.SparseUnion; } }));
Object.defineProperty(exports, "Dictionary", ({ enumerable: true, get: function () { return Arrow_js_1.Dictionary; } }));
Object.defineProperty(exports, "Interval", ({ enumerable: true, get: function () { return Arrow_js_1.Interval; } }));
Object.defineProperty(exports, "IntervalDayTime", ({ enumerable: true, get: function () { return Arrow_js_1.IntervalDayTime; } }));
Object.defineProperty(exports, "IntervalYearMonth", ({ enumerable: true, get: function () { return Arrow_js_1.IntervalYearMonth; } }));
Object.defineProperty(exports, "Duration", ({ enumerable: true, get: function () { return Arrow_js_1.Duration; } }));
Object.defineProperty(exports, "DurationSecond", ({ enumerable: true, get: function () { return Arrow_js_1.DurationSecond; } }));
Object.defineProperty(exports, "DurationMillisecond", ({ enumerable: true, get: function () { return Arrow_js_1.DurationMillisecond; } }));
Object.defineProperty(exports, "DurationMicrosecond", ({ enumerable: true, get: function () { return Arrow_js_1.DurationMicrosecond; } }));
Object.defineProperty(exports, "DurationNanosecond", ({ enumerable: true, get: function () { return Arrow_js_1.DurationNanosecond; } }));
Object.defineProperty(exports, "FixedSizeList", ({ enumerable: true, get: function () { return Arrow_js_1.FixedSizeList; } }));
Object.defineProperty(exports, "Map_", ({ enumerable: true, get: function () { return Arrow_js_1.Map_; } }));
Object.defineProperty(exports, "MapRow", ({ enumerable: true, get: function () { return Arrow_js_1.MapRow; } }));
Object.defineProperty(exports, "Table", ({ enumerable: true, get: function () { return Arrow_js_1.Table; } }));
Object.defineProperty(exports, "makeTable", ({ enumerable: true, get: function () { return Arrow_js_1.makeTable; } }));
Object.defineProperty(exports, "tableFromArrays", ({ enumerable: true, get: function () { return Arrow_js_1.tableFromArrays; } }));
Object.defineProperty(exports, "Schema", ({ enumerable: true, get: function () { return Arrow_js_1.Schema; } }));
Object.defineProperty(exports, "Field", ({ enumerable: true, get: function () { return Arrow_js_1.Field; } }));
Object.defineProperty(exports, "Visitor", ({ enumerable: true, get: function () { return Arrow_js_1.Visitor; } }));
Object.defineProperty(exports, "Vector", ({ enumerable: true, get: function () { return Arrow_js_1.Vector; } }));
Object.defineProperty(exports, "makeVector", ({ enumerable: true, get: function () { return Arrow_js_1.makeVector; } }));
Object.defineProperty(exports, "vectorFromArray", ({ enumerable: true, get: function () { return Arrow_js_1.vectorFromArray; } }));
Object.defineProperty(exports, "tableFromJSON", ({ enumerable: true, get: function () { return Arrow_js_1.tableFromJSON; } }));
Object.defineProperty(exports, "ByteStream", ({ enumerable: true, get: function () { return Arrow_js_1.ByteStream; } }));
Object.defineProperty(exports, "AsyncByteStream", ({ enumerable: true, get: function () { return Arrow_js_1.AsyncByteStream; } }));
Object.defineProperty(exports, "AsyncByteQueue", ({ enumerable: true, get: function () { return Arrow_js_1.AsyncByteQueue; } }));
Object.defineProperty(exports, "RecordBatchReader", ({ enumerable: true, get: function () { return Arrow_js_1.RecordBatchReader; } }));
Object.defineProperty(exports, "RecordBatchFileReader", ({ enumerable: true, get: function () { return Arrow_js_1.RecordBatchFileReader; } }));
Object.defineProperty(exports, "RecordBatchStreamReader", ({ enumerable: true, get: function () { return Arrow_js_1.RecordBatchStreamReader; } }));
Object.defineProperty(exports, "AsyncRecordBatchFileReader", ({ enumerable: true, get: function () { return Arrow_js_1.AsyncRecordBatchFileReader; } }));
Object.defineProperty(exports, "AsyncRecordBatchStreamReader", ({ enumerable: true, get: function () { return Arrow_js_1.AsyncRecordBatchStreamReader; } }));
Object.defineProperty(exports, "RecordBatchWriter", ({ enumerable: true, get: function () { return Arrow_js_1.RecordBatchWriter; } }));
Object.defineProperty(exports, "RecordBatchFileWriter", ({ enumerable: true, get: function () { return Arrow_js_1.RecordBatchFileWriter; } }));
Object.defineProperty(exports, "RecordBatchStreamWriter", ({ enumerable: true, get: function () { return Arrow_js_1.RecordBatchStreamWriter; } }));
Object.defineProperty(exports, "RecordBatchJSONWriter", ({ enumerable: true, get: function () { return Arrow_js_1.RecordBatchJSONWriter; } }));
Object.defineProperty(exports, "tableFromIPC", ({ enumerable: true, get: function () { return Arrow_js_1.tableFromIPC; } }));
Object.defineProperty(exports, "tableToIPC", ({ enumerable: true, get: function () { return Arrow_js_1.tableToIPC; } }));
Object.defineProperty(exports, "MessageReader", ({ enumerable: true, get: function () { return Arrow_js_1.MessageReader; } }));
Object.defineProperty(exports, "AsyncMessageReader", ({ enumerable: true, get: function () { return Arrow_js_1.AsyncMessageReader; } }));
Object.defineProperty(exports, "JSONMessageReader", ({ enumerable: true, get: function () { return Arrow_js_1.JSONMessageReader; } }));
Object.defineProperty(exports, "Message", ({ enumerable: true, get: function () { return Arrow_js_1.Message; } }));
Object.defineProperty(exports, "RecordBatch", ({ enumerable: true, get: function () { return Arrow_js_1.RecordBatch; } }));
Object.defineProperty(exports, "util", ({ enumerable: true, get: function () { return Arrow_js_1.util; } }));
Object.defineProperty(exports, "Builder", ({ enumerable: true, get: function () { return Arrow_js_1.Builder; } }));
Object.defineProperty(exports, "makeBuilder", ({ enumerable: true, get: function () { return Arrow_js_1.makeBuilder; } }));
Object.defineProperty(exports, "builderThroughIterable", ({ enumerable: true, get: function () { return Arrow_js_1.builderThroughIterable; } }));
Object.defineProperty(exports, "builderThroughAsyncIterable", ({ enumerable: true, get: function () { return Arrow_js_1.builderThroughAsyncIterable; } }));
var Arrow_js_2 = __webpack_require__(180);
Object.defineProperty(exports, "BinaryBuilder", ({ enumerable: true, get: function () { return Arrow_js_2.BinaryBuilder; } }));
Object.defineProperty(exports, "LargeBinaryBuilder", ({ enumerable: true, get: function () { return Arrow_js_2.LargeBinaryBuilder; } }));
Object.defineProperty(exports, "BoolBuilder", ({ enumerable: true, get: function () { return Arrow_js_2.BoolBuilder; } }));
Object.defineProperty(exports, "DateBuilder", ({ enumerable: true, get: function () { return Arrow_js_2.DateBuilder; } }));
Object.defineProperty(exports, "DateDayBuilder", ({ enumerable: true, get: function () { return Arrow_js_2.DateDayBuilder; } }));
Object.defineProperty(exports, "DateMillisecondBuilder", ({ enumerable: true, get: function () { return Arrow_js_2.DateMillisecondBuilder; } }));
Object.defineProperty(exports, "DecimalBuilder", ({ enumerable: true, get: function () { return Arrow_js_2.DecimalBuilder; } }));
Object.defineProperty(exports, "DictionaryBuilder", ({ enumerable: true, get: function () { return Arrow_js_2.DictionaryBuilder; } }));
Object.defineProperty(exports, "FixedSizeBinaryBuilder", ({ enumerable: true, get: function () { return Arrow_js_2.FixedSizeBinaryBuilder; } }));
Object.defineProperty(exports, "FixedSizeListBuilder", ({ enumerable: true, get: function () { return Arrow_js_2.FixedSizeListBuilder; } }));
Object.defineProperty(exports, "FloatBuilder", ({ enumerable: true, get: function () { return Arrow_js_2.FloatBuilder; } }));
Object.defineProperty(exports, "Float16Builder", ({ enumerable: true, get: function () { return Arrow_js_2.Float16Builder; } }));
Object.defineProperty(exports, "Float32Builder", ({ enumerable: true, get: function () { return Arrow_js_2.Float32Builder; } }));
Object.defineProperty(exports, "Float64Builder", ({ enumerable: true, get: function () { return Arrow_js_2.Float64Builder; } }));
Object.defineProperty(exports, "IntervalBuilder", ({ enumerable: true, get: function () { return Arrow_js_2.IntervalBuilder; } }));
Object.defineProperty(exports, "IntervalDayTimeBuilder", ({ enumerable: true, get: function () { return Arrow_js_2.IntervalDayTimeBuilder; } }));
Object.defineProperty(exports, "IntervalYearMonthBuilder", ({ enumerable: true, get: function () { return Arrow_js_2.IntervalYearMonthBuilder; } }));
Object.defineProperty(exports, "DurationBuilder", ({ enumerable: true, get: function () { return Arrow_js_2.DurationBuilder; } }));
Object.defineProperty(exports, "DurationSecondBuilder", ({ enumerable: true, get: function () { return Arrow_js_2.DurationSecondBuilder; } }));
Object.defineProperty(exports, "DurationMillisecondBuilder", ({ enumerable: true, get: function () { return Arrow_js_2.DurationMillisecondBuilder; } }));
Object.defineProperty(exports, "DurationMicrosecondBuilder", ({ enumerable: true, get: function () { return Arrow_js_2.DurationMicrosecondBuilder; } }));
Object.defineProperty(exports, "DurationNanosecondBuilder", ({ enumerable: true, get: function () { return Arrow_js_2.DurationNanosecondBuilder; } }));
Object.defineProperty(exports, "IntBuilder", ({ enumerable: true, get: function () { return Arrow_js_2.IntBuilder; } }));
Object.defineProperty(exports, "Int8Builder", ({ enumerable: true, get: function () { return Arrow_js_2.Int8Builder; } }));
Object.defineProperty(exports, "Int16Builder", ({ enumerable: true, get: function () { return Arrow_js_2.Int16Builder; } }));
Object.defineProperty(exports, "Int32Builder", ({ enumerable: true, get: function () { return Arrow_js_2.Int32Builder; } }));
Object.defineProperty(exports, "Int64Builder", ({ enumerable: true, get: function () { return Arrow_js_2.Int64Builder; } }));
Object.defineProperty(exports, "Uint8Builder", ({ enumerable: true, get: function () { return Arrow_js_2.Uint8Builder; } }));
Object.defineProperty(exports, "Uint16Builder", ({ enumerable: true, get: function () { return Arrow_js_2.Uint16Builder; } }));
Object.defineProperty(exports, "Uint32Builder", ({ enumerable: true, get: function () { return Arrow_js_2.Uint32Builder; } }));
Object.defineProperty(exports, "Uint64Builder", ({ enumerable: true, get: function () { return Arrow_js_2.Uint64Builder; } }));
Object.defineProperty(exports, "ListBuilder", ({ enumerable: true, get: function () { return Arrow_js_2.ListBuilder; } }));
Object.defineProperty(exports, "MapBuilder", ({ enumerable: true, get: function () { return Arrow_js_2.MapBuilder; } }));
Object.defineProperty(exports, "NullBuilder", ({ enumerable: true, get: function () { return Arrow_js_2.NullBuilder; } }));
Object.defineProperty(exports, "StructBuilder", ({ enumerable: true, get: function () { return Arrow_js_2.StructBuilder; } }));
Object.defineProperty(exports, "TimestampBuilder", ({ enumerable: true, get: function () { return Arrow_js_2.TimestampBuilder; } }));
Object.defineProperty(exports, "TimestampSecondBuilder", ({ enumerable: true, get: function () { return Arrow_js_2.TimestampSecondBuilder; } }));
Object.defineProperty(exports, "TimestampMillisecondBuilder", ({ enumerable: true, get: function () { return Arrow_js_2.TimestampMillisecondBuilder; } }));
Object.defineProperty(exports, "TimestampMicrosecondBuilder", ({ enumerable: true, get: function () { return Arrow_js_2.TimestampMicrosecondBuilder; } }));
Object.defineProperty(exports, "TimestampNanosecondBuilder", ({ enumerable: true, get: function () { return Arrow_js_2.TimestampNanosecondBuilder; } }));
Object.defineProperty(exports, "TimeBuilder", ({ enumerable: true, get: function () { return Arrow_js_2.TimeBuilder; } }));
Object.defineProperty(exports, "TimeSecondBuilder", ({ enumerable: true, get: function () { return Arrow_js_2.TimeSecondBuilder; } }));
Object.defineProperty(exports, "TimeMillisecondBuilder", ({ enumerable: true, get: function () { return Arrow_js_2.TimeMillisecondBuilder; } }));
Object.defineProperty(exports, "TimeMicrosecondBuilder", ({ enumerable: true, get: function () { return Arrow_js_2.TimeMicrosecondBuilder; } }));
Object.defineProperty(exports, "TimeNanosecondBuilder", ({ enumerable: true, get: function () { return Arrow_js_2.TimeNanosecondBuilder; } }));
Object.defineProperty(exports, "UnionBuilder", ({ enumerable: true, get: function () { return Arrow_js_2.UnionBuilder; } }));
Object.defineProperty(exports, "DenseUnionBuilder", ({ enumerable: true, get: function () { return Arrow_js_2.DenseUnionBuilder; } }));
Object.defineProperty(exports, "SparseUnionBuilder", ({ enumerable: true, get: function () { return Arrow_js_2.SparseUnionBuilder; } }));
Object.defineProperty(exports, "Utf8Builder", ({ enumerable: true, get: function () { return Arrow_js_2.Utf8Builder; } }));
Object.defineProperty(exports, "LargeUtf8Builder", ({ enumerable: true, get: function () { return Arrow_js_2.LargeUtf8Builder; } }));

//# sourceMappingURL=Arrow.dom.js.map


/***/ }),
/* 176 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toDOMStream = void 0;
const tslib_1 = __webpack_require__(41);
const buffer_js_1 = __webpack_require__(43);
const compat_js_1 = __webpack_require__(45);
/** @ignore */
function toDOMStream(source, options) {
    if ((0, compat_js_1.isAsyncIterable)(source)) {
        return asyncIterableAsReadableDOMStream(source, options);
    }
    if ((0, compat_js_1.isIterable)(source)) {
        return iterableAsReadableDOMStream(source, options);
    }
    /* istanbul ignore next */
    throw new Error(`toDOMStream() must be called with an Iterable or AsyncIterable`);
}
exports.toDOMStream = toDOMStream;
/** @ignore */
function iterableAsReadableDOMStream(source, options) {
    let it = null;
    const bm = ((options === null || options === void 0 ? void 0 : options.type) === 'bytes') || false;
    const hwm = (options === null || options === void 0 ? void 0 : options.highWaterMark) || (Math.pow(2, 24));
    return new ReadableStream(Object.assign(Object.assign({}, options), { start(controller) { next(controller, it || (it = source[Symbol.iterator]())); },
        pull(controller) { it ? (next(controller, it)) : controller.close(); },
        cancel() { ((it === null || it === void 0 ? void 0 : it.return) && it.return() || true) && (it = null); } }), Object.assign({ highWaterMark: bm ? hwm : undefined }, options));
    function next(controller, it) {
        let buf;
        let r = null;
        let size = controller.desiredSize || null;
        while (!(r = it.next(bm ? size : null)).done) {
            if (ArrayBuffer.isView(r.value) && (buf = (0, buffer_js_1.toUint8Array)(r.value))) {
                size != null && bm && (size = size - buf.byteLength + 1);
                r.value = buf;
            }
            controller.enqueue(r.value);
            if (size != null && --size <= 0) {
                return;
            }
        }
        controller.close();
    }
}
/** @ignore */
function asyncIterableAsReadableDOMStream(source, options) {
    let it = null;
    const bm = ((options === null || options === void 0 ? void 0 : options.type) === 'bytes') || false;
    const hwm = (options === null || options === void 0 ? void 0 : options.highWaterMark) || (Math.pow(2, 24));
    return new ReadableStream(Object.assign(Object.assign({}, options), { start(controller) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () { yield next(controller, it || (it = source[Symbol.asyncIterator]())); });
        },
        pull(controller) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () { it ? (yield next(controller, it)) : controller.close(); });
        },
        cancel() {
            return tslib_1.__awaiter(this, void 0, void 0, function* () { ((it === null || it === void 0 ? void 0 : it.return) && (yield it.return()) || true) && (it = null); });
        } }), Object.assign({ highWaterMark: bm ? hwm : undefined }, options));
    function next(controller, it) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let buf;
            let r = null;
            let size = controller.desiredSize || null;
            while (!(r = yield it.next(bm ? size : null)).done) {
                if (ArrayBuffer.isView(r.value) && (buf = (0, buffer_js_1.toUint8Array)(r.value))) {
                    size != null && bm && (size = size - buf.byteLength + 1);
                    r.value = buf;
                }
                controller.enqueue(r.value);
                if (size != null && --size <= 0) {
                    return;
                }
            }
            controller.close();
        });
    }
}

//# sourceMappingURL=iterable.js.map


/***/ }),
/* 177 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BuilderTransform = exports.builderThroughDOMStream = void 0;
const tslib_1 = __webpack_require__(41);
const factories_js_1 = __webpack_require__(136);
/** @ignore */
function builderThroughDOMStream(options) {
    return new BuilderTransform(options);
}
exports.builderThroughDOMStream = builderThroughDOMStream;
/** @ignore */
class BuilderTransform {
    constructor(options) {
        // Access properties by string indexers to defeat closure compiler
        this._numChunks = 0;
        this._finished = false;
        this._bufferedSize = 0;
        const { ['readableStrategy']: readableStrategy, ['writableStrategy']: writableStrategy, ['queueingStrategy']: queueingStrategy = 'count' } = options, builderOptions = tslib_1.__rest(options, ['readableStrategy', 'writableStrategy', 'queueingStrategy']);
        this._controller = null;
        this._builder = (0, factories_js_1.makeBuilder)(builderOptions);
        this._getSize = queueingStrategy !== 'bytes' ? chunkLength : chunkByteLength;
        const { ['highWaterMark']: readableHighWaterMark = queueingStrategy === 'bytes' ? Math.pow(2, 14) : 1000 } = Object.assign({}, readableStrategy);
        const { ['highWaterMark']: writableHighWaterMark = queueingStrategy === 'bytes' ? Math.pow(2, 14) : 1000 } = Object.assign({}, writableStrategy);
        this['readable'] = new ReadableStream({
            ['cancel']: () => { this._builder.clear(); },
            ['pull']: (c) => { this._maybeFlush(this._builder, this._controller = c); },
            ['start']: (c) => { this._maybeFlush(this._builder, this._controller = c); },
        }, {
            'highWaterMark': readableHighWaterMark,
            'size': queueingStrategy !== 'bytes' ? chunkLength : chunkByteLength,
        });
        this['writable'] = new WritableStream({
            ['abort']: () => { this._builder.clear(); },
            ['write']: () => { this._maybeFlush(this._builder, this._controller); },
            ['close']: () => { this._maybeFlush(this._builder.finish(), this._controller); },
        }, {
            'highWaterMark': writableHighWaterMark,
            'size': (value) => this._writeValueAndReturnChunkSize(value),
        });
    }
    _writeValueAndReturnChunkSize(value) {
        const bufferedSize = this._bufferedSize;
        this._bufferedSize = this._getSize(this._builder.append(value));
        return this._bufferedSize - bufferedSize;
    }
    _maybeFlush(builder, controller) {
        if (controller == null) {
            return;
        }
        if (this._bufferedSize >= controller.desiredSize) {
            ++this._numChunks && this._enqueue(controller, builder.toVector());
        }
        if (builder.finished) {
            if (builder.length > 0 || this._numChunks === 0) {
                ++this._numChunks && this._enqueue(controller, builder.toVector());
            }
            if (!this._finished && (this._finished = true)) {
                this._enqueue(controller, null);
            }
        }
    }
    _enqueue(controller, chunk) {
        this._bufferedSize = 0;
        this._controller = null;
        chunk == null ? controller.close() : controller.enqueue(chunk);
    }
}
exports.BuilderTransform = BuilderTransform;
/** @ignore */ const chunkLength = (chunk) => { var _a; return (_a = chunk === null || chunk === void 0 ? void 0 : chunk.length) !== null && _a !== void 0 ? _a : 0; };
/** @ignore */ const chunkByteLength = (chunk) => { var _a; return (_a = chunk === null || chunk === void 0 ? void 0 : chunk.byteLength) !== null && _a !== void 0 ? _a : 0; };

//# sourceMappingURL=builder.js.map


/***/ }),
/* 178 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.recordBatchReaderThroughDOMStream = void 0;
const tslib_1 = __webpack_require__(41);
const stream_js_1 = __webpack_require__(129);
const reader_js_1 = __webpack_require__(124);
/** @ignore */
function recordBatchReaderThroughDOMStream(writableStrategy, readableStrategy) {
    const queue = new stream_js_1.AsyncByteQueue();
    let reader = null;
    const readable = new ReadableStream({
        cancel() {
            return tslib_1.__awaiter(this, void 0, void 0, function* () { yield queue.close(); });
        },
        start(controller) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () { yield next(controller, reader || (reader = yield open())); });
        },
        pull(controller) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () { reader ? yield next(controller, reader) : controller.close(); });
        }
    });
    return { writable: new WritableStream(queue, Object.assign({ 'highWaterMark': Math.pow(2, 14) }, writableStrategy)), readable };
    function open() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield (yield reader_js_1.RecordBatchReader.from(queue)).open(readableStrategy);
        });
    }
    function next(controller, reader) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let size = controller.desiredSize;
            let r = null;
            while (!(r = yield reader.next()).done) {
                controller.enqueue(r.value);
                if (size != null && --size <= 0) {
                    return;
                }
            }
            controller.close();
        });
    }
}
exports.recordBatchReaderThroughDOMStream = recordBatchReaderThroughDOMStream;

//# sourceMappingURL=reader.js.map


/***/ }),
/* 179 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.recordBatchWriterThroughDOMStream = void 0;
const tslib_1 = __webpack_require__(41);
const stream_js_1 = __webpack_require__(129);
/** @ignore */
function recordBatchWriterThroughDOMStream(writableStrategy, readableStrategy) {
    const writer = new this(writableStrategy);
    const reader = new stream_js_1.AsyncByteStream(writer);
    const readable = new ReadableStream({
        // type: 'bytes',
        cancel() {
            return tslib_1.__awaiter(this, void 0, void 0, function* () { yield reader.cancel(); });
        },
        pull(controller) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () { yield next(controller); });
        },
        start(controller) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () { yield next(controller); });
        },
    }, Object.assign({ 'highWaterMark': Math.pow(2, 14) }, readableStrategy));
    return { writable: new WritableStream(writer, writableStrategy), readable };
    function next(controller) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let buf = null;
            let size = controller.desiredSize;
            while (buf = yield reader.read(size || null)) {
                controller.enqueue(buf);
                if (size != null && (size -= buf.byteLength) <= 0) {
                    return;
                }
            }
            controller.close();
        });
    }
}
exports.recordBatchWriterThroughDOMStream = recordBatchWriterThroughDOMStream;

//# sourceMappingURL=writer.js.map


/***/ }),
/* 180 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DenseUnion = exports.Union = exports.Struct = exports.List = exports.Decimal = exports.TimeNanosecond = exports.TimeMicrosecond = exports.TimeMillisecond = exports.TimeSecond = exports.Time = exports.TimestampNanosecond = exports.TimestampMicrosecond = exports.TimestampMillisecond = exports.TimestampSecond = exports.Timestamp = exports.DateMillisecond = exports.DateDay = exports.Date_ = exports.FixedSizeBinary = exports.LargeBinary = exports.Binary = exports.LargeUtf8 = exports.Utf8 = exports.Float64 = exports.Float32 = exports.Float16 = exports.Float = exports.Uint64 = exports.Uint32 = exports.Uint16 = exports.Uint8 = exports.Int64 = exports.Int32 = exports.Int16 = exports.Int8 = exports.Int = exports.Bool = exports.Null = exports.DataType = exports.makeData = exports.Data = exports.MetadataVersion = exports.IntervalUnit = exports.UnionMode = exports.Precision = exports.TimeUnit = exports.DateUnit = exports.BufferType = exports.Type = exports.MessageHeader = void 0;
exports.TimeBuilder = exports.Uint64Builder = exports.Uint32Builder = exports.Uint16Builder = exports.Uint8Builder = exports.Int64Builder = exports.Int32Builder = exports.Int16Builder = exports.Int8Builder = exports.IntBuilder = exports.Float64Builder = exports.Float32Builder = exports.Float16Builder = exports.FloatBuilder = exports.FixedSizeBinaryBuilder = exports.DictionaryBuilder = exports.DecimalBuilder = exports.DateMillisecondBuilder = exports.DateDayBuilder = exports.DateBuilder = exports.NullBuilder = exports.BoolBuilder = exports.builderThroughAsyncIterable = exports.builderThroughIterable = exports.tableFromJSON = exports.vectorFromArray = exports.makeBuilder = exports.Builder = exports.StructRow = exports.MapRow = exports.Field = exports.Schema = exports.Visitor = exports.makeVector = exports.Vector = exports.tableFromArrays = exports.makeTable = exports.Table = exports.Map_ = exports.FixedSizeList = exports.DurationNanosecond = exports.DurationMicrosecond = exports.DurationMillisecond = exports.DurationSecond = exports.Duration = exports.IntervalYearMonth = exports.IntervalDayTime = exports.Interval = exports.Dictionary = exports.SparseUnion = void 0;
exports.util = exports.RecordBatch = exports.Message = exports.JSONMessageReader = exports.AsyncMessageReader = exports.MessageReader = exports.tableFromIPC = exports.tableToIPC = exports.RecordBatchJSONWriter = exports.RecordBatchStreamWriter = exports.RecordBatchFileWriter = exports.RecordBatchWriter = exports.AsyncRecordBatchStreamReader = exports.AsyncRecordBatchFileReader = exports.RecordBatchStreamReader = exports.RecordBatchFileReader = exports.RecordBatchReader = exports.AsyncByteQueue = exports.AsyncByteStream = exports.ByteStream = exports.DenseUnionBuilder = exports.SparseUnionBuilder = exports.UnionBuilder = exports.StructBuilder = exports.MapBuilder = exports.FixedSizeListBuilder = exports.ListBuilder = exports.LargeBinaryBuilder = exports.BinaryBuilder = exports.LargeUtf8Builder = exports.Utf8Builder = exports.DurationNanosecondBuilder = exports.DurationMicrosecondBuilder = exports.DurationMillisecondBuilder = exports.DurationSecondBuilder = exports.DurationBuilder = exports.IntervalYearMonthBuilder = exports.IntervalDayTimeBuilder = exports.IntervalBuilder = exports.TimestampNanosecondBuilder = exports.TimestampMicrosecondBuilder = exports.TimestampMillisecondBuilder = exports.TimestampSecondBuilder = exports.TimestampBuilder = exports.TimeNanosecondBuilder = exports.TimeMicrosecondBuilder = exports.TimeMillisecondBuilder = exports.TimeSecondBuilder = void 0;
var message_header_js_1 = __webpack_require__(55);
Object.defineProperty(exports, "MessageHeader", ({ enumerable: true, get: function () { return message_header_js_1.MessageHeader; } }));
var enum_js_1 = __webpack_require__(48);
Object.defineProperty(exports, "Type", ({ enumerable: true, get: function () { return enum_js_1.Type; } }));
Object.defineProperty(exports, "BufferType", ({ enumerable: true, get: function () { return enum_js_1.BufferType; } }));
Object.defineProperty(exports, "DateUnit", ({ enumerable: true, get: function () { return enum_js_1.DateUnit; } }));
Object.defineProperty(exports, "TimeUnit", ({ enumerable: true, get: function () { return enum_js_1.TimeUnit; } }));
Object.defineProperty(exports, "Precision", ({ enumerable: true, get: function () { return enum_js_1.Precision; } }));
Object.defineProperty(exports, "UnionMode", ({ enumerable: true, get: function () { return enum_js_1.UnionMode; } }));
Object.defineProperty(exports, "IntervalUnit", ({ enumerable: true, get: function () { return enum_js_1.IntervalUnit; } }));
Object.defineProperty(exports, "MetadataVersion", ({ enumerable: true, get: function () { return enum_js_1.MetadataVersion; } }));
var data_js_1 = __webpack_require__(117);
Object.defineProperty(exports, "Data", ({ enumerable: true, get: function () { return data_js_1.Data; } }));
Object.defineProperty(exports, "makeData", ({ enumerable: true, get: function () { return data_js_1.makeData; } }));
var type_js_1 = __webpack_require__(113);
Object.defineProperty(exports, "DataType", ({ enumerable: true, get: function () { return type_js_1.DataType; } }));
Object.defineProperty(exports, "Null", ({ enumerable: true, get: function () { return type_js_1.Null; } }));
Object.defineProperty(exports, "Bool", ({ enumerable: true, get: function () { return type_js_1.Bool; } }));
Object.defineProperty(exports, "Int", ({ enumerable: true, get: function () { return type_js_1.Int; } }));
Object.defineProperty(exports, "Int8", ({ enumerable: true, get: function () { return type_js_1.Int8; } }));
Object.defineProperty(exports, "Int16", ({ enumerable: true, get: function () { return type_js_1.Int16; } }));
Object.defineProperty(exports, "Int32", ({ enumerable: true, get: function () { return type_js_1.Int32; } }));
Object.defineProperty(exports, "Int64", ({ enumerable: true, get: function () { return type_js_1.Int64; } }));
Object.defineProperty(exports, "Uint8", ({ enumerable: true, get: function () { return type_js_1.Uint8; } }));
Object.defineProperty(exports, "Uint16", ({ enumerable: true, get: function () { return type_js_1.Uint16; } }));
Object.defineProperty(exports, "Uint32", ({ enumerable: true, get: function () { return type_js_1.Uint32; } }));
Object.defineProperty(exports, "Uint64", ({ enumerable: true, get: function () { return type_js_1.Uint64; } }));
Object.defineProperty(exports, "Float", ({ enumerable: true, get: function () { return type_js_1.Float; } }));
Object.defineProperty(exports, "Float16", ({ enumerable: true, get: function () { return type_js_1.Float16; } }));
Object.defineProperty(exports, "Float32", ({ enumerable: true, get: function () { return type_js_1.Float32; } }));
Object.defineProperty(exports, "Float64", ({ enumerable: true, get: function () { return type_js_1.Float64; } }));
Object.defineProperty(exports, "Utf8", ({ enumerable: true, get: function () { return type_js_1.Utf8; } }));
Object.defineProperty(exports, "LargeUtf8", ({ enumerable: true, get: function () { return type_js_1.LargeUtf8; } }));
Object.defineProperty(exports, "Binary", ({ enumerable: true, get: function () { return type_js_1.Binary; } }));
Object.defineProperty(exports, "LargeBinary", ({ enumerable: true, get: function () { return type_js_1.LargeBinary; } }));
Object.defineProperty(exports, "FixedSizeBinary", ({ enumerable: true, get: function () { return type_js_1.FixedSizeBinary; } }));
Object.defineProperty(exports, "Date_", ({ enumerable: true, get: function () { return type_js_1.Date_; } }));
Object.defineProperty(exports, "DateDay", ({ enumerable: true, get: function () { return type_js_1.DateDay; } }));
Object.defineProperty(exports, "DateMillisecond", ({ enumerable: true, get: function () { return type_js_1.DateMillisecond; } }));
Object.defineProperty(exports, "Timestamp", ({ enumerable: true, get: function () { return type_js_1.Timestamp; } }));
Object.defineProperty(exports, "TimestampSecond", ({ enumerable: true, get: function () { return type_js_1.TimestampSecond; } }));
Object.defineProperty(exports, "TimestampMillisecond", ({ enumerable: true, get: function () { return type_js_1.TimestampMillisecond; } }));
Object.defineProperty(exports, "TimestampMicrosecond", ({ enumerable: true, get: function () { return type_js_1.TimestampMicrosecond; } }));
Object.defineProperty(exports, "TimestampNanosecond", ({ enumerable: true, get: function () { return type_js_1.TimestampNanosecond; } }));
Object.defineProperty(exports, "Time", ({ enumerable: true, get: function () { return type_js_1.Time; } }));
Object.defineProperty(exports, "TimeSecond", ({ enumerable: true, get: function () { return type_js_1.TimeSecond; } }));
Object.defineProperty(exports, "TimeMillisecond", ({ enumerable: true, get: function () { return type_js_1.TimeMillisecond; } }));
Object.defineProperty(exports, "TimeMicrosecond", ({ enumerable: true, get: function () { return type_js_1.TimeMicrosecond; } }));
Object.defineProperty(exports, "TimeNanosecond", ({ enumerable: true, get: function () { return type_js_1.TimeNanosecond; } }));
Object.defineProperty(exports, "Decimal", ({ enumerable: true, get: function () { return type_js_1.Decimal; } }));
Object.defineProperty(exports, "List", ({ enumerable: true, get: function () { return type_js_1.List; } }));
Object.defineProperty(exports, "Struct", ({ enumerable: true, get: function () { return type_js_1.Struct; } }));
Object.defineProperty(exports, "Union", ({ enumerable: true, get: function () { return type_js_1.Union; } }));
Object.defineProperty(exports, "DenseUnion", ({ enumerable: true, get: function () { return type_js_1.DenseUnion; } }));
Object.defineProperty(exports, "SparseUnion", ({ enumerable: true, get: function () { return type_js_1.SparseUnion; } }));
Object.defineProperty(exports, "Dictionary", ({ enumerable: true, get: function () { return type_js_1.Dictionary; } }));
Object.defineProperty(exports, "Interval", ({ enumerable: true, get: function () { return type_js_1.Interval; } }));
Object.defineProperty(exports, "IntervalDayTime", ({ enumerable: true, get: function () { return type_js_1.IntervalDayTime; } }));
Object.defineProperty(exports, "IntervalYearMonth", ({ enumerable: true, get: function () { return type_js_1.IntervalYearMonth; } }));
Object.defineProperty(exports, "Duration", ({ enumerable: true, get: function () { return type_js_1.Duration; } }));
Object.defineProperty(exports, "DurationSecond", ({ enumerable: true, get: function () { return type_js_1.DurationSecond; } }));
Object.defineProperty(exports, "DurationMillisecond", ({ enumerable: true, get: function () { return type_js_1.DurationMillisecond; } }));
Object.defineProperty(exports, "DurationMicrosecond", ({ enumerable: true, get: function () { return type_js_1.DurationMicrosecond; } }));
Object.defineProperty(exports, "DurationNanosecond", ({ enumerable: true, get: function () { return type_js_1.DurationNanosecond; } }));
Object.defineProperty(exports, "FixedSizeList", ({ enumerable: true, get: function () { return type_js_1.FixedSizeList; } }));
Object.defineProperty(exports, "Map_", ({ enumerable: true, get: function () { return type_js_1.Map_; } }));
var table_js_1 = __webpack_require__(135);
Object.defineProperty(exports, "Table", ({ enumerable: true, get: function () { return table_js_1.Table; } }));
Object.defineProperty(exports, "makeTable", ({ enumerable: true, get: function () { return table_js_1.makeTable; } }));
Object.defineProperty(exports, "tableFromArrays", ({ enumerable: true, get: function () { return table_js_1.tableFromArrays; } }));
var vector_js_1 = __webpack_require__(47);
Object.defineProperty(exports, "Vector", ({ enumerable: true, get: function () { return vector_js_1.Vector; } }));
Object.defineProperty(exports, "makeVector", ({ enumerable: true, get: function () { return vector_js_1.makeVector; } }));
var visitor_js_1 = __webpack_require__(112);
Object.defineProperty(exports, "Visitor", ({ enumerable: true, get: function () { return visitor_js_1.Visitor; } }));
var schema_js_1 = __webpack_require__(128);
Object.defineProperty(exports, "Schema", ({ enumerable: true, get: function () { return schema_js_1.Schema; } }));
Object.defineProperty(exports, "Field", ({ enumerable: true, get: function () { return schema_js_1.Field; } }));
var map_js_1 = __webpack_require__(107);
Object.defineProperty(exports, "MapRow", ({ enumerable: true, get: function () { return map_js_1.MapRow; } }));
var struct_js_1 = __webpack_require__(114);
Object.defineProperty(exports, "StructRow", ({ enumerable: true, get: function () { return struct_js_1.StructRow; } }));
var builder_js_1 = __webpack_require__(46);
Object.defineProperty(exports, "Builder", ({ enumerable: true, get: function () { return builder_js_1.Builder; } }));
var factories_js_1 = __webpack_require__(136);
Object.defineProperty(exports, "makeBuilder", ({ enumerable: true, get: function () { return factories_js_1.makeBuilder; } }));
Object.defineProperty(exports, "vectorFromArray", ({ enumerable: true, get: function () { return factories_js_1.vectorFromArray; } }));
Object.defineProperty(exports, "tableFromJSON", ({ enumerable: true, get: function () { return factories_js_1.tableFromJSON; } }));
Object.defineProperty(exports, "builderThroughIterable", ({ enumerable: true, get: function () { return factories_js_1.builderThroughIterable; } }));
Object.defineProperty(exports, "builderThroughAsyncIterable", ({ enumerable: true, get: function () { return factories_js_1.builderThroughAsyncIterable; } }));
var bool_js_1 = __webpack_require__(140);
Object.defineProperty(exports, "BoolBuilder", ({ enumerable: true, get: function () { return bool_js_1.BoolBuilder; } }));
var null_js_1 = __webpack_require__(152);
Object.defineProperty(exports, "NullBuilder", ({ enumerable: true, get: function () { return null_js_1.NullBuilder; } }));
var date_js_1 = __webpack_require__(141);
Object.defineProperty(exports, "DateBuilder", ({ enumerable: true, get: function () { return date_js_1.DateBuilder; } }));
Object.defineProperty(exports, "DateDayBuilder", ({ enumerable: true, get: function () { return date_js_1.DateDayBuilder; } }));
Object.defineProperty(exports, "DateMillisecondBuilder", ({ enumerable: true, get: function () { return date_js_1.DateMillisecondBuilder; } }));
var decimal_js_1 = __webpack_require__(142);
Object.defineProperty(exports, "DecimalBuilder", ({ enumerable: true, get: function () { return decimal_js_1.DecimalBuilder; } }));
var dictionary_js_1 = __webpack_require__(143);
Object.defineProperty(exports, "DictionaryBuilder", ({ enumerable: true, get: function () { return dictionary_js_1.DictionaryBuilder; } }));
var fixedsizebinary_js_1 = __webpack_require__(144);
Object.defineProperty(exports, "FixedSizeBinaryBuilder", ({ enumerable: true, get: function () { return fixedsizebinary_js_1.FixedSizeBinaryBuilder; } }));
var float_js_1 = __webpack_require__(146);
Object.defineProperty(exports, "FloatBuilder", ({ enumerable: true, get: function () { return float_js_1.FloatBuilder; } }));
Object.defineProperty(exports, "Float16Builder", ({ enumerable: true, get: function () { return float_js_1.Float16Builder; } }));
Object.defineProperty(exports, "Float32Builder", ({ enumerable: true, get: function () { return float_js_1.Float32Builder; } }));
Object.defineProperty(exports, "Float64Builder", ({ enumerable: true, get: function () { return float_js_1.Float64Builder; } }));
var int_js_1 = __webpack_require__(149);
Object.defineProperty(exports, "IntBuilder", ({ enumerable: true, get: function () { return int_js_1.IntBuilder; } }));
Object.defineProperty(exports, "Int8Builder", ({ enumerable: true, get: function () { return int_js_1.Int8Builder; } }));
Object.defineProperty(exports, "Int16Builder", ({ enumerable: true, get: function () { return int_js_1.Int16Builder; } }));
Object.defineProperty(exports, "Int32Builder", ({ enumerable: true, get: function () { return int_js_1.Int32Builder; } }));
Object.defineProperty(exports, "Int64Builder", ({ enumerable: true, get: function () { return int_js_1.Int64Builder; } }));
Object.defineProperty(exports, "Uint8Builder", ({ enumerable: true, get: function () { return int_js_1.Uint8Builder; } }));
Object.defineProperty(exports, "Uint16Builder", ({ enumerable: true, get: function () { return int_js_1.Uint16Builder; } }));
Object.defineProperty(exports, "Uint32Builder", ({ enumerable: true, get: function () { return int_js_1.Uint32Builder; } }));
Object.defineProperty(exports, "Uint64Builder", ({ enumerable: true, get: function () { return int_js_1.Uint64Builder; } }));
var time_js_1 = __webpack_require__(155);
Object.defineProperty(exports, "TimeBuilder", ({ enumerable: true, get: function () { return time_js_1.TimeBuilder; } }));
Object.defineProperty(exports, "TimeSecondBuilder", ({ enumerable: true, get: function () { return time_js_1.TimeSecondBuilder; } }));
Object.defineProperty(exports, "TimeMillisecondBuilder", ({ enumerable: true, get: function () { return time_js_1.TimeMillisecondBuilder; } }));
Object.defineProperty(exports, "TimeMicrosecondBuilder", ({ enumerable: true, get: function () { return time_js_1.TimeMicrosecondBuilder; } }));
Object.defineProperty(exports, "TimeNanosecondBuilder", ({ enumerable: true, get: function () { return time_js_1.TimeNanosecondBuilder; } }));
var timestamp_js_1 = __webpack_require__(154);
Object.defineProperty(exports, "TimestampBuilder", ({ enumerable: true, get: function () { return timestamp_js_1.TimestampBuilder; } }));
Object.defineProperty(exports, "TimestampSecondBuilder", ({ enumerable: true, get: function () { return timestamp_js_1.TimestampSecondBuilder; } }));
Object.defineProperty(exports, "TimestampMillisecondBuilder", ({ enumerable: true, get: function () { return timestamp_js_1.TimestampMillisecondBuilder; } }));
Object.defineProperty(exports, "TimestampMicrosecondBuilder", ({ enumerable: true, get: function () { return timestamp_js_1.TimestampMicrosecondBuilder; } }));
Object.defineProperty(exports, "TimestampNanosecondBuilder", ({ enumerable: true, get: function () { return timestamp_js_1.TimestampNanosecondBuilder; } }));
var interval_js_1 = __webpack_require__(147);
Object.defineProperty(exports, "IntervalBuilder", ({ enumerable: true, get: function () { return interval_js_1.IntervalBuilder; } }));
Object.defineProperty(exports, "IntervalDayTimeBuilder", ({ enumerable: true, get: function () { return interval_js_1.IntervalDayTimeBuilder; } }));
Object.defineProperty(exports, "IntervalYearMonthBuilder", ({ enumerable: true, get: function () { return interval_js_1.IntervalYearMonthBuilder; } }));
var duration_js_1 = __webpack_require__(148);
Object.defineProperty(exports, "DurationBuilder", ({ enumerable: true, get: function () { return duration_js_1.DurationBuilder; } }));
Object.defineProperty(exports, "DurationSecondBuilder", ({ enumerable: true, get: function () { return duration_js_1.DurationSecondBuilder; } }));
Object.defineProperty(exports, "DurationMillisecondBuilder", ({ enumerable: true, get: function () { return duration_js_1.DurationMillisecondBuilder; } }));
Object.defineProperty(exports, "DurationMicrosecondBuilder", ({ enumerable: true, get: function () { return duration_js_1.DurationMicrosecondBuilder; } }));
Object.defineProperty(exports, "DurationNanosecondBuilder", ({ enumerable: true, get: function () { return duration_js_1.DurationNanosecondBuilder; } }));
var utf8_js_1 = __webpack_require__(157);
Object.defineProperty(exports, "Utf8Builder", ({ enumerable: true, get: function () { return utf8_js_1.Utf8Builder; } }));
var largeutf8_js_1 = __webpack_require__(158);
Object.defineProperty(exports, "LargeUtf8Builder", ({ enumerable: true, get: function () { return largeutf8_js_1.LargeUtf8Builder; } }));
var binary_js_1 = __webpack_require__(138);
Object.defineProperty(exports, "BinaryBuilder", ({ enumerable: true, get: function () { return binary_js_1.BinaryBuilder; } }));
var largebinary_js_1 = __webpack_require__(139);
Object.defineProperty(exports, "LargeBinaryBuilder", ({ enumerable: true, get: function () { return largebinary_js_1.LargeBinaryBuilder; } }));
var list_js_1 = __webpack_require__(150);
Object.defineProperty(exports, "ListBuilder", ({ enumerable: true, get: function () { return list_js_1.ListBuilder; } }));
var fixedsizelist_js_1 = __webpack_require__(145);
Object.defineProperty(exports, "FixedSizeListBuilder", ({ enumerable: true, get: function () { return fixedsizelist_js_1.FixedSizeListBuilder; } }));
var map_js_2 = __webpack_require__(151);
Object.defineProperty(exports, "MapBuilder", ({ enumerable: true, get: function () { return map_js_2.MapBuilder; } }));
var struct_js_2 = __webpack_require__(153);
Object.defineProperty(exports, "StructBuilder", ({ enumerable: true, get: function () { return struct_js_2.StructBuilder; } }));
var union_js_1 = __webpack_require__(156);
Object.defineProperty(exports, "UnionBuilder", ({ enumerable: true, get: function () { return union_js_1.UnionBuilder; } }));
Object.defineProperty(exports, "SparseUnionBuilder", ({ enumerable: true, get: function () { return union_js_1.SparseUnionBuilder; } }));
Object.defineProperty(exports, "DenseUnionBuilder", ({ enumerable: true, get: function () { return union_js_1.DenseUnionBuilder; } }));
var stream_js_1 = __webpack_require__(129);
Object.defineProperty(exports, "ByteStream", ({ enumerable: true, get: function () { return stream_js_1.ByteStream; } }));
Object.defineProperty(exports, "AsyncByteStream", ({ enumerable: true, get: function () { return stream_js_1.AsyncByteStream; } }));
Object.defineProperty(exports, "AsyncByteQueue", ({ enumerable: true, get: function () { return stream_js_1.AsyncByteQueue; } }));
var reader_js_1 = __webpack_require__(124);
Object.defineProperty(exports, "RecordBatchReader", ({ enumerable: true, get: function () { return reader_js_1.RecordBatchReader; } }));
Object.defineProperty(exports, "RecordBatchFileReader", ({ enumerable: true, get: function () { return reader_js_1.RecordBatchFileReader; } }));
Object.defineProperty(exports, "RecordBatchStreamReader", ({ enumerable: true, get: function () { return reader_js_1.RecordBatchStreamReader; } }));
Object.defineProperty(exports, "AsyncRecordBatchFileReader", ({ enumerable: true, get: function () { return reader_js_1.AsyncRecordBatchFileReader; } }));
Object.defineProperty(exports, "AsyncRecordBatchStreamReader", ({ enumerable: true, get: function () { return reader_js_1.AsyncRecordBatchStreamReader; } }));
var writer_js_1 = __webpack_require__(166);
Object.defineProperty(exports, "RecordBatchWriter", ({ enumerable: true, get: function () { return writer_js_1.RecordBatchWriter; } }));
Object.defineProperty(exports, "RecordBatchFileWriter", ({ enumerable: true, get: function () { return writer_js_1.RecordBatchFileWriter; } }));
Object.defineProperty(exports, "RecordBatchStreamWriter", ({ enumerable: true, get: function () { return writer_js_1.RecordBatchStreamWriter; } }));
Object.defineProperty(exports, "RecordBatchJSONWriter", ({ enumerable: true, get: function () { return writer_js_1.RecordBatchJSONWriter; } }));
var serialization_js_1 = __webpack_require__(181);
Object.defineProperty(exports, "tableToIPC", ({ enumerable: true, get: function () { return serialization_js_1.tableToIPC; } }));
Object.defineProperty(exports, "tableFromIPC", ({ enumerable: true, get: function () { return serialization_js_1.tableFromIPC; } }));
var message_js_1 = __webpack_require__(161);
Object.defineProperty(exports, "MessageReader", ({ enumerable: true, get: function () { return message_js_1.MessageReader; } }));
Object.defineProperty(exports, "AsyncMessageReader", ({ enumerable: true, get: function () { return message_js_1.AsyncMessageReader; } }));
Object.defineProperty(exports, "JSONMessageReader", ({ enumerable: true, get: function () { return message_js_1.JSONMessageReader; } }));
var message_js_2 = __webpack_require__(162);
Object.defineProperty(exports, "Message", ({ enumerable: true, get: function () { return message_js_2.Message; } }));
var recordbatch_js_1 = __webpack_require__(134);
Object.defineProperty(exports, "RecordBatch", ({ enumerable: true, get: function () { return recordbatch_js_1.RecordBatch; } }));
const util_bn_ = __webpack_require__(110);
const util_int_ = __webpack_require__(133);
const util_bit_ = __webpack_require__(118);
const util_math_ = __webpack_require__(116);
const util_buffer_ = __webpack_require__(43);
const util_vector_ = __webpack_require__(106);
const util_pretty_ = __webpack_require__(108);
const typecomparator_js_1 = __webpack_require__(159);
/** @ignore */
exports.util = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, util_bn_), util_int_), util_bit_), util_math_), util_buffer_), util_vector_), util_pretty_), { compareSchemas: typecomparator_js_1.compareSchemas,
    compareFields: typecomparator_js_1.compareFields,
    compareTypes: typecomparator_js_1.compareTypes });

//# sourceMappingURL=Arrow.js.map


/***/ }),
/* 181 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.tableToIPC = exports.tableFromIPC = void 0;
const table_js_1 = __webpack_require__(135);
const compat_js_1 = __webpack_require__(45);
const reader_js_1 = __webpack_require__(124);
const writer_js_1 = __webpack_require__(166);
function tableFromIPC(input) {
    const reader = reader_js_1.RecordBatchReader.from(input);
    if ((0, compat_js_1.isPromise)(reader)) {
        return reader.then((reader) => tableFromIPC(reader));
    }
    if (reader.isAsync()) {
        return reader.readAll().then((xs) => new table_js_1.Table(xs));
    }
    return new table_js_1.Table(reader.readAll());
}
exports.tableFromIPC = tableFromIPC;
/**
 * Serialize a {@link Table} to the IPC format. This function is a convenience
 * wrapper for {@link RecordBatchStreamWriter} and {@link RecordBatchFileWriter}.
 * Opposite of {@link tableFromIPC}.
 *
 * @param table The Table to serialize.
 * @param type Whether to serialize the Table as a file or a stream.
 */
function tableToIPC(table, type = 'stream') {
    return (type === 'stream' ? writer_js_1.RecordBatchStreamWriter : writer_js_1.RecordBatchFileWriter)
        .writeAll(table)
        .toUint8Array(true);
}
exports.tableToIPC = tableToIPC;

//# sourceMappingURL=serialization.js.map


/***/ }),
/* 182 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// SPDX-License-Identifier: Apache-2.0
// SPDX-FileCopyrightText: Copyright The LanceDB Authors
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmbeddingFunctionRegistry = void 0;
exports.register = register;
exports.getRegistry = getRegistry;
__webpack_require__(183);
/**
 * This is a singleton class used to register embedding functions
 * and fetch them by name. It also handles serializing and deserializing.
 * You can implement your own embedding function by subclassing EmbeddingFunction
 * or TextEmbeddingFunction and registering it with the registry
 */
class EmbeddingFunctionRegistry {
    #functions = new Map();
    #variables = new Map();
    /**
     * Get the number of registered functions
     */
    length() {
        return this.#functions.size;
    }
    /**
     * Register an embedding function
     * @throws Error if the function is already registered
     */
    register(alias) {
        const self = this;
        return function (ctor) {
            if (!alias) {
                alias = ctor.name;
            }
            if (self.#functions.has(alias)) {
                throw new Error(`Embedding function with alias "${alias}" already exists`);
            }
            self.#functions.set(alias, ctor);
            Reflect.defineMetadata("lancedb::embedding::name", alias, ctor);
            return ctor;
        };
    }
    /**
     * Fetch an embedding function by name
     * @param name The name of the function
     */
    get(name) {
        const factory = this.#functions.get(name);
        if (!factory) {
            // biome-ignore lint/suspicious/noExplicitAny: <explanation>
            return undefined;
        }
        // biome-ignore lint/suspicious/noExplicitAny: <explanation>
        let create;
        if (factory.prototype.init) {
            // biome-ignore lint/suspicious/noExplicitAny: <explanation>
            create = async function (options) {
                const instance = new factory(options);
                await instance.init();
                return instance;
            };
        }
        else {
            // biome-ignore lint/suspicious/noExplicitAny: <explanation>
            create = (options) => new factory(options);
        }
        return {
            create,
        };
    }
    /**
     * reset the registry to the initial state
     */
    reset() {
        this.#functions.clear();
    }
    /**
     * @ignore
     */
    async parseFunctions(metadata) {
        if (!metadata.has("embedding_functions")) {
            return new Map();
        }
        else {
            const functions = (JSON.parse(metadata.get("embedding_functions")));
            const items = await Promise.all(functions.map(async (f) => {
                const fn = this.get(f.name);
                if (!fn) {
                    throw new Error(`Function "${f.name}" not found in registry`);
                }
                const func = await this.get(f.name).create(f.model);
                return [
                    f.name,
                    {
                        sourceColumn: f.sourceColumn,
                        vectorColumn: f.vectorColumn,
                        function: func,
                    },
                ];
            }));
            return new Map(items);
        }
    }
    // biome-ignore lint/suspicious/noExplicitAny: <explanation>
    functionToMetadata(conf) {
        // biome-ignore lint/suspicious/noExplicitAny: <explanation>
        const metadata = {};
        const name = Reflect.getMetadata("lancedb::embedding::name", conf.function.constructor);
        metadata["sourceColumn"] = conf.sourceColumn;
        metadata["vectorColumn"] = conf.vectorColumn ?? "vector";
        metadata["name"] = name ?? conf.function.constructor.name;
        metadata["model"] = conf.function.toJSON();
        return metadata;
    }
    getTableMetadata(functions) {
        const metadata = new Map();
        const jsonData = functions.map((conf) => this.functionToMetadata(conf));
        metadata.set("embedding_functions", JSON.stringify(jsonData));
        return metadata;
    }
    /**
     * Set a variable. These can be accessed in the embedding function
     * configuration using the syntax `$var:variable_name`. If they are not
     * set, an error will be thrown letting you know which key is unset. If you
     * want to supply a default value, you can add an additional part in the
     * configuration like so: `$var:variable_name:default_value`. Default values
     * can be used for runtime configurations that are not sensitive, such as
     * whether to use a GPU for inference.
     *
     * The name must not contain colons. The default value can contain colons.
     *
     * @param name
     * @param value
     */
    setVar(name, value) {
        if (name.includes(":")) {
            throw new Error("Variable names cannot contain colons");
        }
        this.#variables.set(name, value);
    }
    /**
     * Get a variable.
     * @param name
     * @returns
     * @see {@link setVar}
     */
    getVar(name) {
        return this.#variables.get(name);
    }
}
exports.EmbeddingFunctionRegistry = EmbeddingFunctionRegistry;
const _REGISTRY = new EmbeddingFunctionRegistry();
function register(name) {
    return _REGISTRY.register(name);
}
/**
 * Utility function to get the global instance of the registry
 * @returns `EmbeddingFunctionRegistry` The global instance of the registry
 * @example
 * ```ts
 * const registry = getRegistry();
 * const openai = registry.get("openai").create();
 */
function getRegistry() {
    return _REGISTRY;
}


/***/ }),
/* 183 */
/***/ (() => {

/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var Reflect;
(function (Reflect) {
    // Metadata Proposal
    // https://rbuckton.github.io/reflect-metadata/
    (function (factory) {
        var root = typeof globalThis === "object" ? globalThis :
            typeof global === "object" ? global :
                typeof self === "object" ? self :
                    typeof this === "object" ? this :
                        sloppyModeThis();
        var exporter = makeExporter(Reflect);
        if (typeof root.Reflect !== "undefined") {
            exporter = makeExporter(root.Reflect, exporter);
        }
        factory(exporter, root);
        if (typeof root.Reflect === "undefined") {
            root.Reflect = Reflect;
        }
        function makeExporter(target, previous) {
            return function (key, value) {
                Object.defineProperty(target, key, { configurable: true, writable: true, value: value });
                if (previous)
                    previous(key, value);
            };
        }
        function functionThis() {
            try {
                return Function("return this;")();
            }
            catch (_) { }
        }
        function indirectEvalThis() {
            try {
                return (void 0, eval)("(function() { return this; })()");
            }
            catch (_) { }
        }
        function sloppyModeThis() {
            return functionThis() || indirectEvalThis();
        }
    })(function (exporter, root) {
        var hasOwn = Object.prototype.hasOwnProperty;
        // feature test for Symbol support
        var supportsSymbol = typeof Symbol === "function";
        var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
        var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
        var supportsCreate = typeof Object.create === "function"; // feature test for Object.create support
        var supportsProto = { __proto__: [] } instanceof Array; // feature test for __proto__ support
        var downLevel = !supportsCreate && !supportsProto;
        var HashMap = {
            // create an object in dictionary mode (a.k.a. "slow" mode in v8)
            create: supportsCreate
                ? function () { return MakeDictionary(Object.create(null)); }
                : supportsProto
                    ? function () { return MakeDictionary({ __proto__: null }); }
                    : function () { return MakeDictionary({}); },
            has: downLevel
                ? function (map, key) { return hasOwn.call(map, key); }
                : function (map, key) { return key in map; },
            get: downLevel
                ? function (map, key) { return hasOwn.call(map, key) ? map[key] : undefined; }
                : function (map, key) { return map[key]; },
        };
        // Load global or shim versions of Map, Set, and WeakMap
        var functionPrototype = Object.getPrototypeOf(Function);
        var _Map = typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
        var _Set = typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
        var _WeakMap = typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
        var registrySymbol = supportsSymbol ? Symbol.for("@reflect-metadata:registry") : undefined;
        var metadataRegistry = GetOrCreateMetadataRegistry();
        var metadataProvider = CreateMetadataProvider(metadataRegistry);
        /**
         * Applies a set of decorators to a property of a target object.
         * @param decorators An array of decorators.
         * @param target The target object.
         * @param propertyKey (Optional) The property key to decorate.
         * @param attributes (Optional) The property descriptor for the target key.
         * @remarks Decorators are applied in reverse order.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Example = Reflect.decorate(decoratorsArray, Example);
         *
         *     // property (on constructor)
         *     Reflect.decorate(decoratorsArray, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.decorate(decoratorsArray, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Object.defineProperty(Example, "staticMethod",
         *         Reflect.decorate(decoratorsArray, Example, "staticMethod",
         *             Object.getOwnPropertyDescriptor(Example, "staticMethod")));
         *
         *     // method (on prototype)
         *     Object.defineProperty(Example.prototype, "method",
         *         Reflect.decorate(decoratorsArray, Example.prototype, "method",
         *             Object.getOwnPropertyDescriptor(Example.prototype, "method")));
         *
         */
        function decorate(decorators, target, propertyKey, attributes) {
            if (!IsUndefined(propertyKey)) {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
                    throw new TypeError();
                if (IsNull(attributes))
                    attributes = undefined;
                propertyKey = ToPropertyKey(propertyKey);
                return DecorateProperty(decorators, target, propertyKey, attributes);
            }
            else {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsConstructor(target))
                    throw new TypeError();
                return DecorateConstructor(decorators, target);
            }
        }
        exporter("decorate", decorate);
        // 4.1.2 Reflect.metadata(metadataKey, metadataValue)
        // https://rbuckton.github.io/reflect-metadata/#reflect.metadata
        /**
         * A default metadata decorator factory that can be used on a class, class member, or parameter.
         * @param metadataKey The key for the metadata entry.
         * @param metadataValue The value for the metadata entry.
         * @returns A decorator function.
         * @remarks
         * If `metadataKey` is already defined for the target and target key, the
         * metadataValue for that key will be overwritten.
         * @example
         *
         *     // constructor
         *     @Reflect.metadata(key, value)
         *     class Example {
         *     }
         *
         *     // property (on constructor, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticProperty;
         *     }
         *
         *     // property (on prototype, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         property;
         *     }
         *
         *     // method (on constructor)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticMethod() { }
         *     }
         *
         *     // method (on prototype)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         method() { }
         *     }
         *
         */
        function metadata(metadataKey, metadataValue) {
            function decorator(target, propertyKey) {
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
                    throw new TypeError();
                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
            }
            return decorator;
        }
        exporter("metadata", metadata);
        /**
         * Define a unique metadata entry on the target.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param metadataValue A value that contains attached metadata.
         * @param target The target object on which to define metadata.
         * @param propertyKey (Optional) The property key for the target.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Reflect.defineMetadata("custom:annotation", options, Example);
         *
         *     // property (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticMethod");
         *
         *     // method (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "method");
         *
         *     // decorator factory as metadata-producing annotation.
         *     function MyAnnotation(options): Decorator {
         *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);
         *     }
         *
         */
        function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        exporter("defineMetadata", defineMetadata);
        /**
         * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasMetadata", hasMetadata);
        /**
         * Gets a value indicating whether the target object has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasOwnMetadata", hasOwnMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetMetadata(metadataKey, target, propertyKey);
        }
        exporter("getMetadata", getMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("getOwnMetadata", getOwnMetadata);
        /**
         * Gets the metadata keys defined on the target object or its prototype chain.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "method");
         *
         */
        function getMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryMetadataKeys(target, propertyKey);
        }
        exporter("getMetadataKeys", getMetadataKeys);
        /**
         * Gets the unique metadata keys defined on the target object.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "method");
         *
         */
        function getOwnMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryOwnMetadataKeys(target, propertyKey);
        }
        exporter("getOwnMetadataKeys", getOwnMetadataKeys);
        /**
         * Deletes the metadata entry from the target object with the provided key.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata entry was found and deleted; otherwise, false.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.deleteMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function deleteMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            var provider = GetMetadataProvider(target, propertyKey, /*Create*/ false);
            if (IsUndefined(provider))
                return false;
            return provider.OrdinaryDeleteMetadata(metadataKey, target, propertyKey);
        }
        exporter("deleteMetadata", deleteMetadata);
        function DecorateConstructor(decorators, target) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsConstructor(decorated))
                        throw new TypeError();
                    target = decorated;
                }
            }
            return target;
        }
        function DecorateProperty(decorators, target, propertyKey, descriptor) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target, propertyKey, descriptor);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsObject(decorated))
                        throw new TypeError();
                    descriptor = decorated;
                }
            }
            return descriptor;
        }
        // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata
        function OrdinaryHasMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return true;
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryHasMetadata(MetadataKey, parent, P);
            return false;
        }
        // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata
        function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
            var provider = GetMetadataProvider(O, P, /*Create*/ false);
            if (IsUndefined(provider))
                return false;
            return ToBoolean(provider.OrdinaryHasOwnMetadata(MetadataKey, O, P));
        }
        // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata
        function OrdinaryGetMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return OrdinaryGetOwnMetadata(MetadataKey, O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryGetMetadata(MetadataKey, parent, P);
            return undefined;
        }
        // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata
        function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
            var provider = GetMetadataProvider(O, P, /*Create*/ false);
            if (IsUndefined(provider))
                return;
            return provider.OrdinaryGetOwnMetadata(MetadataKey, O, P);
        }
        // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata
        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
            var provider = GetMetadataProvider(O, P, /*Create*/ true);
            provider.OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P);
        }
        // 3.1.6.1 OrdinaryMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys
        function OrdinaryMetadataKeys(O, P) {
            var ownKeys = OrdinaryOwnMetadataKeys(O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (parent === null)
                return ownKeys;
            var parentKeys = OrdinaryMetadataKeys(parent, P);
            if (parentKeys.length <= 0)
                return ownKeys;
            if (ownKeys.length <= 0)
                return parentKeys;
            var set = new _Set();
            var keys = [];
            for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
                var key = ownKeys_1[_i];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
                var key = parentKeys_1[_a];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            return keys;
        }
        // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys
        function OrdinaryOwnMetadataKeys(O, P) {
            var provider = GetMetadataProvider(O, P, /*create*/ false);
            if (!provider) {
                return [];
            }
            return provider.OrdinaryOwnMetadataKeys(O, P);
        }
        // 6 ECMAScript Data Types and Values
        // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values
        function Type(x) {
            if (x === null)
                return 1 /* Null */;
            switch (typeof x) {
                case "undefined": return 0 /* Undefined */;
                case "boolean": return 2 /* Boolean */;
                case "string": return 3 /* String */;
                case "symbol": return 4 /* Symbol */;
                case "number": return 5 /* Number */;
                case "object": return x === null ? 1 /* Null */ : 6 /* Object */;
                default: return 6 /* Object */;
            }
        }
        // 6.1.1 The Undefined Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type
        function IsUndefined(x) {
            return x === undefined;
        }
        // 6.1.2 The Null Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type
        function IsNull(x) {
            return x === null;
        }
        // 6.1.5 The Symbol Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type
        function IsSymbol(x) {
            return typeof x === "symbol";
        }
        // 6.1.7 The Object Type
        // https://tc39.github.io/ecma262/#sec-object-type
        function IsObject(x) {
            return typeof x === "object" ? x !== null : typeof x === "function";
        }
        // 7.1 Type Conversion
        // https://tc39.github.io/ecma262/#sec-type-conversion
        // 7.1.1 ToPrimitive(input [, PreferredType])
        // https://tc39.github.io/ecma262/#sec-toprimitive
        function ToPrimitive(input, PreferredType) {
            switch (Type(input)) {
                case 0 /* Undefined */: return input;
                case 1 /* Null */: return input;
                case 2 /* Boolean */: return input;
                case 3 /* String */: return input;
                case 4 /* Symbol */: return input;
                case 5 /* Number */: return input;
            }
            var hint = PreferredType === 3 /* String */ ? "string" : PreferredType === 5 /* Number */ ? "number" : "default";
            var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
            if (exoticToPrim !== undefined) {
                var result = exoticToPrim.call(input, hint);
                if (IsObject(result))
                    throw new TypeError();
                return result;
            }
            return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
        }
        // 7.1.1.1 OrdinaryToPrimitive(O, hint)
        // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive
        function OrdinaryToPrimitive(O, hint) {
            if (hint === "string") {
                var toString_1 = O.toString;
                if (IsCallable(toString_1)) {
                    var result = toString_1.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            else {
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var toString_2 = O.toString;
                if (IsCallable(toString_2)) {
                    var result = toString_2.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            throw new TypeError();
        }
        // 7.1.2 ToBoolean(argument)
        // https://tc39.github.io/ecma262/2016/#sec-toboolean
        function ToBoolean(argument) {
            return !!argument;
        }
        // 7.1.12 ToString(argument)
        // https://tc39.github.io/ecma262/#sec-tostring
        function ToString(argument) {
            return "" + argument;
        }
        // 7.1.14 ToPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-topropertykey
        function ToPropertyKey(argument) {
            var key = ToPrimitive(argument, 3 /* String */);
            if (IsSymbol(key))
                return key;
            return ToString(key);
        }
        // 7.2 Testing and Comparison Operations
        // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations
        // 7.2.2 IsArray(argument)
        // https://tc39.github.io/ecma262/#sec-isarray
        function IsArray(argument) {
            return Array.isArray
                ? Array.isArray(argument)
                : argument instanceof Object
                    ? argument instanceof Array
                    : Object.prototype.toString.call(argument) === "[object Array]";
        }
        // 7.2.3 IsCallable(argument)
        // https://tc39.github.io/ecma262/#sec-iscallable
        function IsCallable(argument) {
            // NOTE: This is an approximation as we cannot check for [[Call]] internal method.
            return typeof argument === "function";
        }
        // 7.2.4 IsConstructor(argument)
        // https://tc39.github.io/ecma262/#sec-isconstructor
        function IsConstructor(argument) {
            // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.
            return typeof argument === "function";
        }
        // 7.2.7 IsPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-ispropertykey
        function IsPropertyKey(argument) {
            switch (Type(argument)) {
                case 3 /* String */: return true;
                case 4 /* Symbol */: return true;
                default: return false;
            }
        }
        function SameValueZero(x, y) {
            return x === y || x !== x && y !== y;
        }
        // 7.3 Operations on Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-objects
        // 7.3.9 GetMethod(V, P)
        // https://tc39.github.io/ecma262/#sec-getmethod
        function GetMethod(V, P) {
            var func = V[P];
            if (func === undefined || func === null)
                return undefined;
            if (!IsCallable(func))
                throw new TypeError();
            return func;
        }
        // 7.4 Operations on Iterator Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects
        function GetIterator(obj) {
            var method = GetMethod(obj, iteratorSymbol);
            if (!IsCallable(method))
                throw new TypeError(); // from Call
            var iterator = method.call(obj);
            if (!IsObject(iterator))
                throw new TypeError();
            return iterator;
        }
        // 7.4.4 IteratorValue(iterResult)
        // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue
        function IteratorValue(iterResult) {
            return iterResult.value;
        }
        // 7.4.5 IteratorStep(iterator)
        // https://tc39.github.io/ecma262/#sec-iteratorstep
        function IteratorStep(iterator) {
            var result = iterator.next();
            return result.done ? false : result;
        }
        // 7.4.6 IteratorClose(iterator, completion)
        // https://tc39.github.io/ecma262/#sec-iteratorclose
        function IteratorClose(iterator) {
            var f = iterator["return"];
            if (f)
                f.call(iterator);
        }
        // 9.1 Ordinary Object Internal Methods and Internal Slots
        // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots
        // 9.1.1.1 OrdinaryGetPrototypeOf(O)
        // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof
        function OrdinaryGetPrototypeOf(O) {
            var proto = Object.getPrototypeOf(O);
            if (typeof O !== "function" || O === functionPrototype)
                return proto;
            // TypeScript doesn't set __proto__ in ES5, as it's non-standard.
            // Try to determine the superclass constructor. Compatible implementations
            // must either set __proto__ on a subclass constructor to the superclass constructor,
            // or ensure each class has a valid `constructor` property on its prototype that
            // points back to the constructor.
            // If this is not the same as Function.[[Prototype]], then this is definately inherited.
            // This is the case when in ES6 or when using __proto__ in a compatible browser.
            if (proto !== functionPrototype)
                return proto;
            // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.
            var prototype = O.prototype;
            var prototypeProto = prototype && Object.getPrototypeOf(prototype);
            if (prototypeProto == null || prototypeProto === Object.prototype)
                return proto;
            // If the constructor was not a function, then we cannot determine the heritage.
            var constructor = prototypeProto.constructor;
            if (typeof constructor !== "function")
                return proto;
            // If we have some kind of self-reference, then we cannot determine the heritage.
            if (constructor === O)
                return proto;
            // we have a pretty good guess at the heritage.
            return constructor;
        }
        // Global metadata registry
        // - Allows `import "reflect-metadata"` and `import "reflect-metadata/no-conflict"` to interoperate.
        // - Uses isolated metadata if `Reflect` is frozen before the registry can be installed.
        /**
         * Creates a registry used to allow multiple `reflect-metadata` providers.
         */
        function CreateMetadataRegistry() {
            var fallback;
            if (!IsUndefined(registrySymbol) &&
                typeof root.Reflect !== "undefined" &&
                !(registrySymbol in root.Reflect) &&
                typeof root.Reflect.defineMetadata === "function") {
                // interoperate with older version of `reflect-metadata` that did not support a registry.
                fallback = CreateFallbackProvider(root.Reflect);
            }
            var first;
            var second;
            var rest;
            var targetProviderMap = new _WeakMap();
            var registry = {
                registerProvider: registerProvider,
                getProvider: getProvider,
                setProvider: setProvider,
            };
            return registry;
            function registerProvider(provider) {
                if (!Object.isExtensible(registry)) {
                    throw new Error("Cannot add provider to a frozen registry.");
                }
                switch (true) {
                    case fallback === provider: break;
                    case IsUndefined(first):
                        first = provider;
                        break;
                    case first === provider: break;
                    case IsUndefined(second):
                        second = provider;
                        break;
                    case second === provider: break;
                    default:
                        if (rest === undefined)
                            rest = new _Set();
                        rest.add(provider);
                        break;
                }
            }
            function getProviderNoCache(O, P) {
                if (!IsUndefined(first)) {
                    if (first.isProviderFor(O, P))
                        return first;
                    if (!IsUndefined(second)) {
                        if (second.isProviderFor(O, P))
                            return first;
                        if (!IsUndefined(rest)) {
                            var iterator = GetIterator(rest);
                            while (true) {
                                var next = IteratorStep(iterator);
                                if (!next) {
                                    return undefined;
                                }
                                var provider = IteratorValue(next);
                                if (provider.isProviderFor(O, P)) {
                                    IteratorClose(iterator);
                                    return provider;
                                }
                            }
                        }
                    }
                }
                if (!IsUndefined(fallback) && fallback.isProviderFor(O, P)) {
                    return fallback;
                }
                return undefined;
            }
            function getProvider(O, P) {
                var providerMap = targetProviderMap.get(O);
                var provider;
                if (!IsUndefined(providerMap)) {
                    provider = providerMap.get(P);
                }
                if (!IsUndefined(provider)) {
                    return provider;
                }
                provider = getProviderNoCache(O, P);
                if (!IsUndefined(provider)) {
                    if (IsUndefined(providerMap)) {
                        providerMap = new _Map();
                        targetProviderMap.set(O, providerMap);
                    }
                    providerMap.set(P, provider);
                }
                return provider;
            }
            function hasProvider(provider) {
                if (IsUndefined(provider))
                    throw new TypeError();
                return first === provider || second === provider || !IsUndefined(rest) && rest.has(provider);
            }
            function setProvider(O, P, provider) {
                if (!hasProvider(provider)) {
                    throw new Error("Metadata provider not registered.");
                }
                var existingProvider = getProvider(O, P);
                if (existingProvider !== provider) {
                    if (!IsUndefined(existingProvider)) {
                        return false;
                    }
                    var providerMap = targetProviderMap.get(O);
                    if (IsUndefined(providerMap)) {
                        providerMap = new _Map();
                        targetProviderMap.set(O, providerMap);
                    }
                    providerMap.set(P, provider);
                }
                return true;
            }
        }
        /**
         * Gets or creates the shared registry of metadata providers.
         */
        function GetOrCreateMetadataRegistry() {
            var metadataRegistry;
            if (!IsUndefined(registrySymbol) && IsObject(root.Reflect) && Object.isExtensible(root.Reflect)) {
                metadataRegistry = root.Reflect[registrySymbol];
            }
            if (IsUndefined(metadataRegistry)) {
                metadataRegistry = CreateMetadataRegistry();
            }
            if (!IsUndefined(registrySymbol) && IsObject(root.Reflect) && Object.isExtensible(root.Reflect)) {
                Object.defineProperty(root.Reflect, registrySymbol, {
                    enumerable: false,
                    configurable: false,
                    writable: false,
                    value: metadataRegistry
                });
            }
            return metadataRegistry;
        }
        function CreateMetadataProvider(registry) {
            // [[Metadata]] internal slot
            // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots
            var metadata = new _WeakMap();
            var provider = {
                isProviderFor: function (O, P) {
                    var targetMetadata = metadata.get(O);
                    if (IsUndefined(targetMetadata))
                        return false;
                    return targetMetadata.has(P);
                },
                OrdinaryDefineOwnMetadata: OrdinaryDefineOwnMetadata,
                OrdinaryHasOwnMetadata: OrdinaryHasOwnMetadata,
                OrdinaryGetOwnMetadata: OrdinaryGetOwnMetadata,
                OrdinaryOwnMetadataKeys: OrdinaryOwnMetadataKeys,
                OrdinaryDeleteMetadata: OrdinaryDeleteMetadata,
            };
            metadataRegistry.registerProvider(provider);
            return provider;
            function GetOrCreateMetadataMap(O, P, Create) {
                var targetMetadata = metadata.get(O);
                var createdTargetMetadata = false;
                if (IsUndefined(targetMetadata)) {
                    if (!Create)
                        return undefined;
                    targetMetadata = new _Map();
                    metadata.set(O, targetMetadata);
                    createdTargetMetadata = true;
                }
                var metadataMap = targetMetadata.get(P);
                if (IsUndefined(metadataMap)) {
                    if (!Create)
                        return undefined;
                    metadataMap = new _Map();
                    targetMetadata.set(P, metadataMap);
                    if (!registry.setProvider(O, P, provider)) {
                        targetMetadata.delete(P);
                        if (createdTargetMetadata) {
                            metadata.delete(O);
                        }
                        throw new Error("Wrong provider for target.");
                    }
                }
                return metadataMap;
            }
            // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)
            // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata
            function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
                var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
                if (IsUndefined(metadataMap))
                    return false;
                return ToBoolean(metadataMap.has(MetadataKey));
            }
            // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)
            // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata
            function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
                var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
                if (IsUndefined(metadataMap))
                    return undefined;
                return metadataMap.get(MetadataKey);
            }
            // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)
            // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata
            function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
                var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ true);
                metadataMap.set(MetadataKey, MetadataValue);
            }
            // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)
            // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys
            function OrdinaryOwnMetadataKeys(O, P) {
                var keys = [];
                var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
                if (IsUndefined(metadataMap))
                    return keys;
                var keysObj = metadataMap.keys();
                var iterator = GetIterator(keysObj);
                var k = 0;
                while (true) {
                    var next = IteratorStep(iterator);
                    if (!next) {
                        keys.length = k;
                        return keys;
                    }
                    var nextValue = IteratorValue(next);
                    try {
                        keys[k] = nextValue;
                    }
                    catch (e) {
                        try {
                            IteratorClose(iterator);
                        }
                        finally {
                            throw e;
                        }
                    }
                    k++;
                }
            }
            function OrdinaryDeleteMetadata(MetadataKey, O, P) {
                var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
                if (IsUndefined(metadataMap))
                    return false;
                if (!metadataMap.delete(MetadataKey))
                    return false;
                if (metadataMap.size === 0) {
                    var targetMetadata = metadata.get(O);
                    if (!IsUndefined(targetMetadata)) {
                        targetMetadata.delete(P);
                        if (targetMetadata.size === 0) {
                            metadata.delete(targetMetadata);
                        }
                    }
                }
                return true;
            }
        }
        function CreateFallbackProvider(reflect) {
            var defineMetadata = reflect.defineMetadata, hasOwnMetadata = reflect.hasOwnMetadata, getOwnMetadata = reflect.getOwnMetadata, getOwnMetadataKeys = reflect.getOwnMetadataKeys, deleteMetadata = reflect.deleteMetadata;
            var metadataOwner = new _WeakMap();
            var provider = {
                isProviderFor: function (O, P) {
                    var metadataPropertySet = metadataOwner.get(O);
                    if (!IsUndefined(metadataPropertySet) && metadataPropertySet.has(P)) {
                        return true;
                    }
                    if (getOwnMetadataKeys(O, P).length) {
                        if (IsUndefined(metadataPropertySet)) {
                            metadataPropertySet = new _Set();
                            metadataOwner.set(O, metadataPropertySet);
                        }
                        metadataPropertySet.add(P);
                        return true;
                    }
                    return false;
                },
                OrdinaryDefineOwnMetadata: defineMetadata,
                OrdinaryHasOwnMetadata: hasOwnMetadata,
                OrdinaryGetOwnMetadata: getOwnMetadata,
                OrdinaryOwnMetadataKeys: getOwnMetadataKeys,
                OrdinaryDeleteMetadata: deleteMetadata,
            };
            return provider;
        }
        /**
         * Gets the metadata provider for an object. If the object has no metadata provider and this is for a create operation,
         * then this module's metadata provider is assigned to the object.
         */
        function GetMetadataProvider(O, P, Create) {
            var registeredProvider = metadataRegistry.getProvider(O, P);
            if (!IsUndefined(registeredProvider)) {
                return registeredProvider;
            }
            if (Create) {
                if (metadataRegistry.setProvider(O, P, metadataProvider)) {
                    return metadataProvider;
                }
                throw new Error("Illegal state.");
            }
            return undefined;
        }
        // naive Map shim
        function CreateMapPolyfill() {
            var cacheSentinel = {};
            var arraySentinel = [];
            var MapIterator = /** @class */ (function () {
                function MapIterator(keys, values, selector) {
                    this._index = 0;
                    this._keys = keys;
                    this._values = values;
                    this._selector = selector;
                }
                MapIterator.prototype["@@iterator"] = function () { return this; };
                MapIterator.prototype[iteratorSymbol] = function () { return this; };
                MapIterator.prototype.next = function () {
                    var index = this._index;
                    if (index >= 0 && index < this._keys.length) {
                        var result = this._selector(this._keys[index], this._values[index]);
                        if (index + 1 >= this._keys.length) {
                            this._index = -1;
                            this._keys = arraySentinel;
                            this._values = arraySentinel;
                        }
                        else {
                            this._index++;
                        }
                        return { value: result, done: false };
                    }
                    return { value: undefined, done: true };
                };
                MapIterator.prototype.throw = function (error) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    throw error;
                };
                MapIterator.prototype.return = function (value) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    return { value: value, done: true };
                };
                return MapIterator;
            }());
            var Map = /** @class */ (function () {
                function Map() {
                    this._keys = [];
                    this._values = [];
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                }
                Object.defineProperty(Map.prototype, "size", {
                    get: function () { return this._keys.length; },
                    enumerable: true,
                    configurable: true
                });
                Map.prototype.has = function (key) { return this._find(key, /*insert*/ false) >= 0; };
                Map.prototype.get = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    return index >= 0 ? this._values[index] : undefined;
                };
                Map.prototype.set = function (key, value) {
                    var index = this._find(key, /*insert*/ true);
                    this._values[index] = value;
                    return this;
                };
                Map.prototype.delete = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    if (index >= 0) {
                        var size = this._keys.length;
                        for (var i = index + 1; i < size; i++) {
                            this._keys[i - 1] = this._keys[i];
                            this._values[i - 1] = this._values[i];
                        }
                        this._keys.length--;
                        this._values.length--;
                        if (SameValueZero(key, this._cacheKey)) {
                            this._cacheKey = cacheSentinel;
                            this._cacheIndex = -2;
                        }
                        return true;
                    }
                    return false;
                };
                Map.prototype.clear = function () {
                    this._keys.length = 0;
                    this._values.length = 0;
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                };
                Map.prototype.keys = function () { return new MapIterator(this._keys, this._values, getKey); };
                Map.prototype.values = function () { return new MapIterator(this._keys, this._values, getValue); };
                Map.prototype.entries = function () { return new MapIterator(this._keys, this._values, getEntry); };
                Map.prototype["@@iterator"] = function () { return this.entries(); };
                Map.prototype[iteratorSymbol] = function () { return this.entries(); };
                Map.prototype._find = function (key, insert) {
                    if (!SameValueZero(this._cacheKey, key)) {
                        this._cacheIndex = -1;
                        for (var i = 0; i < this._keys.length; i++) {
                            if (SameValueZero(this._keys[i], key)) {
                                this._cacheIndex = i;
                                break;
                            }
                        }
                    }
                    if (this._cacheIndex < 0 && insert) {
                        this._cacheIndex = this._keys.length;
                        this._keys.push(key);
                        this._values.push(undefined);
                    }
                    return this._cacheIndex;
                };
                return Map;
            }());
            return Map;
            function getKey(key, _) {
                return key;
            }
            function getValue(_, value) {
                return value;
            }
            function getEntry(key, value) {
                return [key, value];
            }
        }
        // naive Set shim
        function CreateSetPolyfill() {
            var Set = /** @class */ (function () {
                function Set() {
                    this._map = new _Map();
                }
                Object.defineProperty(Set.prototype, "size", {
                    get: function () { return this._map.size; },
                    enumerable: true,
                    configurable: true
                });
                Set.prototype.has = function (value) { return this._map.has(value); };
                Set.prototype.add = function (value) { return this._map.set(value, value), this; };
                Set.prototype.delete = function (value) { return this._map.delete(value); };
                Set.prototype.clear = function () { this._map.clear(); };
                Set.prototype.keys = function () { return this._map.keys(); };
                Set.prototype.values = function () { return this._map.keys(); };
                Set.prototype.entries = function () { return this._map.entries(); };
                Set.prototype["@@iterator"] = function () { return this.keys(); };
                Set.prototype[iteratorSymbol] = function () { return this.keys(); };
                return Set;
            }());
            return Set;
        }
        // naive WeakMap shim
        function CreateWeakMapPolyfill() {
            var UUID_SIZE = 16;
            var keys = HashMap.create();
            var rootKey = CreateUniqueKey();
            return /** @class */ (function () {
                function WeakMap() {
                    this._key = CreateUniqueKey();
                }
                WeakMap.prototype.has = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.has(table, this._key) : false;
                };
                WeakMap.prototype.get = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.get(table, this._key) : undefined;
                };
                WeakMap.prototype.set = function (target, value) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ true);
                    table[this._key] = value;
                    return this;
                };
                WeakMap.prototype.delete = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? delete table[this._key] : false;
                };
                WeakMap.prototype.clear = function () {
                    // NOTE: not a real clear, just makes the previous data unreachable
                    this._key = CreateUniqueKey();
                };
                return WeakMap;
            }());
            function CreateUniqueKey() {
                var key;
                do
                    key = "@@WeakMap@@" + CreateUUID();
                while (HashMap.has(keys, key));
                keys[key] = true;
                return key;
            }
            function GetOrCreateWeakMapTable(target, create) {
                if (!hasOwn.call(target, rootKey)) {
                    if (!create)
                        return undefined;
                    Object.defineProperty(target, rootKey, { value: HashMap.create() });
                }
                return target[rootKey];
            }
            function FillRandomBytes(buffer, size) {
                for (var i = 0; i < size; ++i)
                    buffer[i] = Math.random() * 0xff | 0;
                return buffer;
            }
            function GenRandomBytes(size) {
                if (typeof Uint8Array === "function") {
                    var array = new Uint8Array(size);
                    if (typeof crypto !== "undefined") {
                        crypto.getRandomValues(array);
                    }
                    else if (typeof msCrypto !== "undefined") {
                        msCrypto.getRandomValues(array);
                    }
                    else {
                        FillRandomBytes(array, size);
                    }
                    return array;
                }
                return FillRandomBytes(new Array(size), size);
            }
            function CreateUUID() {
                var data = GenRandomBytes(UUID_SIZE);
                // mark as random - RFC 4122 Â§ 4.4
                data[6] = data[6] & 0x4f | 0x40;
                data[8] = data[8] & 0xbf | 0x80;
                var result = "";
                for (var offset = 0; offset < UUID_SIZE; ++offset) {
                    var byte = data[offset];
                    if (offset === 4 || offset === 6 || offset === 8)
                        result += "-";
                    if (byte < 16)
                        result += "0";
                    result += byte.toString(16).toLowerCase();
                }
                return result;
            }
        }
        // uses a heuristic used by v8 and chakra to force an object into dictionary mode.
        function MakeDictionary(obj) {
            obj.__ = undefined;
            delete obj.__;
            return obj;
        }
    });
})(Reflect || (Reflect = {}));


/***/ }),
/* 184 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// SPDX-License-Identifier: Apache-2.0
// SPDX-FileCopyrightText: Copyright The LanceDB Authors
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sanitizeMetadata = sanitizeMetadata;
exports.sanitizeInt = sanitizeInt;
exports.sanitizeFloat = sanitizeFloat;
exports.sanitizeDecimal = sanitizeDecimal;
exports.sanitizeDate = sanitizeDate;
exports.sanitizeTime = sanitizeTime;
exports.sanitizeTimestamp = sanitizeTimestamp;
exports.sanitizeTypedTimestamp = sanitizeTypedTimestamp;
exports.sanitizeInterval = sanitizeInterval;
exports.sanitizeList = sanitizeList;
exports.sanitizeStruct = sanitizeStruct;
exports.sanitizeUnion = sanitizeUnion;
exports.sanitizeTypedUnion = sanitizeTypedUnion;
exports.sanitizeFixedSizeBinary = sanitizeFixedSizeBinary;
exports.sanitizeFixedSizeList = sanitizeFixedSizeList;
exports.sanitizeMap = sanitizeMap;
exports.sanitizeDuration = sanitizeDuration;
exports.sanitizeDictionary = sanitizeDictionary;
exports.sanitizeType = sanitizeType;
exports.sanitizeField = sanitizeField;
exports.sanitizeSchema = sanitizeSchema;
exports.sanitizeTable = sanitizeTable;
exports.dataTypeFromName = dataTypeFromName;
// The utilities in this file help sanitize data from the user's arrow
// library into the types expected by vectordb's arrow library.  Node
// generally allows for mulitple versions of the same library (and sometimes
// even multiple copies of the same version) to be installed at the same
// time.  However, arrow-js uses instanceof which expected that the input
// comes from the exact same library instance.  This is not always the case
// and so we must sanitize the input to ensure that it is compatible.
const apache_arrow_1 = __webpack_require__(40);
const arrow_1 = __webpack_require__(39);
function sanitizeMetadata(metadataLike) {
    if (metadataLike === undefined || metadataLike === null) {
        return undefined;
    }
    if (!(metadataLike instanceof Map)) {
        throw Error("Expected metadata, if present, to be a Map<string, string>");
    }
    for (const item of metadataLike) {
        if (!(typeof item[0] === "string" || !(typeof item[1] === "string"))) {
            throw Error("Expected metadata, if present, to be a Map<string, string> but it had non-string keys or values");
        }
    }
    return metadataLike;
}
function sanitizeInt(typeLike) {
    if (!("bitWidth" in typeLike) ||
        typeof typeLike.bitWidth !== "number" ||
        !("isSigned" in typeLike) ||
        typeof typeLike.isSigned !== "boolean") {
        throw Error("Expected an Int Type to have a `bitWidth` and `isSigned` property");
    }
    return new arrow_1.Int(typeLike.isSigned, typeLike.bitWidth);
}
function sanitizeFloat(typeLike) {
    if (!("precision" in typeLike) || typeof typeLike.precision !== "number") {
        throw Error("Expected a Float Type to have a `precision` property");
    }
    return new arrow_1.Float(typeLike.precision);
}
function sanitizeDecimal(typeLike) {
    if (!("scale" in typeLike) ||
        typeof typeLike.scale !== "number" ||
        !("precision" in typeLike) ||
        typeof typeLike.precision !== "number" ||
        !("bitWidth" in typeLike) ||
        typeof typeLike.bitWidth !== "number") {
        throw Error("Expected a Decimal Type to have `scale`, `precision`, and `bitWidth` properties");
    }
    return new arrow_1.Decimal(typeLike.scale, typeLike.precision, typeLike.bitWidth);
}
function sanitizeDate(typeLike) {
    if (!("unit" in typeLike) || typeof typeLike.unit !== "number") {
        throw Error("Expected a Date type to have a `unit` property");
    }
    return new arrow_1.Date_(typeLike.unit);
}
function sanitizeTime(typeLike) {
    if (!("unit" in typeLike) ||
        typeof typeLike.unit !== "number" ||
        !("bitWidth" in typeLike) ||
        typeof typeLike.bitWidth !== "number") {
        throw Error("Expected a Time type to have `unit` and `bitWidth` properties");
    }
    return new arrow_1.Time(typeLike.unit, typeLike.bitWidth);
}
function sanitizeTimestamp(typeLike) {
    if (!("unit" in typeLike) || typeof typeLike.unit !== "number") {
        throw Error("Expected a Timestamp type to have a `unit` property");
    }
    let timezone = null;
    if ("timezone" in typeLike && typeof typeLike.timezone === "string") {
        timezone = typeLike.timezone;
    }
    return new arrow_1.Timestamp(typeLike.unit, timezone);
}
function sanitizeTypedTimestamp(typeLike, 
// eslint-disable-next-line @typescript-eslint/naming-convention
Datatype) {
    let timezone = null;
    if ("timezone" in typeLike && typeof typeLike.timezone === "string") {
        timezone = typeLike.timezone;
    }
    return new Datatype(timezone);
}
function sanitizeInterval(typeLike) {
    if (!("unit" in typeLike) || typeof typeLike.unit !== "number") {
        throw Error("Expected an Interval type to have a `unit` property");
    }
    return new arrow_1.Interval(typeLike.unit);
}
function sanitizeList(typeLike) {
    if (!("children" in typeLike) || !Array.isArray(typeLike.children)) {
        throw Error("Expected a List type to have an array-like `children` property");
    }
    if (typeLike.children.length !== 1) {
        throw Error("Expected a List type to have exactly one child");
    }
    return new arrow_1.List(sanitizeField(typeLike.children[0]));
}
function sanitizeStruct(typeLike) {
    if (!("children" in typeLike) || !Array.isArray(typeLike.children)) {
        throw Error("Expected a Struct type to have an array-like `children` property");
    }
    return new arrow_1.Struct(typeLike.children.map((child) => sanitizeField(child)));
}
function sanitizeUnion(typeLike) {
    if (!("typeIds" in typeLike) ||
        !("mode" in typeLike) ||
        typeof typeLike.mode !== "number") {
        throw Error("Expected a Union type to have `typeIds` and `mode` properties");
    }
    if (!("children" in typeLike) || !Array.isArray(typeLike.children)) {
        throw Error("Expected a Union type to have an array-like `children` property");
    }
    return new arrow_1.Union(typeLike.mode, 
    // biome-ignore lint/suspicious/noExplicitAny: skip
    typeLike.typeIds, typeLike.children.map((child) => sanitizeField(child)));
}
function sanitizeTypedUnion(typeLike, 
// eslint-disable-next-line @typescript-eslint/naming-convention
UnionType) {
    if (!("typeIds" in typeLike)) {
        throw Error("Expected a DenseUnion/SparseUnion type to have a `typeIds` property");
    }
    if (!("children" in typeLike) || !Array.isArray(typeLike.children)) {
        throw Error("Expected a DenseUnion/SparseUnion type to have an array-like `children` property");
    }
    return new UnionType(typeLike.typeIds, typeLike.children.map((child) => sanitizeField(child)));
}
function sanitizeFixedSizeBinary(typeLike) {
    if (!("byteWidth" in typeLike) || typeof typeLike.byteWidth !== "number") {
        throw Error("Expected a FixedSizeBinary type to have a `byteWidth` property");
    }
    return new arrow_1.FixedSizeBinary(typeLike.byteWidth);
}
function sanitizeFixedSizeList(typeLike) {
    if (!("listSize" in typeLike) || typeof typeLike.listSize !== "number") {
        throw Error("Expected a FixedSizeList type to have a `listSize` property");
    }
    if (!("children" in typeLike) || !Array.isArray(typeLike.children)) {
        throw Error("Expected a FixedSizeList type to have an array-like `children` property");
    }
    if (typeLike.children.length !== 1) {
        throw Error("Expected a FixedSizeList type to have exactly one child");
    }
    return new arrow_1.FixedSizeList(typeLike.listSize, sanitizeField(typeLike.children[0]));
}
function sanitizeMap(typeLike) {
    if (!("children" in typeLike) || !Array.isArray(typeLike.children)) {
        throw Error("Expected a Map type to have an array-like `children` property");
    }
    if (!("keysSorted" in typeLike) || typeof typeLike.keysSorted !== "boolean") {
        throw Error("Expected a Map type to have a `keysSorted` property");
    }
    return new arrow_1.Map_(
    // biome-ignore lint/suspicious/noExplicitAny: skip
    typeLike.children.map((field) => sanitizeField(field)), typeLike.keysSorted);
}
function sanitizeDuration(typeLike) {
    if (!("unit" in typeLike) || typeof typeLike.unit !== "number") {
        throw Error("Expected a Duration type to have a `unit` property");
    }
    return new arrow_1.Duration(typeLike.unit);
}
function sanitizeDictionary(typeLike) {
    if (!("id" in typeLike) || typeof typeLike.id !== "number") {
        throw Error("Expected a Dictionary type to have an `id` property");
    }
    if (!("indices" in typeLike) || typeof typeLike.indices !== "object") {
        throw Error("Expected a Dictionary type to have an `indices` property");
    }
    if (!("dictionary" in typeLike) || typeof typeLike.dictionary !== "object") {
        throw Error("Expected a Dictionary type to have an `dictionary` property");
    }
    if (!("isOrdered" in typeLike) || typeof typeLike.isOrdered !== "boolean") {
        throw Error("Expected a Dictionary type to have an `isOrdered` property");
    }
    return new arrow_1.Dictionary(sanitizeType(typeLike.dictionary), sanitizeType(typeLike.indices), typeLike.id, typeLike.isOrdered);
}
// biome-ignore lint/suspicious/noExplicitAny: skip
function sanitizeType(typeLike) {
    if (typeof typeLike === "string") {
        return dataTypeFromName(typeLike);
    }
    if (typeof typeLike !== "object" || typeLike === null) {
        throw Error("Expected a Type but object was null/undefined");
    }
    if (!("typeId" in typeLike) ||
        !(typeof typeLike.typeId !== "function" ||
            typeof typeLike.typeId !== "number")) {
        throw Error("Expected a Type to have a typeId property");
    }
    let typeId;
    if (typeof typeLike.typeId === "function") {
        typeId = typeLike.typeId();
    }
    else if (typeof typeLike.typeId === "number") {
        typeId = typeLike.typeId;
    }
    else {
        throw Error("Type's typeId property was not a function or number");
    }
    switch (typeId) {
        case arrow_1.Type.NONE:
            throw Error("Received a Type with a typeId of NONE");
        case arrow_1.Type.Null:
            return new arrow_1.Null();
        case arrow_1.Type.Int:
            return sanitizeInt(typeLike);
        case arrow_1.Type.Float:
            return sanitizeFloat(typeLike);
        case arrow_1.Type.Binary:
            return new arrow_1.Binary();
        case arrow_1.Type.Utf8:
            return new arrow_1.Utf8();
        case arrow_1.Type.Bool:
            return new arrow_1.Bool();
        case arrow_1.Type.Decimal:
            return sanitizeDecimal(typeLike);
        case arrow_1.Type.Date:
            return sanitizeDate(typeLike);
        case arrow_1.Type.Time:
            return sanitizeTime(typeLike);
        case arrow_1.Type.Timestamp:
            return sanitizeTimestamp(typeLike);
        case arrow_1.Type.Interval:
            return sanitizeInterval(typeLike);
        case arrow_1.Type.List:
            return sanitizeList(typeLike);
        case arrow_1.Type.Struct:
            return sanitizeStruct(typeLike);
        case arrow_1.Type.Union:
            return sanitizeUnion(typeLike);
        case arrow_1.Type.FixedSizeBinary:
            return sanitizeFixedSizeBinary(typeLike);
        case arrow_1.Type.FixedSizeList:
            return sanitizeFixedSizeList(typeLike);
        case arrow_1.Type.Map:
            return sanitizeMap(typeLike);
        case arrow_1.Type.Duration:
            return sanitizeDuration(typeLike);
        case arrow_1.Type.Dictionary:
            return sanitizeDictionary(typeLike);
        case arrow_1.Type.Int8:
            return new arrow_1.Int8();
        case arrow_1.Type.Int16:
            return new arrow_1.Int16();
        case arrow_1.Type.Int32:
            return new arrow_1.Int32();
        case arrow_1.Type.Int64:
            return new arrow_1.Int64();
        case arrow_1.Type.Uint8:
            return new arrow_1.Uint8();
        case arrow_1.Type.Uint16:
            return new arrow_1.Uint16();
        case arrow_1.Type.Uint32:
            return new arrow_1.Uint32();
        case arrow_1.Type.Uint64:
            return new arrow_1.Uint64();
        case arrow_1.Type.Float16:
            return new arrow_1.Float16();
        case arrow_1.Type.Float32:
            return new arrow_1.Float32();
        case arrow_1.Type.Float64:
            return new arrow_1.Float64();
        case arrow_1.Type.DateMillisecond:
            return new arrow_1.DateMillisecond();
        case arrow_1.Type.DateDay:
            return new arrow_1.DateDay();
        case arrow_1.Type.TimeNanosecond:
            return new arrow_1.TimeNanosecond();
        case arrow_1.Type.TimeMicrosecond:
            return new arrow_1.TimeMicrosecond();
        case arrow_1.Type.TimeMillisecond:
            return new arrow_1.TimeMillisecond();
        case arrow_1.Type.TimeSecond:
            return new arrow_1.TimeSecond();
        case arrow_1.Type.TimestampNanosecond:
            return sanitizeTypedTimestamp(typeLike, arrow_1.TimestampNanosecond);
        case arrow_1.Type.TimestampMicrosecond:
            return sanitizeTypedTimestamp(typeLike, arrow_1.TimestampMicrosecond);
        case arrow_1.Type.TimestampMillisecond:
            return sanitizeTypedTimestamp(typeLike, arrow_1.TimestampMillisecond);
        case arrow_1.Type.TimestampSecond:
            return sanitizeTypedTimestamp(typeLike, arrow_1.TimestampSecond);
        case arrow_1.Type.DenseUnion:
            return sanitizeTypedUnion(typeLike, arrow_1.DenseUnion);
        case arrow_1.Type.SparseUnion:
            return sanitizeTypedUnion(typeLike, arrow_1.SparseUnion);
        case arrow_1.Type.IntervalDayTime:
            return new arrow_1.IntervalDayTime();
        case arrow_1.Type.IntervalYearMonth:
            return new arrow_1.IntervalYearMonth();
        case arrow_1.Type.DurationNanosecond:
            return new arrow_1.DurationNanosecond();
        case arrow_1.Type.DurationMicrosecond:
            return new arrow_1.DurationMicrosecond();
        case arrow_1.Type.DurationMillisecond:
            return new arrow_1.DurationMillisecond();
        case arrow_1.Type.DurationSecond:
            return new arrow_1.DurationSecond();
        default:
            throw new Error("Unrecognized type id in schema: " + typeId);
    }
}
function sanitizeField(fieldLike) {
    if (fieldLike instanceof arrow_1.Field) {
        return fieldLike;
    }
    if (typeof fieldLike !== "object" || fieldLike === null) {
        throw Error("Expected a Field but object was null/undefined");
    }
    if (!("type" in fieldLike) ||
        !("name" in fieldLike) ||
        !("nullable" in fieldLike)) {
        throw Error("The field passed in is missing a `type`/`name`/`nullable` property");
    }
    let type;
    try {
        type = sanitizeType(fieldLike.type);
    }
    catch (error) {
        throw Error(`Unable to sanitize type for field: ${fieldLike.name} due to error: ${error}`, { cause: error });
    }
    const name = fieldLike.name;
    if (!(typeof name === "string")) {
        throw Error("The field passed in had a non-string `name` property");
    }
    const nullable = fieldLike.nullable;
    if (!(typeof nullable === "boolean")) {
        throw Error("The field passed in had a non-boolean `nullable` property");
    }
    let metadata;
    if ("metadata" in fieldLike) {
        metadata = sanitizeMetadata(fieldLike.metadata);
    }
    return new arrow_1.Field(name, type, nullable, metadata);
}
/**
 * Convert something schemaLike into a Schema instance
 *
 * This method is often needed even when the caller is using a Schema
 * instance because they might be using a different instance of apache-arrow
 * than lancedb is using.
 */
function sanitizeSchema(schemaLike) {
    if (schemaLike instanceof arrow_1.Schema) {
        return schemaLike;
    }
    if (typeof schemaLike !== "object" || schemaLike === null) {
        throw Error("Expected a Schema but object was null/undefined");
    }
    if (!("fields" in schemaLike)) {
        throw Error("The schema passed in does not appear to be a schema (no 'fields' property)");
    }
    let metadata;
    if ("metadata" in schemaLike) {
        metadata = sanitizeMetadata(schemaLike.metadata);
    }
    if (!Array.isArray(schemaLike.fields)) {
        throw Error("The schema passed in had a 'fields' property but it was not an array");
    }
    const sanitizedFields = schemaLike.fields.map((field) => sanitizeField(field));
    return new arrow_1.Schema(sanitizedFields, metadata);
}
function sanitizeTable(tableLike) {
    if (tableLike instanceof arrow_1.Table) {
        return tableLike;
    }
    if (typeof tableLike !== "object" || tableLike === null) {
        throw Error("Expected a Table but object was null/undefined");
    }
    if (!("schema" in tableLike)) {
        throw Error("The table passed in does not appear to be a table (no 'schema' property)");
    }
    if (!("batches" in tableLike)) {
        throw Error("The table passed in does not appear to be a table (no 'columns' property)");
    }
    const schema = sanitizeSchema(tableLike.schema);
    const batches = tableLike.batches.map(sanitizeRecordBatch);
    return new arrow_1.Table(schema, batches);
}
function sanitizeRecordBatch(batchLike) {
    if (batchLike instanceof arrow_1.RecordBatch) {
        return batchLike;
    }
    if (typeof batchLike !== "object" || batchLike === null) {
        throw Error("Expected a RecordBatch but object was null/undefined");
    }
    if (!("schema" in batchLike)) {
        throw Error("The record batch passed in does not appear to be a record batch (no 'schema' property)");
    }
    if (!("data" in batchLike)) {
        throw Error("The record batch passed in does not appear to be a record batch (no 'data' property)");
    }
    const schema = sanitizeSchema(batchLike.schema);
    const data = sanitizeData(batchLike.data);
    return new arrow_1.RecordBatch(schema, data);
}
function sanitizeData(dataLike) {
    if (dataLike instanceof apache_arrow_1.Data) {
        return dataLike;
    }
    return new apache_arrow_1.Data(dataLike.type, dataLike.offset, dataLike.length, dataLike.nullCount, {
        [apache_arrow_1.BufferType.OFFSET]: dataLike.valueOffsets,
        [apache_arrow_1.BufferType.DATA]: dataLike.values,
        [apache_arrow_1.BufferType.VALIDITY]: dataLike.nullBitmap,
        [apache_arrow_1.BufferType.TYPE]: dataLike.typeIds,
    });
}
const constructorsByTypeName = {
    null: () => new arrow_1.Null(),
    binary: () => new arrow_1.Binary(),
    utf8: () => new arrow_1.Utf8(),
    bool: () => new arrow_1.Bool(),
    int8: () => new arrow_1.Int8(),
    int16: () => new arrow_1.Int16(),
    int32: () => new arrow_1.Int32(),
    int64: () => new arrow_1.Int64(),
    uint8: () => new arrow_1.Uint8(),
    uint16: () => new arrow_1.Uint16(),
    uint32: () => new arrow_1.Uint32(),
    uint64: () => new arrow_1.Uint64(),
    float16: () => new arrow_1.Float16(),
    float32: () => new arrow_1.Float32(),
    float64: () => new arrow_1.Float64(),
    datemillisecond: () => new arrow_1.DateMillisecond(),
    dateday: () => new arrow_1.DateDay(),
    timenanosecond: () => new arrow_1.TimeNanosecond(),
    timemicrosecond: () => new arrow_1.TimeMicrosecond(),
    timemillisecond: () => new arrow_1.TimeMillisecond(),
    timesecond: () => new arrow_1.TimeSecond(),
    intervaldaytime: () => new arrow_1.IntervalDayTime(),
    intervalyearmonth: () => new arrow_1.IntervalYearMonth(),
    durationnanosecond: () => new arrow_1.DurationNanosecond(),
    durationmicrosecond: () => new arrow_1.DurationMicrosecond(),
    durationmillisecond: () => new arrow_1.DurationMillisecond(),
    durationsecond: () => new arrow_1.DurationSecond(),
};
function dataTypeFromName(typeName) {
    const normalizedTypeName = typeName.toLowerCase();
    const _constructor = constructorsByTypeName[normalizedTypeName];
    if (!_constructor) {
        throw new Error("Unrecognized type name in schema: " + typeName);
    }
    return _constructor();
}


/***/ }),
/* 185 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// SPDX-License-Identifier: Apache-2.0
// SPDX-FileCopyrightText: Copyright The LanceDB Authors
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LocalTable = exports.Table = void 0;
const arrow_1 = __webpack_require__(39);
const registry_1 = __webpack_require__(182);
const merge_1 = __webpack_require__(186);
const query_1 = __webpack_require__(187);
const sanitize_1 = __webpack_require__(184);
const util_1 = __webpack_require__(191);
/**
 * A Table is a collection of Records in a LanceDB Database.
 *
 * A Table object is expected to be long lived and reused for multiple operations.
 * Table objects will cache a certain amount of index data in memory.  This cache
 * will be freed when the Table is garbage collected.  To eagerly free the cache you
 * can call the `close` method.  Once the Table is closed, it cannot be used for any
 * further operations.
 *
 * Tables are created using the methods {@link Connection#createTable}
 * and {@link Connection#createEmptyTable}. Existing tables are opened
 * using {@link Connection#openTable}.
 *
 * Closing a table is optional.  It not closed, it will be closed when it is garbage
 * collected.
 *
 * @hideconstructor
 */
class Table {
    [Symbol.for("nodejs.util.inspect.custom")]() {
        return this.display();
    }
}
exports.Table = Table;
class LocalTable extends Table {
    inner;
    constructor(inner) {
        super();
        this.inner = inner;
    }
    get name() {
        return this.inner.name;
    }
    isOpen() {
        return this.inner.isOpen();
    }
    close() {
        this.inner.close();
    }
    display() {
        return this.inner.display();
    }
    async getEmbeddingFunctions() {
        const schema = await this.schema();
        const registry = (0, registry_1.getRegistry)();
        return registry.parseFunctions(schema.metadata);
    }
    /** Get the schema of the table. */
    async schema() {
        const schemaBuf = await this.inner.schema();
        const tbl = (0, arrow_1.tableFromIPC)(schemaBuf);
        return tbl.schema;
    }
    async add(data, options) {
        const mode = options?.mode ?? "append";
        const schema = await this.schema();
        const buffer = await (0, arrow_1.fromDataToBuffer)(data, undefined, schema);
        return await this.inner.add(buffer, mode);
    }
    async update(optsOrUpdates, options) {
        const isValues = "values" in optsOrUpdates && typeof optsOrUpdates.values !== "string";
        const isValuesSql = "valuesSql" in optsOrUpdates &&
            typeof optsOrUpdates.valuesSql !== "string";
        const isMap = (obj) => {
            return obj instanceof Map;
        };
        let predicate;
        let columns;
        switch (true) {
            case isMap(optsOrUpdates):
                columns = Array.from(optsOrUpdates.entries());
                predicate = options?.where;
                break;
            case isValues && isMap(optsOrUpdates.values):
                columns = Array.from(optsOrUpdates.values.entries()).map(([k, v]) => [
                    k,
                    (0, util_1.toSQL)(v),
                ]);
                predicate = optsOrUpdates.where;
                break;
            case isValues && !isMap(optsOrUpdates.values):
                columns = Object.entries(optsOrUpdates.values).map(([k, v]) => [
                    k,
                    (0, util_1.toSQL)(v),
                ]);
                predicate = optsOrUpdates.where;
                break;
            case isValuesSql && isMap(optsOrUpdates.valuesSql):
                columns = Array.from(optsOrUpdates.valuesSql.entries());
                predicate = optsOrUpdates.where;
                break;
            case isValuesSql && !isMap(optsOrUpdates.valuesSql):
                columns = Object.entries(optsOrUpdates.valuesSql).map(([k, v]) => [
                    k,
                    v,
                ]);
                predicate = optsOrUpdates.where;
                break;
            default:
                columns = Object.entries(optsOrUpdates);
                predicate = options?.where;
        }
        return await this.inner.update(predicate, columns);
    }
    async countRows(filter) {
        return await this.inner.countRows(filter);
    }
    async delete(predicate) {
        return await this.inner.delete(predicate);
    }
    async createIndex(column, options) {
        // Bit of a hack to get around the fact that TS has no package-scope.
        // biome-ignore lint/suspicious/noExplicitAny: skip
        const nativeIndex = options?.config?.inner;
        await this.inner.createIndex(nativeIndex, column, options?.replace, options?.waitTimeoutSeconds, options?.name, options?.train);
    }
    async dropIndex(name) {
        await this.inner.dropIndex(name);
    }
    async prewarmIndex(name) {
        await this.inner.prewarmIndex(name);
    }
    async waitForIndex(indexNames, timeoutSeconds) {
        await this.inner.waitForIndex(indexNames, timeoutSeconds);
    }
    takeOffsets(offsets) {
        return new query_1.TakeQuery(this.inner.takeOffsets(offsets));
    }
    takeRowIds(rowIds) {
        return new query_1.TakeQuery(this.inner.takeRowIds(rowIds));
    }
    query() {
        return new query_1.Query(this.inner);
    }
    search(query, queryType = "auto", ftsColumns) {
        if (typeof query !== "string" && !(0, query_1.instanceOfFullTextQuery)(query)) {
            if (queryType === "fts") {
                throw new Error("Cannot perform full text search on a vector query");
            }
            return this.vectorSearch(query);
        }
        // If the query is a string, we need to determine if it is a vector query or a full text search query
        if (queryType === "fts") {
            return this.query().fullTextSearch(query, {
                columns: ftsColumns,
            });
        }
        // The query type is auto or vector
        // fall back to full text search if no embedding functions are defined and the query is a string
        if (queryType === "auto" &&
            ((0, registry_1.getRegistry)().length() === 0 || (0, query_1.instanceOfFullTextQuery)(query))) {
            return this.query().fullTextSearch(query, {
                columns: ftsColumns,
            });
        }
        const queryPromise = this.getEmbeddingFunctions().then(async (functions) => {
            // TODO: Support multiple embedding functions
            const embeddingFunc = functions
                .values()
                .next().value;
            if (!embeddingFunc) {
                return Promise.reject(new Error("No embedding functions are defined in the table"));
            }
            return await embeddingFunc.function.computeQueryEmbeddings(query);
        });
        return this.query().nearestTo(queryPromise);
    }
    vectorSearch(vector) {
        if ((0, arrow_1.isMultiVector)(vector)) {
            const query = this.query().nearestTo(vector[0]);
            for (const v of vector.slice(1)) {
                query.addQueryVector(v);
            }
            return query;
        }
        return this.query().nearestTo(vector);
    }
    // TODO: Support BatchUDF
    async addColumns(newColumnTransforms) {
        return await this.inner.addColumns(newColumnTransforms);
    }
    async alterColumns(columnAlterations) {
        const processedAlterations = columnAlterations.map((alteration) => {
            if (typeof alteration.dataType === "string") {
                return {
                    ...alteration,
                    dataType: JSON.stringify({ type: alteration.dataType }),
                };
            }
            else if (alteration.dataType === undefined) {
                return {
                    ...alteration,
                    dataType: undefined,
                };
            }
            else {
                const dataType = (0, sanitize_1.sanitizeType)(alteration.dataType);
                return {
                    ...alteration,
                    dataType: JSON.stringify((0, arrow_1.dataTypeToJson)(dataType)),
                };
            }
        });
        return await this.inner.alterColumns(processedAlterations);
    }
    async dropColumns(columnNames) {
        return await this.inner.dropColumns(columnNames);
    }
    async version() {
        return await this.inner.version();
    }
    async checkout(version) {
        if (typeof version === "string") {
            return this.inner.checkoutTag(version);
        }
        return this.inner.checkout(version);
    }
    async checkoutLatest() {
        await this.inner.checkoutLatest();
    }
    async listVersions() {
        return (await this.inner.listVersions()).map((version) => ({
            version: version.version,
            timestamp: new Date(version.timestamp / 1000),
            metadata: version.metadata,
        }));
    }
    async restore() {
        await this.inner.restore();
    }
    async tags() {
        return await this.inner.tags();
    }
    async optimize(options) {
        let cleanupOlderThanMs;
        if (options?.cleanupOlderThan !== undefined &&
            options?.cleanupOlderThan !== null) {
            cleanupOlderThanMs =
                new Date().getTime() - options.cleanupOlderThan.getTime();
        }
        return await this.inner.optimize(cleanupOlderThanMs, options?.deleteUnverified);
    }
    async listIndices() {
        return await this.inner.listIndices();
    }
    async toArrow() {
        return await this.query().toArrow();
    }
    async indexStats(name) {
        const stats = await this.inner.indexStats(name);
        if (stats === null) {
            return undefined;
        }
        return stats;
    }
    async stats() {
        return await this.inner.stats();
    }
    mergeInsert(on) {
        on = Array.isArray(on) ? on : [on];
        return new merge_1.MergeInsertBuilder(this.inner.mergeInsert(on), this.schema());
    }
    /**
     * Check if the table uses the new manifest path scheme.
     *
     * This function will return true if the table uses the V2 manifest
     * path scheme.
     */
    async usesV2ManifestPaths() {
        return await this.inner.usesV2ManifestPaths();
    }
    /**
     * Migrate the table to use the new manifest path scheme.
     *
     * This function will rename all V1 manifests to V2 manifest paths.
     * These paths provide more efficient opening of datasets with many versions
     * on object stores.
     *
     * This function is idempotent, and can be run multiple times without
     * changing the state of the object store.
     *
     * However, it should not be run while other concurrent operations are happening.
     * And it should also run until completion before resuming other operations.
     */
    async migrateManifestPathsV2() {
        await this.inner.migrateManifestPathsV2();
    }
}
exports.LocalTable = LocalTable;


/***/ }),
/* 186 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MergeInsertBuilder = void 0;
// SPDX-License-Identifier: Apache-2.0
// SPDX-FileCopyrightText: Copyright The LanceDB Authors
const arrow_1 = __webpack_require__(39);
/** A builder used to create and run a merge insert operation */
class MergeInsertBuilder {
    #native;
    #schema;
    /** Construct a MergeInsertBuilder. __Internal use only.__ */
    constructor(native, schema) {
        this.#native = native;
        this.#schema = schema;
    }
    /**
     * Rows that exist in both the source table (new data) and
     * the target table (old data) will be updated, replacing
     * the old row with the corresponding matching row.
     *
     * If there are multiple matches then the behavior is undefined.
     * Currently this causes multiple copies of the row to be created
     * but that behavior is subject to change.
     *
     * An optional condition may be specified.  If it is, then only
     * matched rows that satisfy the condtion will be updated.  Any
     * rows that do not satisfy the condition will be left as they
     * are.  Failing to satisfy the condition does not cause a
     * "matched row" to become a "not matched" row.
     *
     * The condition should be an SQL string.  Use the prefix
     * target. to refer to rows in the target table (old data)
     * and the prefix source. to refer to rows in the source
     * table (new data).
     *
     * For example, "target.last_update < source.last_update"
     */
    whenMatchedUpdateAll(options) {
        return new MergeInsertBuilder(this.#native.whenMatchedUpdateAll(options?.where), this.#schema);
    }
    /**
     * Rows that exist only in the source table (new data) should
     * be inserted into the target table.
     */
    whenNotMatchedInsertAll() {
        return new MergeInsertBuilder(this.#native.whenNotMatchedInsertAll(), this.#schema);
    }
    /**
     * Rows that exist only in the target table (old data) will be
     * deleted.  An optional condition can be provided to limit what
     * data is deleted.
     *
     * @param options.where - An optional condition to limit what data is deleted
     */
    whenNotMatchedBySourceDelete(options) {
        return new MergeInsertBuilder(this.#native.whenNotMatchedBySourceDelete(options?.where), this.#schema);
    }
    /**
     * Controls whether to use indexes for the merge operation.
     *
     * When set to `true` (the default), the operation will use an index if available
     * on the join key for improved performance. When set to `false`, it forces a full
     * table scan even if an index exists. This can be useful for benchmarking or when
     * the query optimizer chooses a suboptimal path.
     *
     * @param useIndex - Whether to use indices for the merge operation. Defaults to `true`.
     */
    useIndex(useIndex) {
        return new MergeInsertBuilder(this.#native.useIndex(useIndex), this.#schema);
    }
    /**
     * Executes the merge insert operation
     *
     * @returns {Promise<MergeResult>} the merge result
     */
    async execute(data, execOptions) {
        let schema;
        if (this.#schema instanceof Promise) {
            schema = await this.#schema;
            this.#schema = schema; // In case of future calls
        }
        else {
            schema = this.#schema;
        }
        if (execOptions?.timeoutMs !== undefined) {
            this.#native.setTimeout(execOptions.timeoutMs);
        }
        const buffer = await (0, arrow_1.fromDataToBuffer)(data, undefined, schema);
        return await this.#native.execute(buffer);
    }
}
exports.MergeInsertBuilder = MergeInsertBuilder;


/***/ }),
/* 187 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// SPDX-License-Identifier: Apache-2.0
// SPDX-FileCopyrightText: Copyright The LanceDB Authors
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BooleanQuery = exports.MultiMatchQuery = exports.BoostQuery = exports.PhraseQuery = exports.MatchQuery = exports.Occur = exports.Operator = exports.FullTextQueryType = exports.Query = exports.TakeQuery = exports.VectorQuery = exports.StandardQueryBase = exports.QueryBase = void 0;
exports.RecordBatchIterator = RecordBatchIterator;
exports.instanceOfFullTextQuery = instanceOfFullTextQuery;
const arrow_1 = __webpack_require__(39);
const native_1 = __webpack_require__(188);
async function* RecordBatchIterator(promisedInner) {
    const inner = await promisedInner;
    if (inner === undefined) {
        throw new Error("Invalid iterator state");
    }
    for (let buffer = await inner.next(); buffer; buffer = await inner.next()) {
        const { batches } = (0, arrow_1.tableFromIPC)(buffer);
        if (batches.length !== 1) {
            throw new Error("Expected only one batch");
        }
        yield batches[0];
    }
}
class RecordBatchIterable {
    inner;
    options;
    constructor(inner, options) {
        this.inner = inner;
        this.options = options;
    }
    // biome-ignore lint/suspicious/noExplicitAny: skip
    [Symbol.asyncIterator]() {
        return RecordBatchIterator(this.inner.execute(this.options?.maxBatchLength, this.options?.timeoutMs));
    }
}
/** Common methods supported by all query types
 *
 * @see {@link Query}
 * @see {@link VectorQuery}
 *
 * @hideconstructor
 */
class QueryBase {
    inner;
    /**
     * @hidden
     */
    constructor(inner) {
        this.inner = inner;
        // intentionally empty
    }
    // call a function on the inner (either a promise or the actual object)
    /**
     * @hidden
     */
    doCall(fn) {
        if (this.inner instanceof Promise) {
            this.inner = this.inner.then((inner) => {
                fn(inner);
                return inner;
            });
        }
        else {
            fn(this.inner);
        }
    }
    /**
     * Return only the specified columns.
     *
     * By default a query will return all columns from the table.  However, this can have
     * a very significant impact on latency.  LanceDb stores data in a columnar fashion.  This
     * means we can finely tune our I/O to select exactly the columns we need.
     *
     * As a best practice you should always limit queries to the columns that you need.  If you
     * pass in an array of column names then only those columns will be returned.
     *
     * You can also use this method to create new "dynamic" columns based on your existing columns.
     * For example, you may not care about "a" or "b" but instead simply want "a + b".  This is often
     * seen in the SELECT clause of an SQL query (e.g. `SELECT a+b FROM my_table`).
     *
     * To create dynamic columns you can pass in a Map<string, string>.  A column will be returned
     * for each entry in the map.  The key provides the name of the column.  The value is
     * an SQL string used to specify how the column is calculated.
     *
     * For example, an SQL query might state `SELECT a + b AS combined, c`.  The equivalent
     * input to this method would be:
     * @example
     * new Map([["combined", "a + b"], ["c", "c"]])
     *
     * Columns will always be returned in the order given, even if that order is different than
     * the order used when adding the data.
     *
     * Note that you can pass in a `Record<string, string>` (e.g. an object literal). This method
     * uses `Object.entries` which should preserve the insertion order of the object.  However,
     * object insertion order is easy to get wrong and `Map` is more foolproof.
     */
    select(columns) {
        const selectColumns = (columnArray) => {
            this.doCall((inner) => {
                inner.selectColumns(columnArray);
            });
        };
        const selectMapping = (columnTuples) => {
            this.doCall((inner) => {
                inner.select(columnTuples);
            });
        };
        if (typeof columns === "string") {
            selectColumns([columns]);
        }
        else if (Array.isArray(columns)) {
            selectColumns(columns);
        }
        else if (columns instanceof Map) {
            selectMapping(Array.from(columns.entries()));
        }
        else {
            selectMapping(Object.entries(columns));
        }
        return this;
    }
    /**
     * Whether to return the row id in the results.
     *
     * This column can be used to match results between different queries. For
     * example, to match results from a full text search and a vector search in
     * order to perform hybrid search.
     */
    withRowId() {
        this.doCall((inner) => inner.withRowId());
        return this;
    }
    /**
     * @hidden
     */
    nativeExecute(options) {
        if (this.inner instanceof Promise) {
            return this.inner.then((inner) => inner.execute(options?.maxBatchLength, options?.timeoutMs));
        }
        else {
            return this.inner.execute(options?.maxBatchLength, options?.timeoutMs);
        }
    }
    /**
     * Execute the query and return the results as an @see {@link AsyncIterator}
     * of @see {@link RecordBatch}.
     *
     * By default, LanceDb will use many threads to calculate results and, when
     * the result set is large, multiple batches will be processed at one time.
     * This readahead is limited however and backpressure will be applied if this
     * stream is consumed slowly (this constrains the maximum memory used by a
     * single query)
     *
     */
    execute(options) {
        return RecordBatchIterator(this.nativeExecute(options));
    }
    /**
     * @hidden
     */
    // biome-ignore lint/suspicious/noExplicitAny: skip
    [Symbol.asyncIterator]() {
        return RecordBatchIterator(this.nativeExecute());
    }
    /** Collect the results as an Arrow @see {@link ArrowTable}. */
    async toArrow(options) {
        const batches = [];
        let inner;
        if (this.inner instanceof Promise) {
            inner = await this.inner;
        }
        else {
            inner = this.inner;
        }
        for await (const batch of new RecordBatchIterable(inner, options)) {
            batches.push(batch);
        }
        return new arrow_1.Table(batches);
    }
    /** Collect the results as an array of objects. */
    // biome-ignore lint/suspicious/noExplicitAny: arrow.toArrow() returns any[]
    async toArray(options) {
        const tbl = await this.toArrow(options);
        return tbl.toArray();
    }
    /**
     * Generates an explanation of the query execution plan.
     *
     * @example
     * import * as lancedb from "@lancedb/lancedb"
     * const db = await lancedb.connect("./.lancedb");
     * const table = await db.createTable("my_table", [
     *   { vector: [1.1, 0.9], id: "1" },
     * ]);
     * const plan = await table.query().nearestTo([0.5, 0.2]).explainPlan();
     *
     * @param verbose - If true, provides a more detailed explanation. Defaults to false.
     * @returns A Promise that resolves to a string containing the query execution plan explanation.
     */
    async explainPlan(verbose = false) {
        if (this.inner instanceof Promise) {
            return this.inner.then((inner) => inner.explainPlan(verbose));
        }
        else {
            return this.inner.explainPlan(verbose);
        }
    }
    /**
     * Executes the query and returns the physical query plan annotated with runtime metrics.
     *
     * This is useful for debugging and performance analysis, as it shows how the query was executed
     * and includes metrics such as elapsed time, rows processed, and I/O statistics.
     *
     * @example
     * import * as lancedb from "@lancedb/lancedb"
     *
     * const db = await lancedb.connect("./.lancedb");
     * const table = await db.createTable("my_table", [
     *   { vector: [1.1, 0.9], id: "1" },
     * ]);
     *
     * const plan = await table.query().nearestTo([0.5, 0.2]).analyzePlan();
     *
     * Example output (with runtime metrics inlined):
     * AnalyzeExec verbose=true, metrics=[]
     *  ProjectionExec: expr=[id@3 as id, vector@0 as vector, _distance@2 as _distance], metrics=[output_rows=1, elapsed_compute=3.292Âµs]
     *   Take: columns="vector, _rowid, _distance, (id)", metrics=[output_rows=1, elapsed_compute=66.001Âµs, batches_processed=1, bytes_read=8, iops=1, requests=1]
     *    CoalesceBatchesExec: target_batch_size=1024, metrics=[output_rows=1, elapsed_compute=3.333Âµs]
     *     GlobalLimitExec: skip=0, fetch=10, metrics=[output_rows=1, elapsed_compute=167ns]
     *      FilterExec: _distance@2 IS NOT NULL, metrics=[output_rows=1, elapsed_compute=8.542Âµs]
     *       SortExec: TopK(fetch=10), expr=[_distance@2 ASC NULLS LAST], metrics=[output_rows=1, elapsed_compute=63.25Âµs, row_replacements=1]
     *        KNNVectorDistance: metric=l2, metrics=[output_rows=1, elapsed_compute=114.333Âµs, output_batches=1]
     *         LanceScan: uri=/path/to/data, projection=[vector], row_id=true, row_addr=false, ordered=false, metrics=[output_rows=1, elapsed_compute=103.626Âµs, bytes_read=549, iops=2, requests=2]
     *
     * @returns A query execution plan with runtime metrics for each step.
     */
    async analyzePlan() {
        if (this.inner instanceof Promise) {
            return this.inner.then((inner) => inner.analyzePlan());
        }
        else {
            return this.inner.analyzePlan();
        }
    }
    /**
     * Returns the schema of the output that will be returned by this query.
     *
     * This can be used to inspect the types and names of the columns that will be
     * returned by the query before executing it.
     *
     * @returns An Arrow Schema describing the output columns.
     */
    async outputSchema() {
        let schemaBuffer;
        if (this.inner instanceof Promise) {
            schemaBuffer = await this.inner.then((inner) => inner.outputSchema());
        }
        else {
            schemaBuffer = await this.inner.outputSchema();
        }
        const schema = (0, arrow_1.tableFromIPC)(schemaBuffer).schema;
        return schema;
    }
}
exports.QueryBase = QueryBase;
class StandardQueryBase extends QueryBase {
    constructor(inner) {
        super(inner);
    }
    /**
     * A filter statement to be applied to this query.
     *
     * The filter should be supplied as an SQL query string.  For example:
     * @example
     * x > 10
     * y > 0 AND y < 100
     * x > 5 OR y = 'test'
     *
     * Filtering performance can often be improved by creating a scalar index
     * on the filter column(s).
     */
    where(predicate) {
        this.doCall((inner) => inner.onlyIf(predicate));
        return this;
    }
    /**
     * A filter statement to be applied to this query.
     * @see where
     * @deprecated Use `where` instead
     */
    filter(predicate) {
        return this.where(predicate);
    }
    fullTextSearch(query, options) {
        let columns = null;
        if (options) {
            if (typeof options.columns === "string") {
                columns = [options.columns];
            }
            else if (Array.isArray(options.columns)) {
                columns = options.columns;
            }
        }
        this.doCall((inner) => {
            if (typeof query === "string") {
                inner.fullTextSearch({
                    query: query,
                    columns: columns,
                });
            }
            else {
                inner.fullTextSearch({ query: query.inner });
            }
        });
        return this;
    }
    /**
     * Set the maximum number of results to return.
     *
     * By default, a plain search has no limit.  If this method is not
     * called then every valid row from the table will be returned.
     */
    limit(limit) {
        this.doCall((inner) => inner.limit(limit));
        return this;
    }
    /**
     * Set the number of rows to skip before returning results.
     *
     * This is useful for pagination.
     */
    offset(offset) {
        this.doCall((inner) => inner.offset(offset));
        return this;
    }
    /**
     * Skip searching un-indexed data. This can make search faster, but will miss
     * any data that is not yet indexed.
     *
     * Use {@link Table#optimize} to index all un-indexed data.
     */
    fastSearch() {
        this.doCall((inner) => inner.fastSearch());
        return this;
    }
}
exports.StandardQueryBase = StandardQueryBase;
/**
 * A builder used to construct a vector search
 *
 * This builder can be reused to execute the query many times.
 *
 * @see {@link Query#nearestTo}
 *
 * @hideconstructor
 */
class VectorQuery extends StandardQueryBase {
    /**
     * @hidden
     */
    constructor(inner) {
        super(inner);
    }
    /**
     * Set the number of partitions to search (probe)
     *
     * This argument is only used when the vector column has an IVF PQ index.
     * If there is no index then this value is ignored.
     *
     * The IVF stage of IVF PQ divides the input into partitions (clusters) of
     * related values.
     *
     * The partition whose centroids are closest to the query vector will be
     * exhaustiely searched to find matches.  This parameter controls how many
     * partitions should be searched.
     *
     * Increasing this value will increase the recall of your query but will
     * also increase the latency of your query.  The default value is 20.  This
     * default is good for many cases but the best value to use will depend on
     * your data and the recall that you need to achieve.
     *
     * For best results we recommend tuning this parameter with a benchmark against
     * your actual data to find the smallest possible value that will still give
     * you the desired recall.
     *
     * For more fine grained control over behavior when you have a very narrow filter
     * you can use `minimumNprobes` and `maximumNprobes`.  This method sets both
     * the minimum and maximum to the same value.
     */
    nprobes(nprobes) {
        super.doCall((inner) => inner.nprobes(nprobes));
        return this;
    }
    /**
     * Set the minimum number of probes used.
     *
     * This controls the minimum number of partitions that will be searched.  This
     * parameter will impact every query against a vector index, regardless of the
     * filter.  See `nprobes` for more details.  Higher values will increase recall
     * but will also increase latency.
     */
    minimumNprobes(minimumNprobes) {
        super.doCall((inner) => inner.minimumNprobes(minimumNprobes));
        return this;
    }
    /**
     * Set the maximum number of probes used.
     *
     * This controls the maximum number of partitions that will be searched.  If this
     * number is greater than minimumNprobes then the excess partitions will _only_ be
     * searched if we have not found enough results.  This can be useful when there is
     * a narrow filter to allow these queries to spend more time searching and avoid
     * potential false negatives.
     */
    maximumNprobes(maximumNprobes) {
        super.doCall((inner) => inner.maximumNprobes(maximumNprobes));
        return this;
    }
    /*
     * Set the distance range to use
     *
     * Only rows with distances within range [lower_bound, upper_bound)
     * will be returned.
     *
     * `undefined` means no lower or upper bound.
     */
    distanceRange(lowerBound, upperBound) {
        super.doCall((inner) => inner.distanceRange(lowerBound, upperBound));
        return this;
    }
    /**
     * Set the number of candidates to consider during the search
     *
     * This argument is only used when the vector column has an HNSW index.
     * If there is no index then this value is ignored.
     *
     * Increasing this value will increase the recall of your query but will
     * also increase the latency of your query. The default value is 1.5*limit.
     */
    ef(ef) {
        super.doCall((inner) => inner.ef(ef));
        return this;
    }
    /**
     * Set the vector column to query
     *
     * This controls which column is compared to the query vector supplied in
     * the call to @see {@link Query#nearestTo}
     *
     * This parameter must be specified if the table has more than one column
     * whose data type is a fixed-size-list of floats.
     */
    column(column) {
        super.doCall((inner) => inner.column(column));
        return this;
    }
    /**
     * Set the distance metric to use
     *
     * When performing a vector search we try and find the "nearest" vectors according
     * to some kind of distance metric.  This parameter controls which distance metric to
     * use.  See @see {@link IvfPqOptions.distanceType} for more details on the different
     * distance metrics available.
     *
     * Note: if there is a vector index then the distance type used MUST match the distance
     * type used to train the vector index.  If this is not done then the results will be
     * invalid.
     *
     * By default "l2" is used.
     */
    distanceType(distanceType) {
        super.doCall((inner) => inner.distanceType(distanceType));
        return this;
    }
    /**
     * A multiplier to control how many additional rows are taken during the refine step
     *
     * This argument is only used when the vector column has an IVF PQ index.
     * If there is no index then this value is ignored.
     *
     * An IVF PQ index stores compressed (quantized) values.  They query vector is compared
     * against these values and, since they are compressed, the comparison is inaccurate.
     *
     * This parameter can be used to refine the results.  It can improve both improve recall
     * and correct the ordering of the nearest results.
     *
     * To refine results LanceDb will first perform an ANN search to find the nearest
     * `limit` * `refine_factor` results.  In other words, if `refine_factor` is 3 and
     * `limit` is the default (10) then the first 30 results will be selected.  LanceDb
     * then fetches the full, uncompressed, values for these 30 results.  The results are
     * then reordered by the true distance and only the nearest 10 are kept.
     *
     * Note: there is a difference between calling this method with a value of 1 and never
     * calling this method at all.  Calling this method with any value will have an impact
     * on your search latency.  When you call this method with a `refine_factor` of 1 then
     * LanceDb still needs to fetch the full, uncompressed, values so that it can potentially
     * reorder the results.
     *
     * Note: if this method is NOT called then the distances returned in the _distance column
     * will be approximate distances based on the comparison of the quantized query vector
     * and the quantized result vectors.  This can be considerably different than the true
     * distance between the query vector and the actual uncompressed vector.
     */
    refineFactor(refineFactor) {
        super.doCall((inner) => inner.refineFactor(refineFactor));
        return this;
    }
    /**
     * If this is called then filtering will happen after the vector search instead of
     * before.
     *
     * By default filtering will be performed before the vector search.  This is how
     * filtering is typically understood to work.  This prefilter step does add some
     * additional latency.  Creating a scalar index on the filter column(s) can
     * often improve this latency.  However, sometimes a filter is too complex or scalar
     * indices cannot be applied to the column.  In these cases postfiltering can be
     * used instead of prefiltering to improve latency.
     *
     * Post filtering applies the filter to the results of the vector search.  This means
     * we only run the filter on a much smaller set of data.  However, it can cause the
     * query to return fewer than `limit` results (or even no results) if none of the nearest
     * results match the filter.
     *
     * Post filtering happens during the "refine stage" (described in more detail in
     * @see {@link VectorQuery#refineFactor}).  This means that setting a higher refine
     * factor can often help restore some of the results lost by post filtering.
     */
    postfilter() {
        super.doCall((inner) => inner.postfilter());
        return this;
    }
    /**
     * If this is called then any vector index is skipped
     *
     * An exhaustive (flat) search will be performed.  The query vector will
     * be compared to every vector in the table.  At high scales this can be
     * expensive.  However, this is often still useful.  For example, skipping
     * the vector index can give you ground truth results which you can use to
     * calculate your recall to select an appropriate value for nprobes.
     */
    bypassVectorIndex() {
        super.doCall((inner) => inner.bypassVectorIndex());
        return this;
    }
    /*
     * Add a query vector to the search
     *
     * This method can be called multiple times to add multiple query vectors
     * to the search. If multiple query vectors are added, then they will be searched
     * in parallel, and the results will be concatenated. A column called `query_index`
     * will be added to indicate the index of the query vector that produced the result.
     *
     * Performance wise, this is equivalent to running multiple queries concurrently.
     */
    addQueryVector(vector) {
        if (vector instanceof Promise) {
            const res = (async () => {
                try {
                    const v = await vector;
                    const arr = Float32Array.from(v);
                    //
                    // biome-ignore lint/suspicious/noExplicitAny: we need to get the `inner`, but js has no package scoping
                    const value = this.addQueryVector(arr);
                    const inner = value.inner;
                    return inner;
                }
                catch (e) {
                    return Promise.reject(e);
                }
            })();
            return new VectorQuery(res);
        }
        else {
            super.doCall((inner) => {
                inner.addQueryVector(Float32Array.from(vector));
            });
            return this;
        }
    }
    rerank(reranker) {
        super.doCall((inner) => inner.rerank({
            rerankHybrid: async (_, args) => {
                const vecResults = await (0, arrow_1.fromBufferToRecordBatch)(args.vecResults);
                const ftsResults = await (0, arrow_1.fromBufferToRecordBatch)(args.ftsResults);
                const result = await reranker.rerankHybrid(args.query, vecResults, ftsResults);
                const buffer = (0, arrow_1.fromRecordBatchToBuffer)(result);
                return buffer;
            },
        }));
        return this;
    }
}
exports.VectorQuery = VectorQuery;
/**
 * A query that returns a subset of the rows in the table.
 *
 * @hideconstructor
 */
class TakeQuery extends QueryBase {
    constructor(inner) {
        super(inner);
    }
}
exports.TakeQuery = TakeQuery;
/** A builder for LanceDB queries.
 *
 * @see {@link Table#query}, {@link Table#search}
 *
 * @hideconstructor
 */
class Query extends StandardQueryBase {
    /**
     * @hidden
     */
    constructor(tbl) {
        super(tbl.query());
    }
    /**
     * Find the nearest vectors to the given query vector.
     *
     * This converts the query from a plain query to a vector query.
     *
     * This method will attempt to convert the input to the query vector
     * expected by the embedding model.  If the input cannot be converted
     * then an error will be thrown.
     *
     * By default, there is no embedding model, and the input should be
     * an array-like object of numbers (something that can be used as input
     * to Float32Array.from)
     *
     * If there is only one vector column (a column whose data type is a
     * fixed size list of floats) then the column does not need to be specified.
     * If there is more than one vector column you must use
     * @see {@link VectorQuery#column}  to specify which column you would like
     * to compare with.
     *
     * If no index has been created on the vector column then a vector query
     * will perform a distance comparison between the query vector and every
     * vector in the database and then sort the results.  This is sometimes
     * called a "flat search"
     *
     * For small databases, with a few hundred thousand vectors or less, this can
     * be reasonably fast.  In larger databases you should create a vector index
     * on the column.  If there is a vector index then an "approximate" nearest
     * neighbor search (frequently called an ANN search) will be performed.  This
     * search is much faster, but the results will be approximate.
     *
     * The query can be further parameterized using the returned builder.  There
     * are various ANN search parameters that will let you fine tune your recall
     * accuracy vs search latency.
     *
     * Vector searches always have a `limit`.  If `limit` has not been called then
     * a default `limit` of 10 will be used.  @see {@link Query#limit}
     */
    nearestTo(vector) {
        if (this.inner instanceof Promise) {
            const nativeQuery = this.inner.then(async (inner) => {
                if (vector instanceof Promise) {
                    const arr = await vector.then((v) => Float32Array.from(v));
                    return inner.nearestTo(arr);
                }
                else {
                    return inner.nearestTo(Float32Array.from(vector));
                }
            });
            return new VectorQuery(nativeQuery);
        }
        if (vector instanceof Promise) {
            const res = (async () => {
                try {
                    const v = await vector;
                    const arr = Float32Array.from(v);
                    //
                    // biome-ignore lint/suspicious/noExplicitAny: we need to get the `inner`, but js has no package scoping
                    const value = this.nearestTo(arr);
                    const inner = value.inner;
                    return inner;
                }
                catch (e) {
                    return Promise.reject(e);
                }
            })();
            return new VectorQuery(res);
        }
        else {
            const vectorQuery = this.inner.nearestTo(Float32Array.from(vector));
            return new VectorQuery(vectorQuery);
        }
    }
    nearestToText(query, columns) {
        this.doCall((inner) => {
            if (typeof query === "string") {
                inner.fullTextSearch({
                    query: query,
                    columns: columns,
                });
            }
            else {
                inner.fullTextSearch({ query: query.inner });
            }
        });
        return this;
    }
}
exports.Query = Query;
/**
 * Enum representing the types of full-text queries supported.
 *
 * - `Match`: Performs a full-text search for terms in the query string.
 * - `MatchPhrase`: Searches for an exact phrase match in the text.
 * - `Boost`: Boosts the relevance score of specific terms in the query.
 * - `MultiMatch`: Searches across multiple fields for the query terms.
 */
var FullTextQueryType;
(function (FullTextQueryType) {
    FullTextQueryType["Match"] = "match";
    FullTextQueryType["MatchPhrase"] = "match_phrase";
    FullTextQueryType["Boost"] = "boost";
    FullTextQueryType["MultiMatch"] = "multi_match";
    FullTextQueryType["Boolean"] = "boolean";
})(FullTextQueryType || (exports.FullTextQueryType = FullTextQueryType = {}));
/**
 * Enum representing the logical operators used in full-text queries.
 *
 * - `And`: All terms must match.
 * - `Or`: At least one term must match.
 */
var Operator;
(function (Operator) {
    Operator["And"] = "AND";
    Operator["Or"] = "OR";
})(Operator || (exports.Operator = Operator = {}));
/**
 * Enum representing the occurrence of terms in full-text queries.
 *
 * - `Must`: The term must be present in the document.
 * - `Should`: The term should contribute to the document score, but is not required.
 * - `MustNot`: The term must not be present in the document.
 */
var Occur;
(function (Occur) {
    Occur["Should"] = "SHOULD";
    Occur["Must"] = "MUST";
    Occur["MustNot"] = "MUST_NOT";
})(Occur || (exports.Occur = Occur = {}));
// biome-ignore lint/suspicious/noExplicitAny: we want any here
function instanceOfFullTextQuery(obj) {
    return obj != null && obj.inner instanceof native_1.JsFullTextQuery;
}
class MatchQuery {
    /** @ignore */
    inner;
    /**
     * Creates an instance of MatchQuery.
     *
     * @param query - The text query to search for.
     * @param column - The name of the column to search within.
     * @param options - Optional parameters for the match query.
     *   - `boost`: The boost factor for the query (default is 1.0).
     *   - `fuzziness`: The fuzziness level for the query (default is 0).
     *   - `maxExpansions`: The maximum number of terms to consider for fuzzy matching (default is 50).
     *   - `operator`: The logical operator to use for combining terms in the query (default is "OR").
     *   - `prefixLength`: The number of beginning characters being unchanged for fuzzy matching.
     */
    constructor(query, column, options) {
        let fuzziness = options?.fuzziness;
        if (fuzziness === undefined) {
            fuzziness = 0;
        }
        this.inner = native_1.JsFullTextQuery.matchQuery(query, column, options?.boost ?? 1.0, fuzziness, options?.maxExpansions ?? 50, options?.operator ?? Operator.Or, options?.prefixLength ?? 0);
    }
    queryType() {
        return FullTextQueryType.Match;
    }
}
exports.MatchQuery = MatchQuery;
class PhraseQuery {
    /** @ignore */
    inner;
    /**
     * Creates an instance of `PhraseQuery`.
     *
     * @param query - The phrase to search for in the specified column.
     * @param column - The name of the column to search within.
     * @param options - Optional parameters for the phrase query.
     *   - `slop`: The maximum number of intervening unmatched positions allowed between words in the phrase (default is 0).
     */
    constructor(query, column, options) {
        this.inner = native_1.JsFullTextQuery.phraseQuery(query, column, options?.slop ?? 0);
    }
    queryType() {
        return FullTextQueryType.MatchPhrase;
    }
}
exports.PhraseQuery = PhraseQuery;
class BoostQuery {
    /** @ignore */
    inner;
    /**
     * Creates an instance of BoostQuery.
     * The boost returns documents that match the positive query,
     * but penalizes those that match the negative query.
     * the penalty is controlled by the `negativeBoost` parameter.
     *
     * @param positive - The positive query that boosts the relevance score.
     * @param negative - The negative query that reduces the relevance score.
     * @param options - Optional parameters for the boost query.
     *  - `negativeBoost`: The boost factor for the negative query (default is 0.0).
     */
    constructor(positive, negative, options) {
        this.inner = native_1.JsFullTextQuery.boostQuery(positive.inner, negative.inner, options?.negativeBoost);
    }
    queryType() {
        return FullTextQueryType.Boost;
    }
}
exports.BoostQuery = BoostQuery;
class MultiMatchQuery {
    /** @ignore */
    inner;
    /**
     * Creates an instance of MultiMatchQuery.
     *
     * @param query - The text query to search for across multiple columns.
     * @param columns - An array of column names to search within.
     * @param options - Optional parameters for the multi-match query.
     *  - `boosts`: An array of boost factors for each column (default is 1.0 for all).
     *  - `operator`: The logical operator to use for combining terms in the query (default is "OR").
     */
    constructor(query, columns, options) {
        this.inner = native_1.JsFullTextQuery.multiMatchQuery(query, columns, options?.boosts, options?.operator ?? Operator.Or);
    }
    queryType() {
        return FullTextQueryType.MultiMatch;
    }
}
exports.MultiMatchQuery = MultiMatchQuery;
class BooleanQuery {
    /** @ignore */
    inner;
    /**
     * Creates an instance of BooleanQuery.
     *
     * @param queries - An array of (Occur, FullTextQuery objects) to combine.
     * Occur specifies whether the query must match, or should match.
     */
    constructor(queries) {
        this.inner = native_1.JsFullTextQuery.booleanQuery(queries.map(([occur, query]) => [occur, query.inner]));
    }
    queryType() {
        return FullTextQueryType.Boolean;
    }
}
exports.BooleanQuery = BooleanQuery;


/***/ }),
/* 188 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* tslint:disable */
/* eslint-disable */
/* prettier-ignore */
/* auto-generated by NAPI-RS */
const { existsSync, readFileSync } = __webpack_require__(6);
const { join } = __webpack_require__(25);
const { platform, arch } = process;
let nativeBinding = null;
let localFileExisted = false;
let loadError = null;
function isMusl() {
    // For Node 10
    if (!process.report || typeof process.report.getReport !== 'function') {
        try {
            const lddPath = (__webpack_require__(189).execSync)('which ldd').toString().trim();
            return readFileSync(lddPath, 'utf8').includes('musl');
        }
        catch (e) {
            return true;
        }
    }
    else {
        const { glibcVersionRuntime } = process.report.getReport().header;
        return !glibcVersionRuntime;
    }
}
switch (platform) {
    case 'android':
        switch (arch) {
            case 'arm64':
                localFileExisted = existsSync(join(__dirname, 'lancedb.android-arm64.node'));
                try {
                    if (localFileExisted) {
                        nativeBinding = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module './lancedb.android-arm64.node'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
                    }
                    else {
                        nativeBinding = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module '@lancedb/lancedb-android-arm64'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
                    }
                }
                catch (e) {
                    loadError = e;
                }
                break;
            case 'arm':
                localFileExisted = existsSync(join(__dirname, 'lancedb.android-arm-eabi.node'));
                try {
                    if (localFileExisted) {
                        nativeBinding = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module './lancedb.android-arm-eabi.node'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
                    }
                    else {
                        nativeBinding = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module '@lancedb/lancedb-android-arm-eabi'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
                    }
                }
                catch (e) {
                    loadError = e;
                }
                break;
            default:
                throw new Error(`Unsupported architecture on Android ${arch}`);
        }
        break;
    case 'win32':
        switch (arch) {
            case 'x64':
                localFileExisted = existsSync(join(__dirname, 'lancedb.win32-x64-msvc.node'));
                try {
                    if (localFileExisted) {
                        nativeBinding = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module './lancedb.win32-x64-msvc.node'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
                    }
                    else {
                        nativeBinding = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module '@lancedb/lancedb-win32-x64-msvc'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
                    }
                }
                catch (e) {
                    loadError = e;
                }
                break;
            case 'ia32':
                localFileExisted = existsSync(join(__dirname, 'lancedb.win32-ia32-msvc.node'));
                try {
                    if (localFileExisted) {
                        nativeBinding = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module './lancedb.win32-ia32-msvc.node'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
                    }
                    else {
                        nativeBinding = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module '@lancedb/lancedb-win32-ia32-msvc'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
                    }
                }
                catch (e) {
                    loadError = e;
                }
                break;
            case 'arm64':
                localFileExisted = existsSync(join(__dirname, 'lancedb.win32-arm64-msvc.node'));
                try {
                    if (localFileExisted) {
                        nativeBinding = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module './lancedb.win32-arm64-msvc.node'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
                    }
                    else {
                        nativeBinding = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module '@lancedb/lancedb-win32-arm64-msvc'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
                    }
                }
                catch (e) {
                    loadError = e;
                }
                break;
            default:
                throw new Error(`Unsupported architecture on Windows: ${arch}`);
        }
        break;
    case 'darwin':
        localFileExisted = existsSync(join(__dirname, 'lancedb.darwin-universal.node'));
        try {
            if (localFileExisted) {
                nativeBinding = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module './lancedb.darwin-universal.node'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
            }
            else {
                nativeBinding = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module '@lancedb/lancedb-darwin-universal'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
            }
            break;
        }
        catch { }
        switch (arch) {
            case 'x64':
                localFileExisted = existsSync(join(__dirname, 'lancedb.darwin-x64.node'));
                try {
                    if (localFileExisted) {
                        nativeBinding = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module './lancedb.darwin-x64.node'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
                    }
                    else {
                        nativeBinding = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module '@lancedb/lancedb-darwin-x64'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
                    }
                }
                catch (e) {
                    loadError = e;
                }
                break;
            case 'arm64':
                localFileExisted = existsSync(join(__dirname, 'lancedb.darwin-arm64.node'));
                try {
                    if (localFileExisted) {
                        nativeBinding = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module './lancedb.darwin-arm64.node'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
                    }
                    else {
                        nativeBinding = __webpack_require__(190);
                    }
                }
                catch (e) {
                    loadError = e;
                }
                break;
            default:
                throw new Error(`Unsupported architecture on macOS: ${arch}`);
        }
        break;
    case 'freebsd':
        if (arch !== 'x64') {
            throw new Error(`Unsupported architecture on FreeBSD: ${arch}`);
        }
        localFileExisted = existsSync(join(__dirname, 'lancedb.freebsd-x64.node'));
        try {
            if (localFileExisted) {
                nativeBinding = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module './lancedb.freebsd-x64.node'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
            }
            else {
                nativeBinding = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module '@lancedb/lancedb-freebsd-x64'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
            }
        }
        catch (e) {
            loadError = e;
        }
        break;
    case 'linux':
        switch (arch) {
            case 'x64':
                if (isMusl()) {
                    localFileExisted = existsSync(join(__dirname, 'lancedb.linux-x64-musl.node'));
                    try {
                        if (localFileExisted) {
                            nativeBinding = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module './lancedb.linux-x64-musl.node'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
                        }
                        else {
                            nativeBinding = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module '@lancedb/lancedb-linux-x64-musl'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
                        }
                    }
                    catch (e) {
                        loadError = e;
                    }
                }
                else {
                    localFileExisted = existsSync(join(__dirname, 'lancedb.linux-x64-gnu.node'));
                    try {
                        if (localFileExisted) {
                            nativeBinding = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module './lancedb.linux-x64-gnu.node'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
                        }
                        else {
                            nativeBinding = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module '@lancedb/lancedb-linux-x64-gnu'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
                        }
                    }
                    catch (e) {
                        loadError = e;
                    }
                }
                break;
            case 'arm64':
                if (isMusl()) {
                    localFileExisted = existsSync(join(__dirname, 'lancedb.linux-arm64-musl.node'));
                    try {
                        if (localFileExisted) {
                            nativeBinding = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module './lancedb.linux-arm64-musl.node'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
                        }
                        else {
                            nativeBinding = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module '@lancedb/lancedb-linux-arm64-musl'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
                        }
                    }
                    catch (e) {
                        loadError = e;
                    }
                }
                else {
                    localFileExisted = existsSync(join(__dirname, 'lancedb.linux-arm64-gnu.node'));
                    try {
                        if (localFileExisted) {
                            nativeBinding = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module './lancedb.linux-arm64-gnu.node'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
                        }
                        else {
                            nativeBinding = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module '@lancedb/lancedb-linux-arm64-gnu'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
                        }
                    }
                    catch (e) {
                        loadError = e;
                    }
                }
                break;
            case 'arm':
                if (isMusl()) {
                    localFileExisted = existsSync(join(__dirname, 'lancedb.linux-arm-musleabihf.node'));
                    try {
                        if (localFileExisted) {
                            nativeBinding = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module './lancedb.linux-arm-musleabihf.node'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
                        }
                        else {
                            nativeBinding = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module '@lancedb/lancedb-linux-arm-musleabihf'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
                        }
                    }
                    catch (e) {
                        loadError = e;
                    }
                }
                else {
                    localFileExisted = existsSync(join(__dirname, 'lancedb.linux-arm-gnueabihf.node'));
                    try {
                        if (localFileExisted) {
                            nativeBinding = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module './lancedb.linux-arm-gnueabihf.node'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
                        }
                        else {
                            nativeBinding = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module '@lancedb/lancedb-linux-arm-gnueabihf'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
                        }
                    }
                    catch (e) {
                        loadError = e;
                    }
                }
                break;
            case 'riscv64':
                if (isMusl()) {
                    localFileExisted = existsSync(join(__dirname, 'lancedb.linux-riscv64-musl.node'));
                    try {
                        if (localFileExisted) {
                            nativeBinding = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module './lancedb.linux-riscv64-musl.node'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
                        }
                        else {
                            nativeBinding = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module '@lancedb/lancedb-linux-riscv64-musl'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
                        }
                    }
                    catch (e) {
                        loadError = e;
                    }
                }
                else {
                    localFileExisted = existsSync(join(__dirname, 'lancedb.linux-riscv64-gnu.node'));
                    try {
                        if (localFileExisted) {
                            nativeBinding = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module './lancedb.linux-riscv64-gnu.node'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
                        }
                        else {
                            nativeBinding = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module '@lancedb/lancedb-linux-riscv64-gnu'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
                        }
                    }
                    catch (e) {
                        loadError = e;
                    }
                }
                break;
            case 's390x':
                localFileExisted = existsSync(join(__dirname, 'lancedb.linux-s390x-gnu.node'));
                try {
                    if (localFileExisted) {
                        nativeBinding = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module './lancedb.linux-s390x-gnu.node'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
                    }
                    else {
                        nativeBinding = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module '@lancedb/lancedb-linux-s390x-gnu'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
                    }
                }
                catch (e) {
                    loadError = e;
                }
                break;
            default:
                throw new Error(`Unsupported architecture on Linux: ${arch}`);
        }
        break;
    default:
        throw new Error(`Unsupported OS: ${platform}, architecture: ${arch}`);
}
if (!nativeBinding) {
    if (loadError) {
        throw loadError;
    }
    throw new Error(`Failed to load native binding`);
}
const { Connection, JsHeaderProvider, Index, RecordBatchIterator, NativeMergeInsertBuilder, PermutationBuilder, permutationBuilder, Query, VectorQuery, TakeQuery, JsFullTextQuery, Reranker, RrfReranker, Session, Table, TagContents, Tags } = nativeBinding;
module.exports.Connection = Connection;
module.exports.JsHeaderProvider = JsHeaderProvider;
module.exports.Index = Index;
module.exports.RecordBatchIterator = RecordBatchIterator;
module.exports.NativeMergeInsertBuilder = NativeMergeInsertBuilder;
module.exports.PermutationBuilder = PermutationBuilder;
module.exports.permutationBuilder = permutationBuilder;
module.exports.Query = Query;
module.exports.VectorQuery = VectorQuery;
module.exports.TakeQuery = TakeQuery;
module.exports.JsFullTextQuery = JsFullTextQuery;
module.exports.Reranker = Reranker;
module.exports.RrfReranker = RrfReranker;
module.exports.Session = Session;
module.exports.Table = Table;
module.exports.TagContents = TagContents;
module.exports.Tags = Tags;


/***/ }),
/* 189 */
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),
/* 190 */
/***/ (() => {

throw new Error("Module parse failed: Unexpected character 'ï¿½' (1:0)\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\n(Source code omitted for this binary file)");

/***/ }),
/* 191 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// SPDX-License-Identifier: Apache-2.0
// SPDX-FileCopyrightText: Copyright The LanceDB Authors
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TTLCache = void 0;
exports.toSQL = toSQL;
exports.packBits = packBits;
function toSQL(value) {
    if (typeof value === "string") {
        return `'${value.replace(/'/g, "''")}'`;
    }
    else if (typeof value === "number") {
        return value.toString();
    }
    else if (typeof value === "boolean") {
        return value ? "TRUE" : "FALSE";
    }
    else if (value === null) {
        return "NULL";
    }
    else if (value instanceof Date) {
        return `'${value.toISOString()}'`;
    }
    else if (Array.isArray(value)) {
        return `[${value.map(toSQL).join(", ")}]`;
    }
    else if (Buffer.isBuffer(value)) {
        return `X'${value.toString("hex")}'`;
    }
    else if (value instanceof ArrayBuffer) {
        return `X'${Buffer.from(value).toString("hex")}'`;
    }
    else {
        throw new Error(`Unsupported value type: ${typeof value} value: (${value})`);
    }
}
function packBits(data) {
    const packed = Array(data.length >> 3).fill(0);
    for (let i = 0; i < data.length; i++) {
        const byte = i >> 3;
        const bit = i & 7;
        packed[byte] |= data[i] << bit;
    }
    return packed;
}
class TTLCache {
    ttl;
    // biome-ignore lint/suspicious/noExplicitAny: <explanation>
    cache;
    /**
     * @param ttl Time to live in milliseconds
     */
    constructor(ttl) {
        this.ttl = ttl;
        this.cache = new Map();
    }
    // biome-ignore lint/suspicious/noExplicitAny: <explanation>
    get(key) {
        const entry = this.cache.get(key);
        if (entry === undefined) {
            return undefined;
        }
        if (entry.expires < Date.now()) {
            this.cache.delete(key);
            return undefined;
        }
        return entry.value;
    }
    // biome-ignore lint/suspicious/noExplicitAny: <explanation>
    set(key, value) {
        this.cache.set(key, { value, expires: Date.now() + this.ttl });
    }
    delete(key) {
        this.cache.delete(key);
    }
}
exports.TTLCache = TTLCache;


/***/ }),
/* 192 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// SPDX-License-Identifier: Apache-2.0
// SPDX-FileCopyrightText: Copyright The LanceDB Authors
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Index = void 0;
const native_1 = __webpack_require__(188);
class Index {
    inner;
    constructor(inner) {
        this.inner = inner;
    }
    /**
     * Create an IvfPq index
     *
     * This index stores a compressed (quantized) copy of every vector.  These vectors
     * are grouped into partitions of similar vectors.  Each partition keeps track of
     * a centroid which is the average value of all vectors in the group.
     *
     * During a query the centroids are compared with the query vector to find the closest
     * partitions.  The compressed vectors in these partitions are then searched to find
     * the closest vectors.
     *
     * The compression scheme is called product quantization.  Each vector is divided into
     * subvectors and then each subvector is quantized into a small number of bits.  the
     * parameters `num_bits` and `num_subvectors` control this process, providing a tradeoff
     * between index size (and thus search speed) and index accuracy.
     *
     * The partitioning process is called IVF and the `num_partitions` parameter controls how
     * many groups to create.
     *
     * Note that training an IVF PQ index on a large dataset is a slow operation and
     * currently is also a memory intensive operation.
     */
    static ivfPq(options) {
        return new Index(native_1.Index.ivfPq(options?.distanceType, options?.numPartitions, options?.numSubVectors, options?.numBits, options?.maxIterations, options?.sampleRate));
    }
    /**
     * Create an IvfRq index
     *
     * IVF-RQ (RabitQ Quantization) compresses vectors using RabitQ quantization
     * and organizes them into IVF partitions.
     *
     * The compression scheme is called RabitQ quantization. Each dimension is quantized into a small number of bits.
     * The parameters `num_bits` and `num_partitions` control this process, providing a tradeoff
     * between index size (and thus search speed) and index accuracy.
     *
     * The partitioning process is called IVF and the `num_partitions` parameter controls how
     * many groups to create.
     *
     * Note that training an IVF RQ index on a large dataset is a slow operation and
     * currently is also a memory intensive operation.
     */
    static ivfRq(options) {
        return new Index(native_1.Index.ivfRq(options?.distanceType, options?.numPartitions, options?.numBits, options?.maxIterations, options?.sampleRate));
    }
    /**
     * Create an IvfFlat index
     *
     * This index groups vectors into partitions of similar vectors.  Each partition keeps track of
     * a centroid which is the average value of all vectors in the group.
     *
     * During a query the centroids are compared with the query vector to find the closest
     * partitions.  The vectors in these partitions are then searched to find
     * the closest vectors.
     *
     * The partitioning process is called IVF and the `num_partitions` parameter controls how
     * many groups to create.
     *
     * Note that training an IVF FLAT index on a large dataset is a slow operation and
     * currently is also a memory intensive operation.
     */
    static ivfFlat(options) {
        return new Index(native_1.Index.ivfFlat(options?.distanceType, options?.numPartitions, options?.maxIterations, options?.sampleRate));
    }
    /**
     * Create a btree index
     *
     * A btree index is an index on a scalar columns.  The index stores a copy of the column
     * in sorted order.  A header entry is created for each block of rows (currently the
     * block size is fixed at 4096).  These header entries are stored in a separate
     * cacheable structure (a btree).  To search for data the header is used to determine
     * which blocks need to be read from disk.
     *
     * For example, a btree index in a table with 1Bi rows requires sizeof(Scalar) * 256Ki
     * bytes of memory and will generally need to read sizeof(Scalar) * 4096 bytes to find
     * the correct row ids.
     *
     * This index is good for scalar columns with mostly distinct values and does best when
     * the query is highly selective.
     *
     * The btree index does not currently have any parameters though parameters such as the
     * block size may be added in the future.
     */
    static btree() {
        return new Index(native_1.Index.btree());
    }
    /**
     * Create a bitmap index.
     *
     * A `Bitmap` index stores a bitmap for each distinct value in the column for every row.
     *
     * This index works best for low-cardinality columns, where the number of unique values
     * is small (i.e., less than a few hundreds).
     */
    static bitmap() {
        return new Index(native_1.Index.bitmap());
    }
    /**
     * Create a label list index.
     *
     * LabelList index is a scalar index that can be used on `List<T>` columns to
     * support queries with `array_contains_all` and `array_contains_any`
     * using an underlying bitmap index.
     */
    static labelList() {
        return new Index(native_1.Index.labelList());
    }
    /**
     * Create a full text search index
     *
     * A full text search index is an index on a string column, so that you can conduct full
     * text searches on the column.
     *
     * The results of a full text search are ordered by relevance measured by BM25.
     *
     * You can combine filters with full text search.
     */
    static fts(options) {
        return new Index(native_1.Index.fts(options?.withPosition, options?.baseTokenizer, options?.language, options?.maxTokenLength, options?.lowercase, options?.stem, options?.removeStopWords, options?.asciiFolding, options?.ngramMinLength, options?.ngramMaxLength, options?.prefixOnly));
    }
    /**
     *
     * Create a hnswPq index
     *
     * HNSW-PQ stands for Hierarchical Navigable Small World - Product Quantization.
     * It is a variant of the HNSW algorithm that uses product quantization to compress
     * the vectors.
     *
     */
    static hnswPq(options) {
        return new Index(native_1.Index.hnswPq(options?.distanceType, options?.numPartitions, options?.numSubVectors, options?.maxIterations, options?.sampleRate, options?.m, options?.efConstruction));
    }
    /**
     *
     * Create a hnswSq index
     *
     * HNSW-SQ stands for Hierarchical Navigable Small World - Scalar Quantization.
     * It is a variant of the HNSW algorithm that uses scalar quantization to compress
     * the vectors.
     *
     */
    static hnswSq(options) {
        return new Index(native_1.Index.hnswSq(options?.distanceType, options?.numPartitions, options?.maxIterations, options?.sampleRate, options?.m, options?.efConstruction));
    }
}
exports.Index = Index;


/***/ }),
/* 193 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// SPDX-License-Identifier: Apache-2.0
// SPDX-FileCopyrightText: Copyright The LanceDB Authors
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OAuthHeaderProvider = exports.StaticHeaderProvider = exports.HeaderProvider = void 0;
/**
 * Header providers for LanceDB remote connections.
 *
 * This module provides a flexible header management framework for LanceDB remote
 * connections, allowing users to implement custom header strategies for
 * authentication, request tracking, custom metadata, or any other header-based
 * requirements.
 *
 * @module header
 */
/**
 * Abstract base class for providing custom headers for each request.
 *
 * Users can implement this interface to provide dynamic headers for various purposes
 * such as authentication (OAuth tokens, API keys), request tracking (correlation IDs),
 * custom metadata, or any other header-based requirements. The provider is called
 * before each request to ensure fresh header values are always used.
 *
 * @example
 * Simple JWT token provider:
 * ```typescript
 * class JWTProvider extends HeaderProvider {
 *   constructor(private token: string) {
 *     super();
 *   }
 *
 *   getHeaders(): Record<string, string> {
 *     return { authorization: `Bearer ${this.token}` };
 *   }
 * }
 * ```
 *
 * @example
 * Provider with request tracking:
 * ```typescript
 * class RequestTrackingProvider extends HeaderProvider {
 *   constructor(private sessionId: string) {
 *     super();
 *   }
 *
 *   getHeaders(): Record<string, string> {
 *     return {
 *       "X-Session-Id": this.sessionId,
 *       "X-Request-Id": `req-${Date.now()}`
 *     };
 *   }
 * }
 * ```
 */
class HeaderProvider {
}
exports.HeaderProvider = HeaderProvider;
/**
 * Example implementation: A simple header provider that returns static headers.
 *
 * This is an example implementation showing how to create a HeaderProvider
 * for cases where headers don't change during the session.
 *
 * @example
 * ```typescript
 * const provider = new StaticHeaderProvider({
 *   authorization: "Bearer my-token",
 *   "X-Custom-Header": "custom-value"
 * });
 * const headers = provider.getHeaders();
 * // Returns: {authorization: 'Bearer my-token', 'X-Custom-Header': 'custom-value'}
 * ```
 */
class StaticHeaderProvider extends HeaderProvider {
    _headers;
    /**
     * Initialize with static headers.
     * @param headers - Headers to return for every request.
     */
    constructor(headers) {
        super();
        this._headers = { ...headers };
    }
    /**
     * Return the static headers.
     * @returns Copy of the static headers.
     */
    getHeaders() {
        return { ...this._headers };
    }
}
exports.StaticHeaderProvider = StaticHeaderProvider;
/**
 * Example implementation: OAuth token provider with automatic refresh.
 *
 * This is an example implementation showing how to manage OAuth tokens
 * with automatic refresh when they expire.
 *
 * @example
 * ```typescript
 * async function fetchToken(): Promise<TokenResponse> {
 *   const response = await fetch("https://oauth.example.com/token", {
 *     method: "POST",
 *     body: JSON.stringify({
 *       grant_type: "client_credentials",
 *       client_id: "your-client-id",
 *       client_secret: "your-client-secret"
 *     }),
 *     headers: { "Content-Type": "application/json" }
 *   });
 *   const data = await response.json();
 *   return {
 *     accessToken: data.access_token,
 *     expiresIn: data.expires_in
 *   };
 * }
 *
 * const provider = new OAuthHeaderProvider(fetchToken);
 * const headers = provider.getHeaders();
 * // Returns: {"authorization": "Bearer <your-token>"}
 * ```
 */
class OAuthHeaderProvider extends HeaderProvider {
    _tokenFetcher;
    _refreshBufferSeconds;
    _currentToken = null;
    _tokenExpiresAt = null;
    _refreshPromise = null;
    /**
     * Initialize the OAuth provider.
     * @param tokenFetcher - Function to fetch new tokens. Should return object with 'accessToken' and optionally 'expiresIn'.
     * @param refreshBufferSeconds - Seconds before expiry to refresh token. Default 300 (5 minutes).
     */
    constructor(tokenFetcher, refreshBufferSeconds = 300) {
        super();
        this._tokenFetcher = tokenFetcher;
        this._refreshBufferSeconds = refreshBufferSeconds;
    }
    /**
     * Check if token needs refresh.
     */
    _needsRefresh() {
        if (this._currentToken === null) {
            return true;
        }
        if (this._tokenExpiresAt === null) {
            // No expiration info, assume token is valid
            return false;
        }
        // Refresh if we're within the buffer time of expiration
        const now = Date.now() / 1000;
        return now >= this._tokenExpiresAt - this._refreshBufferSeconds;
    }
    /**
     * Refresh the token if it's expired or close to expiring.
     */
    async _refreshTokenIfNeeded() {
        if (!this._needsRefresh()) {
            return;
        }
        // If refresh is already in progress, wait for it
        if (this._refreshPromise) {
            await this._refreshPromise;
            return;
        }
        // Start refresh
        this._refreshPromise = (async () => {
            try {
                const tokenData = await this._tokenFetcher();
                this._currentToken = tokenData.accessToken;
                if (!this._currentToken) {
                    throw new Error("Token fetcher did not return 'accessToken'");
                }
                // Set expiration if provided
                if (tokenData.expiresIn) {
                    this._tokenExpiresAt = Date.now() / 1000 + tokenData.expiresIn;
                }
                else {
                    // Token doesn't expire or expiration unknown
                    this._tokenExpiresAt = null;
                }
            }
            finally {
                this._refreshPromise = null;
            }
        })();
        await this._refreshPromise;
    }
    /**
     * Get OAuth headers, refreshing token if needed.
     * Note: This is synchronous for now as the Rust implementation expects sync.
     * In a real implementation, this would need to handle async properly.
     * @returns Headers with Bearer token authorization.
     * @throws If unable to fetch or refresh token.
     */
    getHeaders() {
        // For simplicity in this example, we assume the token is already fetched
        // In a real implementation, this would need to handle the async nature properly
        if (!this._currentToken && !this._refreshPromise) {
            // Synchronously trigger refresh - this is a limitation of the current implementation
            throw new Error("Token not initialized. Call refreshToken() first or use async initialization.");
        }
        if (!this._currentToken) {
            throw new Error("Failed to obtain OAuth token");
        }
        return { authorization: `Bearer ${this._currentToken}` };
    }
    /**
     * Manually refresh the token.
     * Call this before using getHeaders() to ensure token is available.
     */
    async refreshToken() {
        this._currentToken = null; // Force refresh
        await this._refreshTokenIfNeeded();
    }
}
exports.OAuthHeaderProvider = OAuthHeaderProvider;


/***/ }),
/* 194 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// SPDX-License-Identifier: Apache-2.0
// SPDX-FileCopyrightText: Copyright The LanceDB Authors
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextEmbeddingFunction = exports.EmbeddingFunction = void 0;
exports.LanceSchema = LanceSchema;
const arrow_1 = __webpack_require__(39);
const sanitize_1 = __webpack_require__(184);
const registry_1 = __webpack_require__(182);
var embedding_function_1 = __webpack_require__(195);
Object.defineProperty(exports, "EmbeddingFunction", ({ enumerable: true, get: function () { return embedding_function_1.EmbeddingFunction; } }));
Object.defineProperty(exports, "TextEmbeddingFunction", ({ enumerable: true, get: function () { return embedding_function_1.TextEmbeddingFunction; } }));
__exportStar(__webpack_require__(182), exports);
/**
 * Create a schema with embedding functions.
 *
 * @param fields
 * @returns Schema
 * @example
 * ```ts
 * class MyEmbeddingFunction extends EmbeddingFunction {
 * // ...
 * }
 * const func = new MyEmbeddingFunction();
 * const schema = LanceSchema({
 *   id: new Int32(),
 *   text: func.sourceField(new Utf8()),
 *   vector: func.vectorField(),
 *   // optional: specify the datatype and/or dimensions
 *   vector2: func.vectorField({ datatype: new Float32(), dims: 3}),
 * });
 *
 * const table = await db.createTable("my_table", data, { schema });
 * ```
 */
function LanceSchema(fields) {
    const arrowFields = [];
    const embeddingFunctions = new Map();
    Object.entries(fields).forEach(([key, value]) => {
        if (Array.isArray(value)) {
            const [dtype, metadata] = value;
            arrowFields.push(new arrow_1.Field(key, (0, sanitize_1.sanitizeType)(dtype), true));
            parseEmbeddingFunctions(embeddingFunctions, key, metadata);
        }
        else {
            arrowFields.push(new arrow_1.Field(key, (0, sanitize_1.sanitizeType)(value), true));
        }
    });
    const registry = (0, registry_1.getRegistry)();
    const metadata = registry.getTableMetadata(Array.from(embeddingFunctions.values()));
    const schema = new arrow_1.Schema(arrowFields, metadata);
    return schema;
}
function parseEmbeddingFunctions(embeddingFunctions, key, metadata) {
    if (metadata.has("source_column_for")) {
        const embedFunction = metadata.get("source_column_for");
        const current = embeddingFunctions.get(embedFunction);
        if (current !== undefined) {
            embeddingFunctions.set(embedFunction, {
                ...current,
                sourceColumn: key,
            });
        }
        else {
            embeddingFunctions.set(embedFunction, {
                sourceColumn: key,
                function: embedFunction,
            });
        }
    }
    else if (metadata.has("vector_column_for")) {
        const embedFunction = metadata.get("vector_column_for");
        const current = embeddingFunctions.get(embedFunction);
        if (current !== undefined) {
            embeddingFunctions.set(embedFunction, {
                ...current,
                vectorColumn: key,
            });
        }
        else {
            embeddingFunctions.set(embedFunction, {
                vectorColumn: key,
                function: embedFunction,
            });
        }
    }
}


/***/ }),
/* 195 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// SPDX-License-Identifier: Apache-2.0
// SPDX-FileCopyrightText: Copyright The LanceDB Authors
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextEmbeddingFunction = exports.EmbeddingFunction = void 0;
__webpack_require__(183);
const arrow_1 = __webpack_require__(39);
const sanitize_1 = __webpack_require__(184);
const registry_1 = __webpack_require__(182);
/**
 * An embedding function that automatically creates vector representation for a given column.
 *
 * It's important subclasses pass the **original** options to the super constructor
 * and then pass those options to `resolveVariables` to resolve any variables before
 * using them.
 *
 * @example
 * ```ts
 * class MyEmbeddingFunction extends EmbeddingFunction {
 *   constructor(options: {model: string, timeout: number}) {
 *     super(optionsRaw);
 *     const options = this.resolveVariables(optionsRaw);
 *     this.model = options.model;
 *     this.timeout = options.timeout;
 *   }
 * }
 * ```
 */
class EmbeddingFunction {
    /**
     * @ignore
     *  This is only used for associating the options type with the class for type checking
     */
    // biome-ignore lint/style/useNamingConvention: we want to keep the name as it is
    TOptions;
    #config;
    /**
     * Get the original arguments to the constructor, to serialize them so they
     * can be used to recreate the embedding function later.
     */
    // biome-ignore lint/suspicious/noExplicitAny :
    toJSON() {
        return JSON.parse(JSON.stringify(this.#config));
    }
    constructor() {
        this.#config = {};
    }
    /**
     * Provide a list of keys in the function options that should be treated as
     * sensitive. If users pass raw values for these keys, they will be rejected.
     */
    getSensitiveKeys() {
        return [];
    }
    /**
     * Apply variables to the config.
     */
    resolveVariables(config) {
        this.#config = config;
        const registry = (0, registry_1.getRegistry)();
        const newConfig = { ...config };
        for (const [key_, value] of Object.entries(newConfig)) {
            if (this.getSensitiveKeys().includes(key_) &&
                !value.startsWith("$var:")) {
                throw new Error(`The key "${key_}" is sensitive and cannot be set directly. Please use the $var: syntax to set it.`);
            }
            // Makes TS happy (https://stackoverflow.com/a/78391854)
            const key = key_;
            if (typeof value === "string" && value.startsWith("$var:")) {
                const [name, defaultValue] = value.slice(5).split(":", 2);
                const variableValue = registry.getVar(name);
                if (!variableValue) {
                    if (defaultValue) {
                        // biome-ignore lint/suspicious/noExplicitAny:
                        newConfig[key] = defaultValue;
                    }
                    else {
                        throw new Error(`Variable "${name}" not found`);
                    }
                }
                else {
                    // biome-ignore lint/suspicious/noExplicitAny:
                    newConfig[key] = variableValue;
                }
            }
        }
        return newConfig;
    }
    /**
     * sourceField is used in combination with `LanceSchema` to provide a declarative data model
     *
     * @param optionsOrDatatype - The options for the field or the datatype
     *
     * @see {@link LanceSchema}
     */
    sourceField(optionsOrDatatype) {
        let datatype = "datatype" in optionsOrDatatype
            ? optionsOrDatatype.datatype
            : optionsOrDatatype;
        if (!datatype) {
            throw new Error("Datatype is required");
        }
        datatype = (0, sanitize_1.sanitizeType)(datatype);
        const metadata = new Map();
        metadata.set("source_column_for", this);
        return [datatype, metadata];
    }
    /**
     * vectorField is used in combination with `LanceSchema` to provide a declarative data model
     *
     * @param optionsOrDatatype - The options for the field
     *
     * @see {@link LanceSchema}
     */
    vectorField(optionsOrDatatype) {
        let dtype;
        let vectorType;
        let dims = this.ndims();
        // `func.vectorField(new Float32())`
        if (optionsOrDatatype === undefined) {
            dtype = new arrow_1.Float32();
        }
        else if (!("datatype" in optionsOrDatatype)) {
            dtype = (0, sanitize_1.sanitizeType)(optionsOrDatatype);
        }
        else {
            // `func.vectorField({
            //  datatype: new Float32(),
            //  dims: 10
            // })`
            dims = dims ?? optionsOrDatatype?.dims;
            dtype = (0, sanitize_1.sanitizeType)(optionsOrDatatype?.datatype);
        }
        if (dtype !== undefined) {
            // `func.vectorField(new FixedSizeList(dims, new Field("item", new Float32(), true)))`
            // or `func.vectorField({datatype: new FixedSizeList(dims, new Field("item", new Float32(), true))})`
            if ((0, arrow_1.isFixedSizeList)(dtype)) {
                vectorType = dtype;
                // `func.vectorField(new Float32())`
                // or `func.vectorField({datatype: new Float32()})`
            }
            else if ((0, arrow_1.isFloat)(dtype)) {
                // No `ndims` impl and no `{dims: n}` provided;
                if (dims === undefined) {
                    throw new Error("ndims is required for vector field");
                }
                vectorType = (0, arrow_1.newVectorType)(dims, dtype);
            }
            else {
                throw new Error("Expected FixedSizeList or Float as datatype for vector field");
            }
        }
        else {
            if (dims === undefined) {
                throw new Error("ndims is required for vector field");
            }
            vectorType = new arrow_1.FixedSizeList(dims, new arrow_1.Field("item", new arrow_1.Float32(), true));
        }
        const metadata = new Map();
        metadata.set("vector_column_for", this);
        return [vectorType, metadata];
    }
    /** The number of dimensions of the embeddings */
    ndims() {
        return undefined;
    }
    /**
    Compute the embeddings for a single query
   */
    async computeQueryEmbeddings(data) {
        return this.computeSourceEmbeddings([data]).then((embeddings) => embeddings[0]);
    }
}
exports.EmbeddingFunction = EmbeddingFunction;
/**
 * an abstract class for implementing embedding functions that take text as input
 */
class TextEmbeddingFunction extends EmbeddingFunction {
    async computeQueryEmbeddings(data) {
        return this.generateEmbeddings([data]).then((data) => data[0]);
    }
    embeddingDataType() {
        return new arrow_1.Float32();
    }
    sourceField() {
        return super.sourceField(new arrow_1.Utf8());
    }
    computeSourceEmbeddings(data) {
        return this.generateEmbeddings(data);
    }
}
exports.TextEmbeddingFunction = TextEmbeddingFunction;


/***/ }),
/* 196 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// SPDX-License-Identifier: Apache-2.0
// SPDX-FileCopyrightText: Copyright The LanceDB Authors
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PermutationBuilder = void 0;
exports.permutationBuilder = permutationBuilder;
const native_js_1 = __webpack_require__(188);
const table_1 = __webpack_require__(185);
/**
 * A PermutationBuilder for creating data permutations with splits, shuffling, and filtering.
 *
 * This class provides a TypeScript wrapper around the native Rust PermutationBuilder,
 * offering methods to configure data splits, shuffling, and filtering before executing
 * the permutation to create a new table.
 */
class PermutationBuilder {
    inner;
    /**
     * @hidden
     */
    constructor(inner) {
        this.inner = inner;
    }
    /**
     * Configure the permutation to be persisted.
     *
     * @param connection - The connection to persist the permutation to
     * @param tableName - The name of the table to create
     * @returns A new PermutationBuilder instance
     * @example
     * ```ts
     * builder.persist(connection, "permutation_table");
     * ```
     */
    persist(connection, tableName) {
        const localConnection = connection;
        const newInner = this.inner.persist(localConnection.inner, tableName);
        return new PermutationBuilder(newInner);
    }
    /**
     * Configure random splits for the permutation.
     *
     * @param options - Configuration for random splitting
     * @returns A new PermutationBuilder instance
     * @example
     * ```ts
     * // Split by ratios
     * builder.splitRandom({ ratios: [0.7, 0.3], seed: 42 });
     *
     * // Split by counts
     * builder.splitRandom({ counts: [1000, 500], seed: 42 });
     *
     * // Split with fixed size
     * builder.splitRandom({ fixed: 100, seed: 42 });
     * ```
     */
    splitRandom(options) {
        const newInner = this.inner.splitRandom(options);
        return new PermutationBuilder(newInner);
    }
    /**
     * Configure hash-based splits for the permutation.
     *
     * @param options - Configuration for hash-based splitting
     * @returns A new PermutationBuilder instance
     * @example
     * ```ts
     * builder.splitHash({
     *   columns: ["user_id"],
     *   splitWeights: [70, 30],
     *   discardWeight: 0
     * });
     * ```
     */
    splitHash(options) {
        const newInner = this.inner.splitHash(options);
        return new PermutationBuilder(newInner);
    }
    /**
     * Configure sequential splits for the permutation.
     *
     * @param options - Configuration for sequential splitting
     * @returns A new PermutationBuilder instance
     * @example
     * ```ts
     * // Split by ratios
     * builder.splitSequential({ ratios: [0.8, 0.2] });
     *
     * // Split by counts
     * builder.splitSequential({ counts: [800, 200] });
     *
     * // Split with fixed size
     * builder.splitSequential({ fixed: 1000 });
     * ```
     */
    splitSequential(options) {
        const newInner = this.inner.splitSequential(options);
        return new PermutationBuilder(newInner);
    }
    /**
     * Configure calculated splits for the permutation.
     *
     * @param options - Configuration for calculated splitting
     * @returns A new PermutationBuilder instance
     * @example
     * ```ts
     * builder.splitCalculated("user_id % 3");
     * ```
     */
    splitCalculated(options) {
        const newInner = this.inner.splitCalculated(options);
        return new PermutationBuilder(newInner);
    }
    /**
     * Configure shuffling for the permutation.
     *
     * @param options - Configuration for shuffling
     * @returns A new PermutationBuilder instance
     * @example
     * ```ts
     * // Basic shuffle
     * builder.shuffle({ seed: 42 });
     *
     * // Shuffle with clump size
     * builder.shuffle({ seed: 42, clumpSize: 10 });
     * ```
     */
    shuffle(options) {
        const newInner = this.inner.shuffle(options);
        return new PermutationBuilder(newInner);
    }
    /**
     * Configure filtering for the permutation.
     *
     * @param filter - SQL filter expression
     * @returns A new PermutationBuilder instance
     * @example
     * ```ts
     * builder.filter("age > 18 AND status = 'active'");
     * ```
     */
    filter(filter) {
        const newInner = this.inner.filter(filter);
        return new PermutationBuilder(newInner);
    }
    /**
     * Execute the permutation and create the destination table.
     *
     * @returns A Promise that resolves to the new Table instance
     * @example
     * ```ts
     * const permutationTable = await builder.execute();
     * console.log(`Created table: ${permutationTable.name}`);
     * ```
     */
    async execute() {
        const nativeTable = await this.inner.execute();
        return new table_1.LocalTable(nativeTable);
    }
}
exports.PermutationBuilder = PermutationBuilder;
/**
 * Create a permutation builder for the given table.
 *
 * @param table - The source table to create a permutation from
 * @returns A PermutationBuilder instance
 * @example
 * ```ts
 * const builder = permutationBuilder(sourceTable, "training_data")
 *   .splitRandom({ ratios: [0.8, 0.2], seed: 42 })
 *   .shuffle({ seed: 123 });
 *
 * const trainingTable = await builder.execute();
 * ```
 */
function permutationBuilder(table) {
    // Extract the inner native table from the TypeScript wrapper
    const localTable = table;
    // Access inner through type assertion since it's private
    const nativeBuilder = (0, native_js_1.permutationBuilder)(
    // biome-ignore lint/suspicious/noExplicitAny: need access to private variable
    localTable.inner);
    return new PermutationBuilder(nativeBuilder);
}


/***/ }),
/* 197 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// SPDX-License-Identifier: Apache-2.0
// SPDX-FileCopyrightText: Copyright The LanceDB Authors
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(198), exports);


/***/ }),
/* 198 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// SPDX-License-Identifier: Apache-2.0
// SPDX-FileCopyrightText: Copyright The LanceDB Authors
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RRFReranker = void 0;
const arrow_1 = __webpack_require__(39);
const native_1 = __webpack_require__(188);
/**
 * Reranks the results using the Reciprocal Rank Fusion (RRF) algorithm.
 *
 * @hideconstructor
 */
class RRFReranker {
    inner;
    /** @ignore */
    constructor(inner) {
        this.inner = inner;
    }
    static async create(k = 60) {
        return new RRFReranker(await native_1.RrfReranker.tryNew(new Float32Array([k])));
    }
    async rerankHybrid(query, vecResults, ftsResults) {
        const buffer = await this.inner.rerankHybrid(query, await (0, arrow_1.fromRecordBatchToBuffer)(vecResults), await (0, arrow_1.fromRecordBatchToBuffer)(ftsResults));
        const recordBatch = await (0, arrow_1.fromBufferToRecordBatch)(buffer);
        return recordBatch;
    }
}
exports.RRFReranker = RRFReranker;


/***/ }),
/* 199 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NIL: () => (/* reexport safe */ _nil_js__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   parse: () => (/* reexport safe */ _parse_js__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   stringify: () => (/* reexport safe */ _stringify_js__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   v1: () => (/* reexport safe */ _v1_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   v3: () => (/* reexport safe */ _v3_js__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   v4: () => (/* reexport safe */ _v4_js__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   v5: () => (/* reexport safe */ _v5_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   validate: () => (/* reexport safe */ _validate_js__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   version: () => (/* reexport safe */ _version_js__WEBPACK_IMPORTED_MODULE_5__["default"])
/* harmony export */ });
/* harmony import */ var _v1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(200);
/* harmony import */ var _v3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(206);
/* harmony import */ var _v4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(210);
/* harmony import */ var _v5_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(212);
/* harmony import */ var _nil_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(214);
/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(215);
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(204);
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(203);
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(208);










/***/ }),
/* 200 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(201);
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(203);

 // **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

let _nodeId;

let _clockseq; // Previous uuid creation time


let _lastMSecs = 0;
let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__["default"])();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(b);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v1);

/***/ }),
/* 201 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ rng)
/* harmony export */ });
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(202);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);

const rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate

let poolPtr = rnds8Pool.length;
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    crypto__WEBPACK_IMPORTED_MODULE_0___default().randomFillSync(rnds8Pool);
    poolPtr = 0;
  }

  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}

/***/ }),
/* 202 */
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),
/* 203 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   unsafeStringify: () => (/* binding */ unsafeStringify)
/* harmony export */ });
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(204);

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).slice(1));
}

function unsafeStringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

function stringify(arr, offset = 0) {
  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);

/***/ }),
/* 204 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(205);


function validate(uuid) {
  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__["default"].test(uuid);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);

/***/ }),
/* 205 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);

/***/ }),
/* 206 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(207);
/* harmony import */ var _md5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(209);


const v3 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__["default"])('v3', 0x30, _md5_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v3);

/***/ }),
/* 207 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DNS: () => (/* binding */ DNS),
/* harmony export */   URL: () => (/* binding */ URL),
/* harmony export */   "default": () => (/* binding */ v35)
/* harmony export */ });
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(203);
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(208);



function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  const bytes = [];

  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
function v35(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;

    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = (0,_parse_js__WEBPACK_IMPORTED_MODULE_1__["default"])(namespace);
    }

    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_0__.unsafeStringify)(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}

/***/ }),
/* 208 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(204);


function parse(uuid) {
  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
    throw TypeError('Invalid UUID');
  }

  let v;
  const arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parse);

/***/ }),
/* 209 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(202);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);


function md5(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === 'string') {
    bytes = Buffer.from(bytes, 'utf8');
  }

  return crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash('md5').update(bytes).digest();
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (md5);

/***/ }),
/* 210 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(211);
/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(201);
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(203);




function v4(options, buf, offset) {
  if (_native_js__WEBPACK_IMPORTED_MODULE_0__["default"].randomUUID && !buf && !options) {
    return _native_js__WEBPACK_IMPORTED_MODULE_0__["default"].randomUUID();
  }

  options = options || {};
  const rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_1__["default"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.unsafeStringify)(rnds);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);

/***/ }),
/* 211 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(202);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  randomUUID: (crypto__WEBPACK_IMPORTED_MODULE_0___default().randomUUID)
});

/***/ }),
/* 212 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(207);
/* harmony import */ var _sha1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(213);


const v5 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__["default"])('v5', 0x50, _sha1_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v5);

/***/ }),
/* 213 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(202);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);


function sha1(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === 'string') {
    bytes = Buffer.from(bytes, 'utf8');
  }

  return crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash('sha1').update(bytes).digest();
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sha1);

/***/ }),
/* 214 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ('00000000-0000-0000-0000-000000000000');

/***/ }),
/* 215 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(204);


function version(uuid) {
  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
    throw TypeError('Invalid UUID');
  }

  return parseInt(uuid.slice(14, 15), 16);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (version);

/***/ }),
/* 216 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.generateEmbedding = generateEmbedding;
exports.generateEmbeddings = generateEmbeddings;
const generative_ai_1 = __webpack_require__(217);
let genAI = null;
function getGenAI() {
    if (!genAI) {
        if (!process.env.GEMINI_API_KEY) {
            throw new Error('GEMINI_API_KEY is not set');
        }
        genAI = new generative_ai_1.GoogleGenerativeAI(process.env.GEMINI_API_KEY);
    }
    return genAI;
}
async function generateEmbedding(text) {
    const model = getGenAI().getGenerativeModel({ model: 'text-embedding-004' });
    const result = await model.embedContent(text);
    return result.embedding.values;
}
async function generateEmbeddings(texts) {
    return Promise.all(texts.map(generateEmbedding));
}


/***/ }),
/* 217 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * Contains the list of OpenAPI data types
 * as defined by https://swagger.io/docs/specification/data-models/data-types/
 * @public
 */
exports.SchemaType = void 0;
(function (SchemaType) {
    /** String type. */
    SchemaType["STRING"] = "string";
    /** Number type. */
    SchemaType["NUMBER"] = "number";
    /** Integer type. */
    SchemaType["INTEGER"] = "integer";
    /** Boolean type. */
    SchemaType["BOOLEAN"] = "boolean";
    /** Array type. */
    SchemaType["ARRAY"] = "array";
    /** Object type. */
    SchemaType["OBJECT"] = "object";
})(exports.SchemaType || (exports.SchemaType = {}));

/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @public
 */
exports.ExecutableCodeLanguage = void 0;
(function (ExecutableCodeLanguage) {
    ExecutableCodeLanguage["LANGUAGE_UNSPECIFIED"] = "language_unspecified";
    ExecutableCodeLanguage["PYTHON"] = "python";
})(exports.ExecutableCodeLanguage || (exports.ExecutableCodeLanguage = {}));
/**
 * Possible outcomes of code execution.
 * @public
 */
exports.Outcome = void 0;
(function (Outcome) {
    /**
     * Unspecified status. This value should not be used.
     */
    Outcome["OUTCOME_UNSPECIFIED"] = "outcome_unspecified";
    /**
     * Code execution completed successfully.
     */
    Outcome["OUTCOME_OK"] = "outcome_ok";
    /**
     * Code execution finished but with a failure. `stderr` should contain the
     * reason.
     */
    Outcome["OUTCOME_FAILED"] = "outcome_failed";
    /**
     * Code execution ran for too long, and was cancelled. There may or may not
     * be a partial output present.
     */
    Outcome["OUTCOME_DEADLINE_EXCEEDED"] = "outcome_deadline_exceeded";
})(exports.Outcome || (exports.Outcome = {}));

/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Possible roles.
 * @public
 */
const POSSIBLE_ROLES = ["user", "model", "function", "system"];
/**
 * Harm categories that would cause prompts or candidates to be blocked.
 * @public
 */
exports.HarmCategory = void 0;
(function (HarmCategory) {
    HarmCategory["HARM_CATEGORY_UNSPECIFIED"] = "HARM_CATEGORY_UNSPECIFIED";
    HarmCategory["HARM_CATEGORY_HATE_SPEECH"] = "HARM_CATEGORY_HATE_SPEECH";
    HarmCategory["HARM_CATEGORY_SEXUALLY_EXPLICIT"] = "HARM_CATEGORY_SEXUALLY_EXPLICIT";
    HarmCategory["HARM_CATEGORY_HARASSMENT"] = "HARM_CATEGORY_HARASSMENT";
    HarmCategory["HARM_CATEGORY_DANGEROUS_CONTENT"] = "HARM_CATEGORY_DANGEROUS_CONTENT";
    HarmCategory["HARM_CATEGORY_CIVIC_INTEGRITY"] = "HARM_CATEGORY_CIVIC_INTEGRITY";
})(exports.HarmCategory || (exports.HarmCategory = {}));
/**
 * Threshold above which a prompt or candidate will be blocked.
 * @public
 */
exports.HarmBlockThreshold = void 0;
(function (HarmBlockThreshold) {
    /** Threshold is unspecified. */
    HarmBlockThreshold["HARM_BLOCK_THRESHOLD_UNSPECIFIED"] = "HARM_BLOCK_THRESHOLD_UNSPECIFIED";
    /** Content with NEGLIGIBLE will be allowed. */
    HarmBlockThreshold["BLOCK_LOW_AND_ABOVE"] = "BLOCK_LOW_AND_ABOVE";
    /** Content with NEGLIGIBLE and LOW will be allowed. */
    HarmBlockThreshold["BLOCK_MEDIUM_AND_ABOVE"] = "BLOCK_MEDIUM_AND_ABOVE";
    /** Content with NEGLIGIBLE, LOW, and MEDIUM will be allowed. */
    HarmBlockThreshold["BLOCK_ONLY_HIGH"] = "BLOCK_ONLY_HIGH";
    /** All content will be allowed. */
    HarmBlockThreshold["BLOCK_NONE"] = "BLOCK_NONE";
})(exports.HarmBlockThreshold || (exports.HarmBlockThreshold = {}));
/**
 * Probability that a prompt or candidate matches a harm category.
 * @public
 */
exports.HarmProbability = void 0;
(function (HarmProbability) {
    /** Probability is unspecified. */
    HarmProbability["HARM_PROBABILITY_UNSPECIFIED"] = "HARM_PROBABILITY_UNSPECIFIED";
    /** Content has a negligible chance of being unsafe. */
    HarmProbability["NEGLIGIBLE"] = "NEGLIGIBLE";
    /** Content has a low chance of being unsafe. */
    HarmProbability["LOW"] = "LOW";
    /** Content has a medium chance of being unsafe. */
    HarmProbability["MEDIUM"] = "MEDIUM";
    /** Content has a high chance of being unsafe. */
    HarmProbability["HIGH"] = "HIGH";
})(exports.HarmProbability || (exports.HarmProbability = {}));
/**
 * Reason that a prompt was blocked.
 * @public
 */
exports.BlockReason = void 0;
(function (BlockReason) {
    // A blocked reason was not specified.
    BlockReason["BLOCKED_REASON_UNSPECIFIED"] = "BLOCKED_REASON_UNSPECIFIED";
    // Content was blocked by safety settings.
    BlockReason["SAFETY"] = "SAFETY";
    // Content was blocked, but the reason is uncategorized.
    BlockReason["OTHER"] = "OTHER";
})(exports.BlockReason || (exports.BlockReason = {}));
/**
 * Reason that a candidate finished.
 * @public
 */
exports.FinishReason = void 0;
(function (FinishReason) {
    // Default value. This value is unused.
    FinishReason["FINISH_REASON_UNSPECIFIED"] = "FINISH_REASON_UNSPECIFIED";
    // Natural stop point of the model or provided stop sequence.
    FinishReason["STOP"] = "STOP";
    // The maximum number of tokens as specified in the request was reached.
    FinishReason["MAX_TOKENS"] = "MAX_TOKENS";
    // The candidate content was flagged for safety reasons.
    FinishReason["SAFETY"] = "SAFETY";
    // The candidate content was flagged for recitation reasons.
    FinishReason["RECITATION"] = "RECITATION";
    // The candidate content was flagged for using an unsupported language.
    FinishReason["LANGUAGE"] = "LANGUAGE";
    // Token generation stopped because the content contains forbidden terms.
    FinishReason["BLOCKLIST"] = "BLOCKLIST";
    // Token generation stopped for potentially containing prohibited content.
    FinishReason["PROHIBITED_CONTENT"] = "PROHIBITED_CONTENT";
    // Token generation stopped because the content potentially contains Sensitive Personally Identifiable Information (SPII).
    FinishReason["SPII"] = "SPII";
    // The function call generated by the model is invalid.
    FinishReason["MALFORMED_FUNCTION_CALL"] = "MALFORMED_FUNCTION_CALL";
    // Unknown reason.
    FinishReason["OTHER"] = "OTHER";
})(exports.FinishReason || (exports.FinishReason = {}));
/**
 * Task type for embedding content.
 * @public
 */
exports.TaskType = void 0;
(function (TaskType) {
    TaskType["TASK_TYPE_UNSPECIFIED"] = "TASK_TYPE_UNSPECIFIED";
    TaskType["RETRIEVAL_QUERY"] = "RETRIEVAL_QUERY";
    TaskType["RETRIEVAL_DOCUMENT"] = "RETRIEVAL_DOCUMENT";
    TaskType["SEMANTIC_SIMILARITY"] = "SEMANTIC_SIMILARITY";
    TaskType["CLASSIFICATION"] = "CLASSIFICATION";
    TaskType["CLUSTERING"] = "CLUSTERING";
})(exports.TaskType || (exports.TaskType = {}));
/**
 * @public
 */
exports.FunctionCallingMode = void 0;
(function (FunctionCallingMode) {
    // Unspecified function calling mode. This value should not be used.
    FunctionCallingMode["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
    // Default model behavior, model decides to predict either a function call
    // or a natural language repspose.
    FunctionCallingMode["AUTO"] = "AUTO";
    // Model is constrained to always predicting a function call only.
    // If "allowed_function_names" are set, the predicted function call will be
    // limited to any one of "allowed_function_names", else the predicted
    // function call will be any one of the provided "function_declarations".
    FunctionCallingMode["ANY"] = "ANY";
    // Model will not predict any function call. Model behavior is same as when
    // not passing any function declarations.
    FunctionCallingMode["NONE"] = "NONE";
})(exports.FunctionCallingMode || (exports.FunctionCallingMode = {}));
/**
 * The mode of the predictor to be used in dynamic retrieval.
 * @public
 */
exports.DynamicRetrievalMode = void 0;
(function (DynamicRetrievalMode) {
    // Unspecified function calling mode. This value should not be used.
    DynamicRetrievalMode["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
    // Run retrieval only when system decides it is necessary.
    DynamicRetrievalMode["MODE_DYNAMIC"] = "MODE_DYNAMIC";
})(exports.DynamicRetrievalMode || (exports.DynamicRetrievalMode = {}));

/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Basic error type for this SDK.
 * @public
 */
class GoogleGenerativeAIError extends Error {
    constructor(message) {
        super(`[GoogleGenerativeAI Error]: ${message}`);
    }
}
/**
 * Errors in the contents of a response from the model. This includes parsing
 * errors, or responses including a safety block reason.
 * @public
 */
class GoogleGenerativeAIResponseError extends GoogleGenerativeAIError {
    constructor(message, response) {
        super(message);
        this.response = response;
    }
}
/**
 * Error class covering HTTP errors when calling the server. Includes HTTP
 * status, statusText, and optional details, if provided in the server response.
 * @public
 */
class GoogleGenerativeAIFetchError extends GoogleGenerativeAIError {
    constructor(message, status, statusText, errorDetails) {
        super(message);
        this.status = status;
        this.statusText = statusText;
        this.errorDetails = errorDetails;
    }
}
/**
 * Errors in the contents of a request originating from user input.
 * @public
 */
class GoogleGenerativeAIRequestInputError extends GoogleGenerativeAIError {
}
/**
 * Error thrown when a request is aborted, either due to a timeout or
 * intentional cancellation by the user.
 * @public
 */
class GoogleGenerativeAIAbortError extends GoogleGenerativeAIError {
}

/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_BASE_URL = "https://generativelanguage.googleapis.com";
const DEFAULT_API_VERSION = "v1beta";
/**
 * We can't `require` package.json if this runs on web. We will use rollup to
 * swap in the version number here at build time.
 */
const PACKAGE_VERSION = "0.24.1";
const PACKAGE_LOG_HEADER = "genai-js";
var Task;
(function (Task) {
    Task["GENERATE_CONTENT"] = "generateContent";
    Task["STREAM_GENERATE_CONTENT"] = "streamGenerateContent";
    Task["COUNT_TOKENS"] = "countTokens";
    Task["EMBED_CONTENT"] = "embedContent";
    Task["BATCH_EMBED_CONTENTS"] = "batchEmbedContents";
})(Task || (Task = {}));
class RequestUrl {
    constructor(model, task, apiKey, stream, requestOptions) {
        this.model = model;
        this.task = task;
        this.apiKey = apiKey;
        this.stream = stream;
        this.requestOptions = requestOptions;
    }
    toString() {
        var _a, _b;
        const apiVersion = ((_a = this.requestOptions) === null || _a === void 0 ? void 0 : _a.apiVersion) || DEFAULT_API_VERSION;
        const baseUrl = ((_b = this.requestOptions) === null || _b === void 0 ? void 0 : _b.baseUrl) || DEFAULT_BASE_URL;
        let url = `${baseUrl}/${apiVersion}/${this.model}:${this.task}`;
        if (this.stream) {
            url += "?alt=sse";
        }
        return url;
    }
}
/**
 * Simple, but may become more complex if we add more versions to log.
 */
function getClientHeaders(requestOptions) {
    const clientHeaders = [];
    if (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.apiClient) {
        clientHeaders.push(requestOptions.apiClient);
    }
    clientHeaders.push(`${PACKAGE_LOG_HEADER}/${PACKAGE_VERSION}`);
    return clientHeaders.join(" ");
}
async function getHeaders(url) {
    var _a;
    const headers = new Headers();
    headers.append("Content-Type", "application/json");
    headers.append("x-goog-api-client", getClientHeaders(url.requestOptions));
    headers.append("x-goog-api-key", url.apiKey);
    let customHeaders = (_a = url.requestOptions) === null || _a === void 0 ? void 0 : _a.customHeaders;
    if (customHeaders) {
        if (!(customHeaders instanceof Headers)) {
            try {
                customHeaders = new Headers(customHeaders);
            }
            catch (e) {
                throw new GoogleGenerativeAIRequestInputError(`unable to convert customHeaders value ${JSON.stringify(customHeaders)} to Headers: ${e.message}`);
            }
        }
        for (const [headerName, headerValue] of customHeaders.entries()) {
            if (headerName === "x-goog-api-key") {
                throw new GoogleGenerativeAIRequestInputError(`Cannot set reserved header name ${headerName}`);
            }
            else if (headerName === "x-goog-api-client") {
                throw new GoogleGenerativeAIRequestInputError(`Header name ${headerName} can only be set using the apiClient field`);
            }
            headers.append(headerName, headerValue);
        }
    }
    return headers;
}
async function constructModelRequest(model, task, apiKey, stream, body, requestOptions) {
    const url = new RequestUrl(model, task, apiKey, stream, requestOptions);
    return {
        url: url.toString(),
        fetchOptions: Object.assign(Object.assign({}, buildFetchOptions(requestOptions)), { method: "POST", headers: await getHeaders(url), body }),
    };
}
async function makeModelRequest(model, task, apiKey, stream, body, requestOptions = {}, 
// Allows this to be stubbed for tests
fetchFn = fetch) {
    const { url, fetchOptions } = await constructModelRequest(model, task, apiKey, stream, body, requestOptions);
    return makeRequest(url, fetchOptions, fetchFn);
}
async function makeRequest(url, fetchOptions, fetchFn = fetch) {
    let response;
    try {
        response = await fetchFn(url, fetchOptions);
    }
    catch (e) {
        handleResponseError(e, url);
    }
    if (!response.ok) {
        await handleResponseNotOk(response, url);
    }
    return response;
}
function handleResponseError(e, url) {
    let err = e;
    if (err.name === "AbortError") {
        err = new GoogleGenerativeAIAbortError(`Request aborted when fetching ${url.toString()}: ${e.message}`);
        err.stack = e.stack;
    }
    else if (!(e instanceof GoogleGenerativeAIFetchError ||
        e instanceof GoogleGenerativeAIRequestInputError)) {
        err = new GoogleGenerativeAIError(`Error fetching from ${url.toString()}: ${e.message}`);
        err.stack = e.stack;
    }
    throw err;
}
async function handleResponseNotOk(response, url) {
    let message = "";
    let errorDetails;
    try {
        const json = await response.json();
        message = json.error.message;
        if (json.error.details) {
            message += ` ${JSON.stringify(json.error.details)}`;
            errorDetails = json.error.details;
        }
    }
    catch (e) {
        // ignored
    }
    throw new GoogleGenerativeAIFetchError(`Error fetching from ${url.toString()}: [${response.status} ${response.statusText}] ${message}`, response.status, response.statusText, errorDetails);
}
/**
 * Generates the request options to be passed to the fetch API.
 * @param requestOptions - The user-defined request options.
 * @returns The generated request options.
 */
function buildFetchOptions(requestOptions) {
    const fetchOptions = {};
    if ((requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.signal) !== undefined || (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeout) >= 0) {
        const controller = new AbortController();
        if ((requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeout) >= 0) {
            setTimeout(() => controller.abort(), requestOptions.timeout);
        }
        if (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.signal) {
            requestOptions.signal.addEventListener("abort", () => {
                controller.abort();
            });
        }
        fetchOptions.signal = controller.signal;
    }
    return fetchOptions;
}

/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Adds convenience helper methods to a response object, including stream
 * chunks (as long as each chunk is a complete GenerateContentResponse JSON).
 */
function addHelpers(response) {
    response.text = () => {
        if (response.candidates && response.candidates.length > 0) {
            if (response.candidates.length > 1) {
                console.warn(`This response had ${response.candidates.length} ` +
                    `candidates. Returning text from the first candidate only. ` +
                    `Access response.candidates directly to use the other candidates.`);
            }
            if (hadBadFinishReason(response.candidates[0])) {
                throw new GoogleGenerativeAIResponseError(`${formatBlockErrorMessage(response)}`, response);
            }
            return getText(response);
        }
        else if (response.promptFeedback) {
            throw new GoogleGenerativeAIResponseError(`Text not available. ${formatBlockErrorMessage(response)}`, response);
        }
        return "";
    };
    /**
     * TODO: remove at next major version
     */
    response.functionCall = () => {
        if (response.candidates && response.candidates.length > 0) {
            if (response.candidates.length > 1) {
                console.warn(`This response had ${response.candidates.length} ` +
                    `candidates. Returning function calls from the first candidate only. ` +
                    `Access response.candidates directly to use the other candidates.`);
            }
            if (hadBadFinishReason(response.candidates[0])) {
                throw new GoogleGenerativeAIResponseError(`${formatBlockErrorMessage(response)}`, response);
            }
            console.warn(`response.functionCall() is deprecated. ` +
                `Use response.functionCalls() instead.`);
            return getFunctionCalls(response)[0];
        }
        else if (response.promptFeedback) {
            throw new GoogleGenerativeAIResponseError(`Function call not available. ${formatBlockErrorMessage(response)}`, response);
        }
        return undefined;
    };
    response.functionCalls = () => {
        if (response.candidates && response.candidates.length > 0) {
            if (response.candidates.length > 1) {
                console.warn(`This response had ${response.candidates.length} ` +
                    `candidates. Returning function calls from the first candidate only. ` +
                    `Access response.candidates directly to use the other candidates.`);
            }
            if (hadBadFinishReason(response.candidates[0])) {
                throw new GoogleGenerativeAIResponseError(`${formatBlockErrorMessage(response)}`, response);
            }
            return getFunctionCalls(response);
        }
        else if (response.promptFeedback) {
            throw new GoogleGenerativeAIResponseError(`Function call not available. ${formatBlockErrorMessage(response)}`, response);
        }
        return undefined;
    };
    return response;
}
/**
 * Returns all text found in all parts of first candidate.
 */
function getText(response) {
    var _a, _b, _c, _d;
    const textStrings = [];
    if ((_b = (_a = response.candidates) === null || _a === void 0 ? void 0 : _a[0].content) === null || _b === void 0 ? void 0 : _b.parts) {
        for (const part of (_d = (_c = response.candidates) === null || _c === void 0 ? void 0 : _c[0].content) === null || _d === void 0 ? void 0 : _d.parts) {
            if (part.text) {
                textStrings.push(part.text);
            }
            if (part.executableCode) {
                textStrings.push("\n```" +
                    part.executableCode.language +
                    "\n" +
                    part.executableCode.code +
                    "\n```\n");
            }
            if (part.codeExecutionResult) {
                textStrings.push("\n```\n" + part.codeExecutionResult.output + "\n```\n");
            }
        }
    }
    if (textStrings.length > 0) {
        return textStrings.join("");
    }
    else {
        return "";
    }
}
/**
 * Returns functionCall of first candidate.
 */
function getFunctionCalls(response) {
    var _a, _b, _c, _d;
    const functionCalls = [];
    if ((_b = (_a = response.candidates) === null || _a === void 0 ? void 0 : _a[0].content) === null || _b === void 0 ? void 0 : _b.parts) {
        for (const part of (_d = (_c = response.candidates) === null || _c === void 0 ? void 0 : _c[0].content) === null || _d === void 0 ? void 0 : _d.parts) {
            if (part.functionCall) {
                functionCalls.push(part.functionCall);
            }
        }
    }
    if (functionCalls.length > 0) {
        return functionCalls;
    }
    else {
        return undefined;
    }
}
const badFinishReasons = [
    exports.FinishReason.RECITATION,
    exports.FinishReason.SAFETY,
    exports.FinishReason.LANGUAGE,
];
function hadBadFinishReason(candidate) {
    return (!!candidate.finishReason &&
        badFinishReasons.includes(candidate.finishReason));
}
function formatBlockErrorMessage(response) {
    var _a, _b, _c;
    let message = "";
    if ((!response.candidates || response.candidates.length === 0) &&
        response.promptFeedback) {
        message += "Response was blocked";
        if ((_a = response.promptFeedback) === null || _a === void 0 ? void 0 : _a.blockReason) {
            message += ` due to ${response.promptFeedback.blockReason}`;
        }
        if ((_b = response.promptFeedback) === null || _b === void 0 ? void 0 : _b.blockReasonMessage) {
            message += `: ${response.promptFeedback.blockReasonMessage}`;
        }
    }
    else if ((_c = response.candidates) === null || _c === void 0 ? void 0 : _c[0]) {
        const firstCandidate = response.candidates[0];
        if (hadBadFinishReason(firstCandidate)) {
            message += `Candidate was blocked due to ${firstCandidate.finishReason}`;
            if (firstCandidate.finishMessage) {
                message += `: ${firstCandidate.finishMessage}`;
            }
        }
    }
    return message;
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */


function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const responseLineRE = /^data\: (.*)(?:\n\n|\r\r|\r\n\r\n)/;
/**
 * Process a response.body stream from the backend and return an
 * iterator that provides one complete GenerateContentResponse at a time
 * and a promise that resolves with a single aggregated
 * GenerateContentResponse.
 *
 * @param response - Response from a fetch call
 */
function processStream(response) {
    const inputStream = response.body.pipeThrough(new TextDecoderStream("utf8", { fatal: true }));
    const responseStream = getResponseStream(inputStream);
    const [stream1, stream2] = responseStream.tee();
    return {
        stream: generateResponseSequence(stream1),
        response: getResponsePromise(stream2),
    };
}
async function getResponsePromise(stream) {
    const allResponses = [];
    const reader = stream.getReader();
    while (true) {
        const { done, value } = await reader.read();
        if (done) {
            return addHelpers(aggregateResponses(allResponses));
        }
        allResponses.push(value);
    }
}
function generateResponseSequence(stream) {
    return __asyncGenerator(this, arguments, function* generateResponseSequence_1() {
        const reader = stream.getReader();
        while (true) {
            const { value, done } = yield __await(reader.read());
            if (done) {
                break;
            }
            yield yield __await(addHelpers(value));
        }
    });
}
/**
 * Reads a raw stream from the fetch response and join incomplete
 * chunks, returning a new stream that provides a single complete
 * GenerateContentResponse in each iteration.
 */
function getResponseStream(inputStream) {
    const reader = inputStream.getReader();
    const stream = new ReadableStream({
        start(controller) {
            let currentText = "";
            return pump();
            function pump() {
                return reader
                    .read()
                    .then(({ value, done }) => {
                    if (done) {
                        if (currentText.trim()) {
                            controller.error(new GoogleGenerativeAIError("Failed to parse stream"));
                            return;
                        }
                        controller.close();
                        return;
                    }
                    currentText += value;
                    let match = currentText.match(responseLineRE);
                    let parsedResponse;
                    while (match) {
                        try {
                            parsedResponse = JSON.parse(match[1]);
                        }
                        catch (e) {
                            controller.error(new GoogleGenerativeAIError(`Error parsing JSON response: "${match[1]}"`));
                            return;
                        }
                        controller.enqueue(parsedResponse);
                        currentText = currentText.substring(match[0].length);
                        match = currentText.match(responseLineRE);
                    }
                    return pump();
                })
                    .catch((e) => {
                    let err = e;
                    err.stack = e.stack;
                    if (err.name === "AbortError") {
                        err = new GoogleGenerativeAIAbortError("Request aborted when reading from the stream");
                    }
                    else {
                        err = new GoogleGenerativeAIError("Error reading from the stream");
                    }
                    throw err;
                });
            }
        },
    });
    return stream;
}
/**
 * Aggregates an array of `GenerateContentResponse`s into a single
 * GenerateContentResponse.
 */
function aggregateResponses(responses) {
    const lastResponse = responses[responses.length - 1];
    const aggregatedResponse = {
        promptFeedback: lastResponse === null || lastResponse === void 0 ? void 0 : lastResponse.promptFeedback,
    };
    for (const response of responses) {
        if (response.candidates) {
            let candidateIndex = 0;
            for (const candidate of response.candidates) {
                if (!aggregatedResponse.candidates) {
                    aggregatedResponse.candidates = [];
                }
                if (!aggregatedResponse.candidates[candidateIndex]) {
                    aggregatedResponse.candidates[candidateIndex] = {
                        index: candidateIndex,
                    };
                }
                // Keep overwriting, the last one will be final
                aggregatedResponse.candidates[candidateIndex].citationMetadata =
                    candidate.citationMetadata;
                aggregatedResponse.candidates[candidateIndex].groundingMetadata =
                    candidate.groundingMetadata;
                aggregatedResponse.candidates[candidateIndex].finishReason =
                    candidate.finishReason;
                aggregatedResponse.candidates[candidateIndex].finishMessage =
                    candidate.finishMessage;
                aggregatedResponse.candidates[candidateIndex].safetyRatings =
                    candidate.safetyRatings;
                /**
                 * Candidates should always have content and parts, but this handles
                 * possible malformed responses.
                 */
                if (candidate.content && candidate.content.parts) {
                    if (!aggregatedResponse.candidates[candidateIndex].content) {
                        aggregatedResponse.candidates[candidateIndex].content = {
                            role: candidate.content.role || "user",
                            parts: [],
                        };
                    }
                    const newPart = {};
                    for (const part of candidate.content.parts) {
                        if (part.text) {
                            newPart.text = part.text;
                        }
                        if (part.functionCall) {
                            newPart.functionCall = part.functionCall;
                        }
                        if (part.executableCode) {
                            newPart.executableCode = part.executableCode;
                        }
                        if (part.codeExecutionResult) {
                            newPart.codeExecutionResult = part.codeExecutionResult;
                        }
                        if (Object.keys(newPart).length === 0) {
                            newPart.text = "";
                        }
                        aggregatedResponse.candidates[candidateIndex].content.parts.push(newPart);
                    }
                }
            }
            candidateIndex++;
        }
        if (response.usageMetadata) {
            aggregatedResponse.usageMetadata = response.usageMetadata;
        }
    }
    return aggregatedResponse;
}

/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function generateContentStream(apiKey, model, params, requestOptions) {
    const response = await makeModelRequest(model, Task.STREAM_GENERATE_CONTENT, apiKey, 
    /* stream */ true, JSON.stringify(params), requestOptions);
    return processStream(response);
}
async function generateContent(apiKey, model, params, requestOptions) {
    const response = await makeModelRequest(model, Task.GENERATE_CONTENT, apiKey, 
    /* stream */ false, JSON.stringify(params), requestOptions);
    const responseJson = await response.json();
    const enhancedResponse = addHelpers(responseJson);
    return {
        response: enhancedResponse,
    };
}

/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function formatSystemInstruction(input) {
    // null or undefined
    if (input == null) {
        return undefined;
    }
    else if (typeof input === "string") {
        return { role: "system", parts: [{ text: input }] };
    }
    else if (input.text) {
        return { role: "system", parts: [input] };
    }
    else if (input.parts) {
        if (!input.role) {
            return { role: "system", parts: input.parts };
        }
        else {
            return input;
        }
    }
}
function formatNewContent(request) {
    let newParts = [];
    if (typeof request === "string") {
        newParts = [{ text: request }];
    }
    else {
        for (const partOrString of request) {
            if (typeof partOrString === "string") {
                newParts.push({ text: partOrString });
            }
            else {
                newParts.push(partOrString);
            }
        }
    }
    return assignRoleToPartsAndValidateSendMessageRequest(newParts);
}
/**
 * When multiple Part types (i.e. FunctionResponsePart and TextPart) are
 * passed in a single Part array, we may need to assign different roles to each
 * part. Currently only FunctionResponsePart requires a role other than 'user'.
 * @private
 * @param parts Array of parts to pass to the model
 * @returns Array of content items
 */
function assignRoleToPartsAndValidateSendMessageRequest(parts) {
    const userContent = { role: "user", parts: [] };
    const functionContent = { role: "function", parts: [] };
    let hasUserContent = false;
    let hasFunctionContent = false;
    for (const part of parts) {
        if ("functionResponse" in part) {
            functionContent.parts.push(part);
            hasFunctionContent = true;
        }
        else {
            userContent.parts.push(part);
            hasUserContent = true;
        }
    }
    if (hasUserContent && hasFunctionContent) {
        throw new GoogleGenerativeAIError("Within a single message, FunctionResponse cannot be mixed with other type of part in the request for sending chat message.");
    }
    if (!hasUserContent && !hasFunctionContent) {
        throw new GoogleGenerativeAIError("No content is provided for sending chat message.");
    }
    if (hasUserContent) {
        return userContent;
    }
    return functionContent;
}
function formatCountTokensInput(params, modelParams) {
    var _a;
    let formattedGenerateContentRequest = {
        model: modelParams === null || modelParams === void 0 ? void 0 : modelParams.model,
        generationConfig: modelParams === null || modelParams === void 0 ? void 0 : modelParams.generationConfig,
        safetySettings: modelParams === null || modelParams === void 0 ? void 0 : modelParams.safetySettings,
        tools: modelParams === null || modelParams === void 0 ? void 0 : modelParams.tools,
        toolConfig: modelParams === null || modelParams === void 0 ? void 0 : modelParams.toolConfig,
        systemInstruction: modelParams === null || modelParams === void 0 ? void 0 : modelParams.systemInstruction,
        cachedContent: (_a = modelParams === null || modelParams === void 0 ? void 0 : modelParams.cachedContent) === null || _a === void 0 ? void 0 : _a.name,
        contents: [],
    };
    const containsGenerateContentRequest = params.generateContentRequest != null;
    if (params.contents) {
        if (containsGenerateContentRequest) {
            throw new GoogleGenerativeAIRequestInputError("CountTokensRequest must have one of contents or generateContentRequest, not both.");
        }
        formattedGenerateContentRequest.contents = params.contents;
    }
    else if (containsGenerateContentRequest) {
        formattedGenerateContentRequest = Object.assign(Object.assign({}, formattedGenerateContentRequest), params.generateContentRequest);
    }
    else {
        // Array or string
        const content = formatNewContent(params);
        formattedGenerateContentRequest.contents = [content];
    }
    return { generateContentRequest: formattedGenerateContentRequest };
}
function formatGenerateContentInput(params) {
    let formattedRequest;
    if (params.contents) {
        formattedRequest = params;
    }
    else {
        // Array or string
        const content = formatNewContent(params);
        formattedRequest = { contents: [content] };
    }
    if (params.systemInstruction) {
        formattedRequest.systemInstruction = formatSystemInstruction(params.systemInstruction);
    }
    return formattedRequest;
}
function formatEmbedContentInput(params) {
    if (typeof params === "string" || Array.isArray(params)) {
        const content = formatNewContent(params);
        return { content };
    }
    return params;
}

/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// https://ai.google.dev/api/rest/v1beta/Content#part
const VALID_PART_FIELDS = [
    "text",
    "inlineData",
    "functionCall",
    "functionResponse",
    "executableCode",
    "codeExecutionResult",
];
const VALID_PARTS_PER_ROLE = {
    user: ["text", "inlineData"],
    function: ["functionResponse"],
    model: ["text", "functionCall", "executableCode", "codeExecutionResult"],
    // System instructions shouldn't be in history anyway.
    system: ["text"],
};
function validateChatHistory(history) {
    let prevContent = false;
    for (const currContent of history) {
        const { role, parts } = currContent;
        if (!prevContent && role !== "user") {
            throw new GoogleGenerativeAIError(`First content should be with role 'user', got ${role}`);
        }
        if (!POSSIBLE_ROLES.includes(role)) {
            throw new GoogleGenerativeAIError(`Each item should include role field. Got ${role} but valid roles are: ${JSON.stringify(POSSIBLE_ROLES)}`);
        }
        if (!Array.isArray(parts)) {
            throw new GoogleGenerativeAIError("Content should have 'parts' property with an array of Parts");
        }
        if (parts.length === 0) {
            throw new GoogleGenerativeAIError("Each Content should have at least one part");
        }
        const countFields = {
            text: 0,
            inlineData: 0,
            functionCall: 0,
            functionResponse: 0,
            fileData: 0,
            executableCode: 0,
            codeExecutionResult: 0,
        };
        for (const part of parts) {
            for (const key of VALID_PART_FIELDS) {
                if (key in part) {
                    countFields[key] += 1;
                }
            }
        }
        const validParts = VALID_PARTS_PER_ROLE[role];
        for (const key of VALID_PART_FIELDS) {
            if (!validParts.includes(key) && countFields[key] > 0) {
                throw new GoogleGenerativeAIError(`Content with role '${role}' can't contain '${key}' part`);
            }
        }
        prevContent = true;
    }
}
/**
 * Returns true if the response is valid (could be appended to the history), flase otherwise.
 */
function isValidResponse(response) {
    var _a;
    if (response.candidates === undefined || response.candidates.length === 0) {
        return false;
    }
    const content = (_a = response.candidates[0]) === null || _a === void 0 ? void 0 : _a.content;
    if (content === undefined) {
        return false;
    }
    if (content.parts === undefined || content.parts.length === 0) {
        return false;
    }
    for (const part of content.parts) {
        if (part === undefined || Object.keys(part).length === 0) {
            return false;
        }
        if (part.text !== undefined && part.text === "") {
            return false;
        }
    }
    return true;
}

/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Do not log a message for this error.
 */
const SILENT_ERROR = "SILENT_ERROR";
/**
 * ChatSession class that enables sending chat messages and stores
 * history of sent and received messages so far.
 *
 * @public
 */
class ChatSession {
    constructor(apiKey, model, params, _requestOptions = {}) {
        this.model = model;
        this.params = params;
        this._requestOptions = _requestOptions;
        this._history = [];
        this._sendPromise = Promise.resolve();
        this._apiKey = apiKey;
        if (params === null || params === void 0 ? void 0 : params.history) {
            validateChatHistory(params.history);
            this._history = params.history;
        }
    }
    /**
     * Gets the chat history so far. Blocked prompts are not added to history.
     * Blocked candidates are not added to history, nor are the prompts that
     * generated them.
     */
    async getHistory() {
        await this._sendPromise;
        return this._history;
    }
    /**
     * Sends a chat message and receives a non-streaming
     * {@link GenerateContentResult}.
     *
     * Fields set in the optional {@link SingleRequestOptions} parameter will
     * take precedence over the {@link RequestOptions} values provided to
     * {@link GoogleGenerativeAI.getGenerativeModel }.
     */
    async sendMessage(request, requestOptions = {}) {
        var _a, _b, _c, _d, _e, _f;
        await this._sendPromise;
        const newContent = formatNewContent(request);
        const generateContentRequest = {
            safetySettings: (_a = this.params) === null || _a === void 0 ? void 0 : _a.safetySettings,
            generationConfig: (_b = this.params) === null || _b === void 0 ? void 0 : _b.generationConfig,
            tools: (_c = this.params) === null || _c === void 0 ? void 0 : _c.tools,
            toolConfig: (_d = this.params) === null || _d === void 0 ? void 0 : _d.toolConfig,
            systemInstruction: (_e = this.params) === null || _e === void 0 ? void 0 : _e.systemInstruction,
            cachedContent: (_f = this.params) === null || _f === void 0 ? void 0 : _f.cachedContent,
            contents: [...this._history, newContent],
        };
        const chatSessionRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
        let finalResult;
        // Add onto the chain.
        this._sendPromise = this._sendPromise
            .then(() => generateContent(this._apiKey, this.model, generateContentRequest, chatSessionRequestOptions))
            .then((result) => {
            var _a;
            if (isValidResponse(result.response)) {
                this._history.push(newContent);
                const responseContent = Object.assign({ parts: [], 
                    // Response seems to come back without a role set.
                    role: "model" }, (_a = result.response.candidates) === null || _a === void 0 ? void 0 : _a[0].content);
                this._history.push(responseContent);
            }
            else {
                const blockErrorMessage = formatBlockErrorMessage(result.response);
                if (blockErrorMessage) {
                    console.warn(`sendMessage() was unsuccessful. ${blockErrorMessage}. Inspect response object for details.`);
                }
            }
            finalResult = result;
        })
            .catch((e) => {
            // Resets _sendPromise to avoid subsequent calls failing and throw error.
            this._sendPromise = Promise.resolve();
            throw e;
        });
        await this._sendPromise;
        return finalResult;
    }
    /**
     * Sends a chat message and receives the response as a
     * {@link GenerateContentStreamResult} containing an iterable stream
     * and a response promise.
     *
     * Fields set in the optional {@link SingleRequestOptions} parameter will
     * take precedence over the {@link RequestOptions} values provided to
     * {@link GoogleGenerativeAI.getGenerativeModel }.
     */
    async sendMessageStream(request, requestOptions = {}) {
        var _a, _b, _c, _d, _e, _f;
        await this._sendPromise;
        const newContent = formatNewContent(request);
        const generateContentRequest = {
            safetySettings: (_a = this.params) === null || _a === void 0 ? void 0 : _a.safetySettings,
            generationConfig: (_b = this.params) === null || _b === void 0 ? void 0 : _b.generationConfig,
            tools: (_c = this.params) === null || _c === void 0 ? void 0 : _c.tools,
            toolConfig: (_d = this.params) === null || _d === void 0 ? void 0 : _d.toolConfig,
            systemInstruction: (_e = this.params) === null || _e === void 0 ? void 0 : _e.systemInstruction,
            cachedContent: (_f = this.params) === null || _f === void 0 ? void 0 : _f.cachedContent,
            contents: [...this._history, newContent],
        };
        const chatSessionRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
        const streamPromise = generateContentStream(this._apiKey, this.model, generateContentRequest, chatSessionRequestOptions);
        // Add onto the chain.
        this._sendPromise = this._sendPromise
            .then(() => streamPromise)
            // This must be handled to avoid unhandled rejection, but jump
            // to the final catch block with a label to not log this error.
            .catch((_ignored) => {
            throw new Error(SILENT_ERROR);
        })
            .then((streamResult) => streamResult.response)
            .then((response) => {
            if (isValidResponse(response)) {
                this._history.push(newContent);
                const responseContent = Object.assign({}, response.candidates[0].content);
                // Response seems to come back without a role set.
                if (!responseContent.role) {
                    responseContent.role = "model";
                }
                this._history.push(responseContent);
            }
            else {
                const blockErrorMessage = formatBlockErrorMessage(response);
                if (blockErrorMessage) {
                    console.warn(`sendMessageStream() was unsuccessful. ${blockErrorMessage}. Inspect response object for details.`);
                }
            }
        })
            .catch((e) => {
            // Errors in streamPromise are already catchable by the user as
            // streamPromise is returned.
            // Avoid duplicating the error message in logs.
            if (e.message !== SILENT_ERROR) {
                // Users do not have access to _sendPromise to catch errors
                // downstream from streamPromise, so they should not throw.
                console.error(e);
            }
        });
        return streamPromise;
    }
}

/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function countTokens(apiKey, model, params, singleRequestOptions) {
    const response = await makeModelRequest(model, Task.COUNT_TOKENS, apiKey, false, JSON.stringify(params), singleRequestOptions);
    return response.json();
}

/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function embedContent(apiKey, model, params, requestOptions) {
    const response = await makeModelRequest(model, Task.EMBED_CONTENT, apiKey, false, JSON.stringify(params), requestOptions);
    return response.json();
}
async function batchEmbedContents(apiKey, model, params, requestOptions) {
    const requestsWithModel = params.requests.map((request) => {
        return Object.assign(Object.assign({}, request), { model });
    });
    const response = await makeModelRequest(model, Task.BATCH_EMBED_CONTENTS, apiKey, false, JSON.stringify({ requests: requestsWithModel }), requestOptions);
    return response.json();
}

/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Class for generative model APIs.
 * @public
 */
class GenerativeModel {
    constructor(apiKey, modelParams, _requestOptions = {}) {
        this.apiKey = apiKey;
        this._requestOptions = _requestOptions;
        if (modelParams.model.includes("/")) {
            // Models may be named "models/model-name" or "tunedModels/model-name"
            this.model = modelParams.model;
        }
        else {
            // If path is not included, assume it's a non-tuned model.
            this.model = `models/${modelParams.model}`;
        }
        this.generationConfig = modelParams.generationConfig || {};
        this.safetySettings = modelParams.safetySettings || [];
        this.tools = modelParams.tools;
        this.toolConfig = modelParams.toolConfig;
        this.systemInstruction = formatSystemInstruction(modelParams.systemInstruction);
        this.cachedContent = modelParams.cachedContent;
    }
    /**
     * Makes a single non-streaming call to the model
     * and returns an object containing a single {@link GenerateContentResponse}.
     *
     * Fields set in the optional {@link SingleRequestOptions} parameter will
     * take precedence over the {@link RequestOptions} values provided to
     * {@link GoogleGenerativeAI.getGenerativeModel }.
     */
    async generateContent(request, requestOptions = {}) {
        var _a;
        const formattedParams = formatGenerateContentInput(request);
        const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
        return generateContent(this.apiKey, this.model, Object.assign({ generationConfig: this.generationConfig, safetySettings: this.safetySettings, tools: this.tools, toolConfig: this.toolConfig, systemInstruction: this.systemInstruction, cachedContent: (_a = this.cachedContent) === null || _a === void 0 ? void 0 : _a.name }, formattedParams), generativeModelRequestOptions);
    }
    /**
     * Makes a single streaming call to the model and returns an object
     * containing an iterable stream that iterates over all chunks in the
     * streaming response as well as a promise that returns the final
     * aggregated response.
     *
     * Fields set in the optional {@link SingleRequestOptions} parameter will
     * take precedence over the {@link RequestOptions} values provided to
     * {@link GoogleGenerativeAI.getGenerativeModel }.
     */
    async generateContentStream(request, requestOptions = {}) {
        var _a;
        const formattedParams = formatGenerateContentInput(request);
        const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
        return generateContentStream(this.apiKey, this.model, Object.assign({ generationConfig: this.generationConfig, safetySettings: this.safetySettings, tools: this.tools, toolConfig: this.toolConfig, systemInstruction: this.systemInstruction, cachedContent: (_a = this.cachedContent) === null || _a === void 0 ? void 0 : _a.name }, formattedParams), generativeModelRequestOptions);
    }
    /**
     * Gets a new {@link ChatSession} instance which can be used for
     * multi-turn chats.
     */
    startChat(startChatParams) {
        var _a;
        return new ChatSession(this.apiKey, this.model, Object.assign({ generationConfig: this.generationConfig, safetySettings: this.safetySettings, tools: this.tools, toolConfig: this.toolConfig, systemInstruction: this.systemInstruction, cachedContent: (_a = this.cachedContent) === null || _a === void 0 ? void 0 : _a.name }, startChatParams), this._requestOptions);
    }
    /**
     * Counts the tokens in the provided request.
     *
     * Fields set in the optional {@link SingleRequestOptions} parameter will
     * take precedence over the {@link RequestOptions} values provided to
     * {@link GoogleGenerativeAI.getGenerativeModel }.
     */
    async countTokens(request, requestOptions = {}) {
        const formattedParams = formatCountTokensInput(request, {
            model: this.model,
            generationConfig: this.generationConfig,
            safetySettings: this.safetySettings,
            tools: this.tools,
            toolConfig: this.toolConfig,
            systemInstruction: this.systemInstruction,
            cachedContent: this.cachedContent,
        });
        const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
        return countTokens(this.apiKey, this.model, formattedParams, generativeModelRequestOptions);
    }
    /**
     * Embeds the provided content.
     *
     * Fields set in the optional {@link SingleRequestOptions} parameter will
     * take precedence over the {@link RequestOptions} values provided to
     * {@link GoogleGenerativeAI.getGenerativeModel }.
     */
    async embedContent(request, requestOptions = {}) {
        const formattedParams = formatEmbedContentInput(request);
        const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
        return embedContent(this.apiKey, this.model, formattedParams, generativeModelRequestOptions);
    }
    /**
     * Embeds an array of {@link EmbedContentRequest}s.
     *
     * Fields set in the optional {@link SingleRequestOptions} parameter will
     * take precedence over the {@link RequestOptions} values provided to
     * {@link GoogleGenerativeAI.getGenerativeModel }.
     */
    async batchEmbedContents(batchEmbedContentRequest, requestOptions = {}) {
        const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
        return batchEmbedContents(this.apiKey, this.model, batchEmbedContentRequest, generativeModelRequestOptions);
    }
}

/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Top-level class for this SDK
 * @public
 */
class GoogleGenerativeAI {
    constructor(apiKey) {
        this.apiKey = apiKey;
    }
    /**
     * Gets a {@link GenerativeModel} instance for the provided model name.
     */
    getGenerativeModel(modelParams, requestOptions) {
        if (!modelParams.model) {
            throw new GoogleGenerativeAIError(`Must provide a model name. ` +
                `Example: genai.getGenerativeModel({ model: 'my-model-name' })`);
        }
        return new GenerativeModel(this.apiKey, modelParams, requestOptions);
    }
    /**
     * Creates a {@link GenerativeModel} instance from provided content cache.
     */
    getGenerativeModelFromCachedContent(cachedContent, modelParams, requestOptions) {
        if (!cachedContent.name) {
            throw new GoogleGenerativeAIRequestInputError("Cached content must contain a `name` field.");
        }
        if (!cachedContent.model) {
            throw new GoogleGenerativeAIRequestInputError("Cached content must contain a `model` field.");
        }
        /**
         * Not checking tools and toolConfig for now as it would require a deep
         * equality comparison and isn't likely to be a common case.
         */
        const disallowedDuplicates = ["model", "systemInstruction"];
        for (const key of disallowedDuplicates) {
            if ((modelParams === null || modelParams === void 0 ? void 0 : modelParams[key]) &&
                cachedContent[key] &&
                (modelParams === null || modelParams === void 0 ? void 0 : modelParams[key]) !== cachedContent[key]) {
                if (key === "model") {
                    const modelParamsComp = modelParams.model.startsWith("models/")
                        ? modelParams.model.replace("models/", "")
                        : modelParams.model;
                    const cachedContentComp = cachedContent.model.startsWith("models/")
                        ? cachedContent.model.replace("models/", "")
                        : cachedContent.model;
                    if (modelParamsComp === cachedContentComp) {
                        continue;
                    }
                }
                throw new GoogleGenerativeAIRequestInputError(`Different value for "${key}" specified in modelParams` +
                    ` (${modelParams[key]}) and cachedContent (${cachedContent[key]})`);
            }
        }
        const modelParamsFromCache = Object.assign(Object.assign({}, modelParams), { model: cachedContent.model, tools: cachedContent.tools, toolConfig: cachedContent.toolConfig, systemInstruction: cachedContent.systemInstruction, cachedContent });
        return new GenerativeModel(this.apiKey, modelParamsFromCache, requestOptions);
    }
}

exports.ChatSession = ChatSession;
exports.GenerativeModel = GenerativeModel;
exports.GoogleGenerativeAI = GoogleGenerativeAI;
exports.GoogleGenerativeAIAbortError = GoogleGenerativeAIAbortError;
exports.GoogleGenerativeAIError = GoogleGenerativeAIError;
exports.GoogleGenerativeAIFetchError = GoogleGenerativeAIFetchError;
exports.GoogleGenerativeAIRequestInputError = GoogleGenerativeAIRequestInputError;
exports.GoogleGenerativeAIResponseError = GoogleGenerativeAIResponseError;
exports.POSSIBLE_ROLES = POSSIBLE_ROLES;
//# sourceMappingURL=index.js.map


/***/ }),
/* 218 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),
/* 219 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GitWatcher = void 0;
const events_1 = __webpack_require__(19);
const GitService_1 = __webpack_require__(229);
class GitWatcher extends events_1.EventEmitter {
    workspaceRoot;
    intervalMs;
    lastCommitHash = null;
    pollInterval = null;
    isPolling = false;
    gitService;
    constructor(workspaceRoot, intervalMs = 30000) {
        super();
        this.workspaceRoot = workspaceRoot;
        this.intervalMs = intervalMs;
        this.gitService = new GitService_1.GitService(workspaceRoot);
    }
    start() {
        if (this.pollInterval) {
            return;
        }
        // Initial check
        this.checkGitLog();
        // Start polling
        this.pollInterval = setInterval(() => {
            this.checkGitLog();
        }, this.intervalMs);
        console.log('GitWatcher started.');
    }
    stop() {
        if (this.pollInterval) {
            clearInterval(this.pollInterval);
            this.pollInterval = null;
        }
        console.log('GitWatcher stopped.');
    }
    async checkGitLog() {
        if (this.isPolling) {
            return;
        }
        this.isPolling = true;
        try {
            const logs = await this.gitService.getRecentCommits(10);
            if (!logs || logs.length === 0) {
                this.isPolling = false;
                return;
            }
            // If it's the first run, just set the last commit and return (or process all? let's process latest)
            if (!this.lastCommitHash) {
                this.lastCommitHash = logs[0].hash;
                this.isPolling = false;
                return;
            }
            // Find new commits since last hash
            const newCommits = [];
            for (const log of logs) {
                if (log.hash === this.lastCommitHash) {
                    break;
                }
                newCommits.push({
                    hash: log.hash,
                    message: log.message,
                    author: log.author,
                    date: log.date.toISOString(),
                    files: log.files || []
                });
            }
            // Emit events for new commits (oldest to newest)
            if (newCommits.length > 0) {
                this.lastCommitHash = newCommits[0].hash; // Update to the newest
                for (let i = newCommits.length - 1; i >= 0; i--) {
                    this.emit('commit', newCommits[i]);
                }
            }
        }
        catch (error) {
            console.warn('GitWatcher error:', error);
        }
        finally {
            this.isPolling = false;
        }
    }
}
exports.GitWatcher = GitWatcher;


/***/ }),
/* 220 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const fs = __webpack_require__(6)
const path = __webpack_require__(25)
const os = __webpack_require__(221)
const crypto = __webpack_require__(202)
const packageJson = __webpack_require__(222)

const version = packageJson.version

// Array of tips to display randomly
const TIPS = [
  'ðŸ” encrypt with Dotenvx: https://dotenvx.com',
  'ðŸ” prevent committing .env to code: https://dotenvx.com/precommit',
  'ðŸ” prevent building .env in docker: https://dotenvx.com/prebuild',
  'ðŸ“¡ add observability to secrets: https://dotenvx.com/ops',
  'ðŸ‘¥ sync secrets across teammates & machines: https://dotenvx.com/ops',
  'ðŸ—‚ï¸ backup and recover secrets: https://dotenvx.com/ops',
  'âœ… audit secrets and track compliance: https://dotenvx.com/ops',
  'ðŸ”„ add secrets lifecycle management: https://dotenvx.com/ops',
  'ðŸ”‘ add access controls to secrets: https://dotenvx.com/ops',
  'ðŸ› ï¸  run anywhere with `dotenvx run -- yourcommand`',
  'âš™ï¸  specify custom .env file path with { path: \'/custom/path/.env\' }',
  'âš™ï¸  enable debug logging with { debug: true }',
  'âš™ï¸  override existing env vars with { override: true }',
  'âš™ï¸  suppress all logs with { quiet: true }',
  'âš™ï¸  write to custom object with { processEnv: myObject }',
  'âš™ï¸  load multiple .env files with { path: [\'.env.local\', \'.env\'] }'
]

// Get a random tip from the tips array
function _getRandomTip () {
  return TIPS[Math.floor(Math.random() * TIPS.length)]
}

function parseBoolean (value) {
  if (typeof value === 'string') {
    return !['false', '0', 'no', 'off', ''].includes(value.toLowerCase())
  }
  return Boolean(value)
}

function supportsAnsi () {
  return process.stdout.isTTY // && process.env.TERM !== 'dumb'
}

function dim (text) {
  return supportsAnsi() ? `\x1b[2m${text}\x1b[0m` : text
}

const LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg

// Parse src into an Object
function parse (src) {
  const obj = {}

  // Convert buffer to string
  let lines = src.toString()

  // Convert line breaks to same format
  lines = lines.replace(/\r\n?/mg, '\n')

  let match
  while ((match = LINE.exec(lines)) != null) {
    const key = match[1]

    // Default undefined or null to empty string
    let value = (match[2] || '')

    // Remove whitespace
    value = value.trim()

    // Check if double quoted
    const maybeQuote = value[0]

    // Remove surrounding quotes
    value = value.replace(/^(['"`])([\s\S]*)\1$/mg, '$2')

    // Expand newlines if double quoted
    if (maybeQuote === '"') {
      value = value.replace(/\\n/g, '\n')
      value = value.replace(/\\r/g, '\r')
    }

    // Add to object
    obj[key] = value
  }

  return obj
}

function _parseVault (options) {
  options = options || {}

  const vaultPath = _vaultPath(options)
  options.path = vaultPath // parse .env.vault
  const result = DotenvModule.configDotenv(options)
  if (!result.parsed) {
    const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`)
    err.code = 'MISSING_DATA'
    throw err
  }

  // handle scenario for comma separated keys - for use with key rotation
  // example: DOTENV_KEY="dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=prod,dotenv://:key_7890@dotenvx.com/vault/.env.vault?environment=prod"
  const keys = _dotenvKey(options).split(',')
  const length = keys.length

  let decrypted
  for (let i = 0; i < length; i++) {
    try {
      // Get full key
      const key = keys[i].trim()

      // Get instructions for decrypt
      const attrs = _instructions(result, key)

      // Decrypt
      decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key)

      break
    } catch (error) {
      // last key
      if (i + 1 >= length) {
        throw error
      }
      // try next key
    }
  }

  // Parse decrypted .env string
  return DotenvModule.parse(decrypted)
}

function _warn (message) {
  console.error(`[dotenv@${version}][WARN] ${message}`)
}

function _debug (message) {
  console.log(`[dotenv@${version}][DEBUG] ${message}`)
}

function _log (message) {
  console.log(`[dotenv@${version}] ${message}`)
}

function _dotenvKey (options) {
  // prioritize developer directly setting options.DOTENV_KEY
  if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
    return options.DOTENV_KEY
  }

  // secondary infra already contains a DOTENV_KEY environment variable
  if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
    return process.env.DOTENV_KEY
  }

  // fallback to empty string
  return ''
}

function _instructions (result, dotenvKey) {
  // Parse DOTENV_KEY. Format is a URI
  let uri
  try {
    uri = new URL(dotenvKey)
  } catch (error) {
    if (error.code === 'ERR_INVALID_URL') {
      const err = new Error('INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development')
      err.code = 'INVALID_DOTENV_KEY'
      throw err
    }

    throw error
  }

  // Get decrypt key
  const key = uri.password
  if (!key) {
    const err = new Error('INVALID_DOTENV_KEY: Missing key part')
    err.code = 'INVALID_DOTENV_KEY'
    throw err
  }

  // Get environment
  const environment = uri.searchParams.get('environment')
  if (!environment) {
    const err = new Error('INVALID_DOTENV_KEY: Missing environment part')
    err.code = 'INVALID_DOTENV_KEY'
    throw err
  }

  // Get ciphertext payload
  const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`
  const ciphertext = result.parsed[environmentKey] // DOTENV_VAULT_PRODUCTION
  if (!ciphertext) {
    const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`)
    err.code = 'NOT_FOUND_DOTENV_ENVIRONMENT'
    throw err
  }

  return { ciphertext, key }
}

function _vaultPath (options) {
  let possibleVaultPath = null

  if (options && options.path && options.path.length > 0) {
    if (Array.isArray(options.path)) {
      for (const filepath of options.path) {
        if (fs.existsSync(filepath)) {
          possibleVaultPath = filepath.endsWith('.vault') ? filepath : `${filepath}.vault`
        }
      }
    } else {
      possibleVaultPath = options.path.endsWith('.vault') ? options.path : `${options.path}.vault`
    }
  } else {
    possibleVaultPath = path.resolve(process.cwd(), '.env.vault')
  }

  if (fs.existsSync(possibleVaultPath)) {
    return possibleVaultPath
  }

  return null
}

function _resolveHome (envPath) {
  return envPath[0] === '~' ? path.join(os.homedir(), envPath.slice(1)) : envPath
}

function _configVault (options) {
  const debug = parseBoolean(process.env.DOTENV_CONFIG_DEBUG || (options && options.debug))
  const quiet = parseBoolean(process.env.DOTENV_CONFIG_QUIET || (options && options.quiet))

  if (debug || !quiet) {
    _log('Loading env from encrypted .env.vault')
  }

  const parsed = DotenvModule._parseVault(options)

  let processEnv = process.env
  if (options && options.processEnv != null) {
    processEnv = options.processEnv
  }

  DotenvModule.populate(processEnv, parsed, options)

  return { parsed }
}

function configDotenv (options) {
  const dotenvPath = path.resolve(process.cwd(), '.env')
  let encoding = 'utf8'
  let processEnv = process.env
  if (options && options.processEnv != null) {
    processEnv = options.processEnv
  }
  let debug = parseBoolean(processEnv.DOTENV_CONFIG_DEBUG || (options && options.debug))
  let quiet = parseBoolean(processEnv.DOTENV_CONFIG_QUIET || (options && options.quiet))

  if (options && options.encoding) {
    encoding = options.encoding
  } else {
    if (debug) {
      _debug('No encoding is specified. UTF-8 is used by default')
    }
  }

  let optionPaths = [dotenvPath] // default, look for .env
  if (options && options.path) {
    if (!Array.isArray(options.path)) {
      optionPaths = [_resolveHome(options.path)]
    } else {
      optionPaths = [] // reset default
      for (const filepath of options.path) {
        optionPaths.push(_resolveHome(filepath))
      }
    }
  }

  // Build the parsed data in a temporary object (because we need to return it).  Once we have the final
  // parsed data, we will combine it with process.env (or options.processEnv if provided).
  let lastError
  const parsedAll = {}
  for (const path of optionPaths) {
    try {
      // Specifying an encoding returns a string instead of a buffer
      const parsed = DotenvModule.parse(fs.readFileSync(path, { encoding }))

      DotenvModule.populate(parsedAll, parsed, options)
    } catch (e) {
      if (debug) {
        _debug(`Failed to load ${path} ${e.message}`)
      }
      lastError = e
    }
  }

  const populated = DotenvModule.populate(processEnv, parsedAll, options)

  // handle user settings DOTENV_CONFIG_ options inside .env file(s)
  debug = parseBoolean(processEnv.DOTENV_CONFIG_DEBUG || debug)
  quiet = parseBoolean(processEnv.DOTENV_CONFIG_QUIET || quiet)

  if (debug || !quiet) {
    const keysCount = Object.keys(populated).length
    const shortPaths = []
    for (const filePath of optionPaths) {
      try {
        const relative = path.relative(process.cwd(), filePath)
        shortPaths.push(relative)
      } catch (e) {
        if (debug) {
          _debug(`Failed to load ${filePath} ${e.message}`)
        }
        lastError = e
      }
    }

    _log(`injecting env (${keysCount}) from ${shortPaths.join(',')} ${dim(`-- tip: ${_getRandomTip()}`)}`)
  }

  if (lastError) {
    return { parsed: parsedAll, error: lastError }
  } else {
    return { parsed: parsedAll }
  }
}

// Populates process.env from .env file
function config (options) {
  // fallback to original dotenv if DOTENV_KEY is not set
  if (_dotenvKey(options).length === 0) {
    return DotenvModule.configDotenv(options)
  }

  const vaultPath = _vaultPath(options)

  // dotenvKey exists but .env.vault file does not exist
  if (!vaultPath) {
    _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`)

    return DotenvModule.configDotenv(options)
  }

  return DotenvModule._configVault(options)
}

function decrypt (encrypted, keyStr) {
  const key = Buffer.from(keyStr.slice(-64), 'hex')
  let ciphertext = Buffer.from(encrypted, 'base64')

  const nonce = ciphertext.subarray(0, 12)
  const authTag = ciphertext.subarray(-16)
  ciphertext = ciphertext.subarray(12, -16)

  try {
    const aesgcm = crypto.createDecipheriv('aes-256-gcm', key, nonce)
    aesgcm.setAuthTag(authTag)
    return `${aesgcm.update(ciphertext)}${aesgcm.final()}`
  } catch (error) {
    const isRange = error instanceof RangeError
    const invalidKeyLength = error.message === 'Invalid key length'
    const decryptionFailed = error.message === 'Unsupported state or unable to authenticate data'

    if (isRange || invalidKeyLength) {
      const err = new Error('INVALID_DOTENV_KEY: It must be 64 characters long (or more)')
      err.code = 'INVALID_DOTENV_KEY'
      throw err
    } else if (decryptionFailed) {
      const err = new Error('DECRYPTION_FAILED: Please check your DOTENV_KEY')
      err.code = 'DECRYPTION_FAILED'
      throw err
    } else {
      throw error
    }
  }
}

// Populate process.env with parsed values
function populate (processEnv, parsed, options = {}) {
  const debug = Boolean(options && options.debug)
  const override = Boolean(options && options.override)
  const populated = {}

  if (typeof parsed !== 'object') {
    const err = new Error('OBJECT_REQUIRED: Please check the processEnv argument being passed to populate')
    err.code = 'OBJECT_REQUIRED'
    throw err
  }

  // Set process.env
  for (const key of Object.keys(parsed)) {
    if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
      if (override === true) {
        processEnv[key] = parsed[key]
        populated[key] = parsed[key]
      }

      if (debug) {
        if (override === true) {
          _debug(`"${key}" is already defined and WAS overwritten`)
        } else {
          _debug(`"${key}" is already defined and was NOT overwritten`)
        }
      }
    } else {
      processEnv[key] = parsed[key]
      populated[key] = parsed[key]
    }
  }

  return populated
}

const DotenvModule = {
  configDotenv,
  _configVault,
  _parseVault,
  config,
  decrypt,
  parse,
  populate
}

module.exports.configDotenv = DotenvModule.configDotenv
module.exports._configVault = DotenvModule._configVault
module.exports._parseVault = DotenvModule._parseVault
module.exports.config = DotenvModule.config
module.exports.decrypt = DotenvModule.decrypt
module.exports.parse = DotenvModule.parse
module.exports.populate = DotenvModule.populate

module.exports = DotenvModule


/***/ }),
/* 221 */
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),
/* 222 */
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"dotenv","version":"17.2.3","description":"Loads environment variables from .env file","main":"lib/main.js","types":"lib/main.d.ts","exports":{".":{"types":"./lib/main.d.ts","require":"./lib/main.js","default":"./lib/main.js"},"./config":"./config.js","./config.js":"./config.js","./lib/env-options":"./lib/env-options.js","./lib/env-options.js":"./lib/env-options.js","./lib/cli-options":"./lib/cli-options.js","./lib/cli-options.js":"./lib/cli-options.js","./package.json":"./package.json"},"scripts":{"dts-check":"tsc --project tests/types/tsconfig.json","lint":"standard","pretest":"npm run lint && npm run dts-check","test":"tap run tests/**/*.js --allow-empty-coverage --disable-coverage --timeout=60000","test:coverage":"tap run tests/**/*.js --show-full-coverage --timeout=60000 --coverage-report=text --coverage-report=lcov","prerelease":"npm test","release":"standard-version"},"repository":{"type":"git","url":"git://github.com/motdotla/dotenv.git"},"homepage":"https://github.com/motdotla/dotenv#readme","funding":"https://dotenvx.com","keywords":["dotenv","env",".env","environment","variables","config","settings"],"readmeFilename":"README.md","license":"BSD-2-Clause","devDependencies":{"@types/node":"^18.11.3","decache":"^4.6.2","sinon":"^14.0.1","standard":"^17.0.0","standard-version":"^9.5.0","tap":"^19.2.0","typescript":"^4.8.4"},"engines":{"node":">=12"},"browser":{"fs":false}}');

/***/ }),
/* 223 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommandManager = void 0;
const vscode = __importStar(__webpack_require__(1));
const NotificationManager_1 = __webpack_require__(27);
const storage_1 = __webpack_require__(35);
const gitlog_1 = __webpack_require__(2);
const fileWatcher_1 = __webpack_require__(28);
class CommandManager {
    context;
    contextService;
    aiService;
    sidebarProvider;
    statusBar;
    issuesTreeProvider;
    constructor(context, contextService, aiService, sidebarProvider, statusBar, issuesTreeProvider) {
        this.context = context;
        this.contextService = contextService;
        this.aiService = aiService;
        this.sidebarProvider = sidebarProvider;
        this.statusBar = statusBar;
        this.issuesTreeProvider = issuesTreeProvider;
    }
    registerCommands() {
        this.registerAnalysisCommands();
        this.registerNavigationCommands();
        this.registerDebugCommands();
        this.registerLegacyCommands();
    }
    registerAnalysisCommands() {
        this.context.subscriptions.push(vscode.commands.registerCommand('copilot.analyze', async () => {
            await this.runAnalysis();
        }));
        this.context.subscriptions.push(vscode.commands.registerCommand('copilot.toggleAutonomous', async () => {
            const config = vscode.workspace.getConfiguration('copilot');
            const isAutonomousMode = !config.get('autonomous.enabled', false);
            await config.update('autonomous.enabled', isAutonomousMode, true);
            if (isAutonomousMode) {
                NotificationManager_1.NotificationManager.showAutonomousStarted();
            }
            else {
                NotificationManager_1.NotificationManager.showSuccess('Autonomous mode disabled');
            }
        }));
        this.context.subscriptions.push(vscode.commands.registerCommand('copilot.refreshContext', async () => {
            await this.refreshContext();
        }));
    }
    registerNavigationCommands() {
        this.context.subscriptions.push(vscode.commands.registerCommand('copilot.showPanel', () => {
            this.sidebarProvider.reveal();
        }));
        this.context.subscriptions.push(vscode.commands.registerCommand('copilot.navigateToIssue', async (file, line, column = 0) => {
            try {
                const document = await vscode.workspace.openTextDocument(file);
                const editor = await vscode.window.showTextDocument(document);
                const position = new vscode.Position(line - 1, column);
                editor.selection = new vscode.Selection(position, position);
                editor.revealRange(new vscode.Range(position, position), vscode.TextEditorRevealType.InCenter);
            }
            catch (error) {
                NotificationManager_1.NotificationManager.showError(`Cannot open file: ${error.message}`);
            }
        }));
        this.context.subscriptions.push(vscode.commands.registerCommand('copilot.applyFix', async (issueId) => {
            NotificationManager_1.NotificationManager.showSuccess('Fix application coming soon!');
        }));
    }
    registerDebugCommands() {
        this.context.subscriptions.push(vscode.commands.registerCommand("contextkeeper.showStoredEvents", async () => {
            try {
                const events = await storage_1.storage.getRecentEvents(20);
                const channel = vscode.window.createOutputChannel("ContextKeeper Storage");
                channel.clear();
                channel.appendLine("=== Recent Stored Events (LanceDB) ===");
                if (events.length === 0) {
                    channel.appendLine("No events found.");
                }
                events.forEach((event, i) => {
                    channel.appendLine(`\n[${i + 1}] ${new Date(event.timestamp).toLocaleString()} - ${event.event_type}`);
                    channel.appendLine(`    File: ${event.file_path}`);
                    channel.appendLine(`    Metadata: ${event.metadata}`);
                });
                channel.show();
            }
            catch (error) {
                vscode.window.showErrorMessage(`Failed to fetch events: ${error.message}`);
            }
        }));
    }
    registerLegacyCommands() {
        this.context.subscriptions.push(vscode.commands.registerCommand("contextkeeper.helloWorld", () => {
            vscode.window.showInformationMessage("Hello World from contextkeeper!");
        }));
        this.context.subscriptions.push(vscode.commands.registerCommand("contextkeeper.testGitlog", async () => {
            try {
                vscode.window.showInformationMessage("Fetching git logs...");
                const logs = await (0, gitlog_1.getLogsWithGitlog)();
                const outputChannel = vscode.window.createOutputChannel("ContextKeeper");
                outputChannel.clear();
                outputChannel.appendLine("=== Recent Git Commits ===");
                logs.forEach((commit, i) => {
                    outputChannel.appendLine(`\n${i + 1}. ${commit.subject}`);
                    outputChannel.appendLine(`   Author: ${commit.authorName}`);
                    outputChannel.appendLine(`   Hash: ${commit.hash}`);
                    outputChannel.appendLine(`   Date: ${commit.authorDate}`);
                });
                outputChannel.show();
                vscode.window.showInformationMessage(`Found ${logs.length} commits!`);
            }
            catch (err) {
                vscode.window.showErrorMessage(`Error: ${err.message}`);
                console.error("Gitlog error:", err);
            }
        }));
        // Auto-lint commands (simplified for now, ideally moved to LintingService)
        let fileWatcher = null;
        this.context.subscriptions.push(vscode.commands.registerCommand("contextkeeper.startAutoLint", () => {
            if (fileWatcher) {
                vscode.window.showWarningMessage("Auto-lint is already running!");
                return;
            }
            const config = vscode.workspace.getConfiguration("contextkeeper");
            const endpoint = config.get("lintingEndpoint") || "https://contextkeeper-worker.workers.dev/lint";
            fileWatcher = new fileWatcher_1.FileWatcher(endpoint);
            fileWatcher.start();
            vscode.window.showInformationMessage("Auto-lint enabled! Files will be checked on save.");
        }));
        this.context.subscriptions.push(vscode.commands.registerCommand("contextkeeper.stopAutoLint", () => {
            if (!fileWatcher) {
                vscode.window.showWarningMessage("Auto-lint is not running!");
                return;
            }
            fileWatcher.stop();
            fileWatcher = null;
            vscode.window.showInformationMessage("Auto-lint disabled.");
        }));
    }
    async refreshContext() {
        try {
            const context = await this.contextService.collectContext();
            this.sidebarProvider.updateContext(context);
        }
        catch (error) {
            NotificationManager_1.NotificationManager.showError(`Failed to collect context: ${error.message}`);
        }
    }
    async runAnalysis() {
        try {
            const context = await this.contextService.collectContext();
            const editor = vscode.window.activeTextEditor;
            const code = editor ? editor.document.getText() : '';
            await NotificationManager_1.NotificationManager.withProgress('Analyzing code...', async (progress) => {
                progress.report({ increment: 0, message: 'Collecting context' });
                const analysis = await this.aiService.analyze(code, context);
                progress.report({ increment: 100, message: 'Complete!' });
                return analysis;
            });
        }
        catch (error) {
            const state = {
                status: 'error',
                error: error.message,
            };
            this.statusBar.setState(state);
            this.sidebarProvider.showError(error.message);
            await NotificationManager_1.NotificationManager.showErrorWithRetry(`Analysis failed: ${error.message}`, () => this.runAnalysis());
        }
    }
}
exports.CommandManager = CommandManager;


/***/ }),
/* 224 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ElevenLabsService = void 0;
const voices_1 = __webpack_require__(225);
const mock_1 = __webpack_require__(226);
const audio_player_1 = __webpack_require__(227);
class ElevenLabsService {
    apiKey = null;
    fallbackMode = false;
    mock = new mock_1.MockPlayer();
    audioPlayer = new audio_player_1.AudioPlayer();
    queue = [];
    isProcessing = false;
    async initialize(apiKey) {
        this.apiKey = apiKey || null;
        if (!this.apiKey) {
            this.fallbackMode = true;
            return;
        }
        // Verify API key with a lightweight user request instead of generating audio
        try {
            const controller = new AbortController();
            const timeout = setTimeout(() => controller.abort(), 5000);
            const res = await fetch('https://api.elevenlabs.io/v1/user', {
                headers: { 'xi-api-key': this.apiKey },
                signal: controller.signal
            });
            clearTimeout(timeout);
            if (!res.ok) {
                console.warn(`[ElevenLabs] API Key verification failed: ${res.status}`);
                this.fallbackMode = true;
            }
        }
        catch (err) {
            console.warn('[ElevenLabs] Connection check failed, using fallback', err);
            this.fallbackMode = true;
        }
    }
    isReady() {
        return !this.fallbackMode && !!this.apiKey;
    }
    isEnabled() {
        return this.isReady();
    }
    clearQueue() {
        this.queue = [];
    }
    async speak(text, voice = 'casual') {
        return new Promise((resolve, reject) => {
            this.queue.push({ text, voice, resolve, reject });
            this.processQueue();
        });
    }
    async processQueue() {
        if (this.isProcessing || this.queue.length === 0) {
            return;
        }
        this.isProcessing = true;
        const item = this.queue.shift();
        if (!item) {
            this.isProcessing = false;
            return;
        }
        try {
            await this.performSpeak(item.text, item.voice);
            item.resolve();
        }
        catch (error) {
            console.error(`Error speaking "${item.text}":`, error);
            item.resolve(); // Resolve anyway to keep queue moving
        }
        finally {
            this.isProcessing = false;
            this.processQueue();
        }
    }
    async performSpeak(text, voice) {
        if (this.fallbackMode || !this.apiKey) {
            await this.mock.play(text, voice);
            return;
        }
        const voiceId = (0, voices_1.getVoiceId)(voice);
        const url = `https://api.elevenlabs.io/v1/text-to-speech/${encodeURIComponent(voiceId)}`;
        const body = JSON.stringify({ text });
        console.log(`[ElevenLabs] Requesting TTS for: "${text}" (Voice: ${voiceId})`);
        try {
            const controller = new AbortController();
            const timeout = setTimeout(() => controller.abort(), 15000); // 15s timeout for generation
            const res = await fetch(url, {
                method: 'POST',
                headers: {
                    'xi-api-key': this.apiKey,
                    'Content-Type': 'application/json'
                },
                body,
                signal: controller.signal
            });
            clearTimeout(timeout);
            if (!res.ok) {
                console.warn(`ElevenLabs API error: ${res.status} ${res.statusText}`);
                await this.mock.play(text, voice);
                return;
            }
            const audioData = await res.arrayBuffer();
            await this.audioPlayer.play(audioData);
        }
        catch (error) {
            console.error('[ElevenLabs] Network error:', error);
            await this.mock.play(text, voice);
        }
    }
}
exports.ElevenLabsService = ElevenLabsService;


/***/ }),
/* 225 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.voiceMap = void 0;
exports.getVoiceId = getVoiceId;
exports.voiceMap = {
    // Using standard ElevenLabs voices:
    // Rachel (American, calm)
    casual: '21m00Tcm4TlvDq8ikWAM',
    // Antoni (American, well-modulated)
    professional: 'ErXwobaYiN019PkySvjV',
    // Josh (American, deep)
    encouraging: 'TxGEqnHWrfWFTfGW9XjX'
};
function getVoiceId(voice) {
    return exports.voiceMap[voice] || exports.voiceMap.casual;
}


/***/ }),
/* 226 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MockPlayer = void 0;
class MockPlayer {
    async play(text, voice = 'casual') {
        // Simple console fallback for environments without ElevenLabs access
        console.log(`[VOICE - ${voice}]: ${text}`);
    }
}
exports.MockPlayer = MockPlayer;


/***/ }),
/* 227 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AudioPlayer = void 0;
const child_process_1 = __webpack_require__(189);
const fs_1 = __webpack_require__(6);
const os = __importStar(__webpack_require__(221));
const path = __importStar(__webpack_require__(25));
class AudioPlayer {
    playerCommand = null;
    constructor() {
        this.detectPlayer();
    }
    async detectPlayer() {
        const platform = process.platform;
        if (platform === 'darwin') {
            this.playerCommand = 'afplay';
        }
        else if (platform === 'linux') {
            // Check if mpg123 is available
            try {
                await new Promise((resolve, reject) => {
                    const child = (0, child_process_1.spawn)('which', ['mpg123']);
                    child.on('close', (code) => code === 0 ? resolve(true) : reject());
                    child.on('error', reject);
                });
                this.playerCommand = 'mpg123';
            }
            catch {
                console.warn('mpg123 not found, audio playback will be disabled on Linux');
                this.playerCommand = null;
            }
        }
        else if (platform === 'win32') {
            this.playerCommand = 'powershell.exe';
        }
    }
    async play(audioData) {
        if (!this.playerCommand) {
            console.log('[Audio] No audio player available, skipping playback.');
            return;
        }
        const buffer = Buffer.from(audioData);
        const tmpDir = os.tmpdir();
        const fileName = `elevenlabs_${Date.now()}.mp3`;
        const filePath = path.join(tmpDir, fileName);
        try {
            await fs_1.promises.writeFile(filePath, buffer);
            const platform = process.platform;
            let args = [];
            let durationEstimate = 10000; // Default 10s
            // Rough estimate: 1MB mp3 ~ 1 minute. 
            // buffer.length is bytes. 
            // 100KB ~ 6 seconds.
            // 128kbps = 16KB/s.
            // Let's be more generous with the estimate.
            durationEstimate = Math.max(5000, (buffer.length / 10000) * 1000);
            console.log(`[Audio] Buffer size: ${buffer.length} bytes. Estimated duration: ${durationEstimate}ms`);
            if (platform === 'darwin') {
                args = [filePath];
            }
            else if (platform === 'linux') {
                args = ['-q', filePath];
            }
            else if (platform === 'win32') {
                // Improved PowerShell command that waits for media to end
                // Note: This is still tricky in pure PowerShell without blocking the UI thread too much
                // We'll stick to a simpler approach but use the estimated duration
                const seconds = Math.ceil(durationEstimate / 1000) + 1;
                args = ['-c', `Add-Type -AssemblyName presentationCore;` +
                        `$player = New-Object System.Windows.Media.MediaPlayer;` +
                        `$player.Open([System.Uri]::new('${filePath}'));` +
                        `$player.Play();` +
                        `Start-Sleep -s ${seconds}`];
            }
            await new Promise((resolve) => {
                console.log(`[Audio] Spawning: ${this.playerCommand} ${args.join(' ')}`);
                // Use 'pipe' to capture output for debugging
                const child = (0, child_process_1.spawn)(this.playerCommand, args, { stdio: 'pipe', detached: false });
                child.stdout?.on('data', (data) => console.log(`[Audio Player stdout]: ${data}`));
                child.stderr?.on('data', (data) => console.error(`[Audio Player stderr]: ${data}`));
                const timeout = setTimeout(() => {
                    try {
                        child.kill();
                    }
                    catch { }
                    resolve();
                }, durationEstimate + 2000); // Add buffer
                child.on('error', (err) => {
                    console.error(`[Audio] Player error: ${err.message}`);
                    clearTimeout(timeout);
                    resolve();
                });
                child.on('close', (code) => {
                    if (code !== 0) {
                        console.error(`[Audio] Player exited with code ${code}`);
                    }
                    clearTimeout(timeout);
                    resolve();
                });
            });
        }
        catch (error) {
            console.error('[Audio] Playback failed:', error);
        }
        finally {
            fs_1.promises.unlink(filePath).catch(() => { });
        }
    }
}
exports.AudioPlayer = AudioPlayer;


/***/ }),
/* 228 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseJsonFromText = parseJsonFromText;
/**
 * robustly parses JSON from a string that might contain markdown code blocks or other text.
 */
function parseJsonFromText(text, fallback) {
    try {
        // 1. Try to find JSON within markdown code blocks
        const markdownJsonRegex = /```(?:json)?\s*([\s\S]*?)\s*```/g;
        const matches = [...text.matchAll(markdownJsonRegex)];
        for (const match of matches) {
            try {
                return JSON.parse(match[1]);
            }
            catch (e) {
                // Continue to next match if parsing fails
            }
        }
        // 2. If no markdown blocks or parsing failed, try to find the first '{' and last '}'
        const firstBrace = text.indexOf('{');
        const lastBrace = text.lastIndexOf('}');
        if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
            const jsonStr = text.substring(firstBrace, lastBrace + 1);
            try {
                return JSON.parse(jsonStr);
            }
            catch (e) {
                // Fall through
            }
        }
        // 3. Try parsing the whole text
        return JSON.parse(text);
    }
    catch (e) {
        console.warn("Failed to parse JSON from text:", e);
        return fallback;
    }
}


/***/ }),
/* 229 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GitService = void 0;
const child_process_1 = __webpack_require__(189);
const util_1 = __webpack_require__(13);
const execPromise = (0, util_1.promisify)(child_process_1.exec);
class GitService {
    repoPath;
    constructor(repoPath) {
        this.repoPath = repoPath;
    }
    async getRecentCommits(limit = 10) {
        try {
            // Dynamic import to handle ESM module in CJS environment
            const gitlogModule = await __webpack_require__.e(/* import() */ 1).then(__webpack_require__.bind(__webpack_require__, 3));
            // @ts-ignore
            const gitlog = gitlogModule.default || gitlogModule;
            // @ts-ignore
            const promiseFunc = gitlog.gitlogPromise || gitlog;
            const commits = await promiseFunc({
                repo: this.repoPath,
                number: limit,
                fields: ["hash", "authorName", "authorDate", "subject", "files"],
            });
            return commits.map((c) => ({
                hash: c.hash,
                message: c.subject,
                author: c.authorName,
                date: new Date(c.authorDate),
                files: c.files || [],
            }));
        }
        catch (error) {
            console.error("Failed to fetch git logs:", error);
            return [];
        }
    }
    async getCurrentBranch() {
        try {
            const { stdout } = await execPromise('git branch --show-current', { cwd: this.repoPath });
            return stdout.trim();
        }
        catch (e) {
            return "unknown";
        }
    }
    async createBranch(name) {
        await execPromise(`git checkout -b ${name}`, { cwd: this.repoPath });
    }
    async commit(message, files = ['.']) {
        await execPromise(`git add ${files.join(' ')} && git commit -m "${message}"`, { cwd: this.repoPath });
    }
    async applyDiff(diff) {
        // This is complex to implement with just exec, usually requires a patch file
        // For now, we'll leave it as a placeholder or implement basic apply
        throw new Error("Method not implemented.");
    }
}
exports.GitService = GitService;


/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".extension.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/require chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "loaded", otherwise not loaded yet
/******/ 		var installedChunks = {
/******/ 			0: 1
/******/ 		};
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		var installChunk = (chunk) => {
/******/ 			var moreModules = chunk.modules, chunkIds = chunk.ids, runtime = chunk.runtime;
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) runtime(__webpack_require__);
/******/ 			for(var i = 0; i < chunkIds.length; i++)
/******/ 				installedChunks[chunkIds[i]] = 1;
/******/ 		
/******/ 		};
/******/ 		
/******/ 		// require() chunk loading for javascript
/******/ 		__webpack_require__.f.require = (chunkId, promises) => {
/******/ 			// "1" is the signal for "already loaded"
/******/ 			if(!installedChunks[chunkId]) {
/******/ 				if(true) { // all chunks have JS
/******/ 					var installedChunk = require("./" + __webpack_require__.u(chunkId));
/******/ 					if (!installedChunks[chunkId]) {
/******/ 						installChunk(installedChunk);
/******/ 					}
/******/ 				} else installedChunks[chunkId] = 1;
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		// no external install chunk
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__(0);
/******/ 	module.exports = __webpack_exports__;
/******/ 	
/******/ })()
;
//# sourceMappingURL=extension.js.map